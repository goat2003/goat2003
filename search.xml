<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/05/31/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
      <url>2021/05/31/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><p><strong>首先是doc头</strong></p></blockquote><p>重点关注字段是<strong>e_magic</strong>和<strong>e_lfnew</strong>这两个，e_magic可以确定该程序是否是可执行文件，而e_lfnew可以告诉编译器程序的开始的位置，如图中e8表示从e8位开始，中间的数据为垃圾数据。<br><img src="https://img-blog.csdnimg.cn/20210601124233560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="dos头"></p><blockquote><p><strong>其次是nt头</strong></p></blockquote><p>nt头包含三个部分，第一部分是一个四字节长度的pe文件头标志。第二部分是image_file_header，也就是标准pe头，这个结构的长度为二十个字节，第三部分为image_optional_header，也就是pe可选文件头<br><img src="https://img-blog.csdnimg.cn/20210601124831230.png" alt="nt头"></p><blockquote><p><strong>首先是标准pe头的字段</strong></p></blockquote><p>Machine：该文件的运行平台，是x86、x64还是I64</p><p>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数。</p><p>TimeDateStamp：PE文件的创建时间，一般有连接器填写。</p><p>PointerToSymbolTable：COFF文件符号表在文件中的偏移。</p><p>NumberOfSymbols：符号表的数量。</p><p>SizeOfOptionalHeader：紧随其后的可选头的大小。</p><p>Characteristics：可执行文件的属性，可以是下面这些值按位相或。</p><blockquote><p><strong>pe可选头</strong></p></blockquote><p>AddressOfEntryPoint：程序入口的RVA，对于exe这个地址可以理解为WinMain的RVA。对于DLL，这个地址可以理解为DllMain的RVA，如果是驱动程序，可以理解为DriverEntry的RVA。</p><p>BaseOfCode：代码段起始地址的RVA。</p><p>BaseOfData：数据段起始地址的RVA。</p><p>ImageBase：映象（加载到内存中的PE文件）的基地址，这个基地址是建议，对于DLL来说，如果无法加载到这个地址，系统会自动为其选择地址。</p><p>SectionAlignment：节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。</p><p>FileAlignment：节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。</p><p>SizeOfImage：映象的大小，PE文件加载到内存中空间是连续的，这个值指定占用虚拟空间的大小。</p><p>SizeOfHeaders：所有文件头（包括节表）的大小，这个值是FileAlignment对齐的。</p><p>CheckSum：映象文件的校验和。</p><p>SizeOfStackReserve：运行时为每个线程栈保留内存的大小。</p><p>SizeOfStackCommit：运行时每个线程栈初始占用内存大小。</p><p>SizeOfHeapReserve：运行时为进程堆保留内存大小。</p><p>SizeOfHeapCommit：运行时进程堆初始占用内存大小。</p><p>NumberOfRvaAndSizes：数据目录的项数，即下面这个数组的项数</p><p>DataDirectory：数据目录，这是一个数组，数组的项定义如下：</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
