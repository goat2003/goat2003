<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%938/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%938/</url>
      
        <content type="html"><![CDATA[<p>title: pe总结8<br>date: 2021-06-15 15:56:28<br>top_img: /images/002.jpg<br>cover: /images/004.jpg<br>tags: </p><ul><li>pe<br>categories: pe</li></ul><p>前面学习了PE的结构后，尝试结合先前所学，修改PE文件来实现给程序添加弹窗的功能PS：这篇笔记并<strong>没有怎么涉及PE的知识点</strong>，重点放在了<strong>HOOK、反汇编和硬编码</strong>上，对PE不是很了解也可以看看，涉及PE知识点的内容放在了后面的笔记：<a href="https://www.52pojie.cn/thread-1409183-1-1.html">PE文件笔记九 实战之HOOK程序添加弹窗续</a>，可以放心食用（￣︶￣）↗　PE实战之给程序添加弹窗修改流程要给程序添加弹窗，首先就是要了解其修改的流程首先要修改的便是程序原本的入口地址，将其修改为弹窗代码所在的地址弹窗代码所在的地址，要在PE文件中找到一片区域，该区域需要 满足 可执行、可读、可写的权限，然后在这片区域写入弹窗代码，弹窗代码的最后要<strong>跳转回</strong>原本的入口地址该修改流程是一种十分经典的HOOK思想，即程序按照原本的流程执行着，你把它原本执行的代码修改了，修改去干我们想要做的事情，做完我们想要的事情后再把它放回去继续执行原本的代码图解HOOK修改流程<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403010059279.png" alt="image-20210403010059279">被HOOK的地方为B正常流程 A→B→CHOOK流程 A→被HOOK的B→自己的代码→复原B中被修改的部分→跳转回B原本要接着执行的地方→C图解给程序添加弹窗<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403010119501.png" alt="image-20210403010119501">弹窗代码既然要给程序添加弹窗，自然需要知道如何通过代码显示一个简单的弹窗下面给出一个简单的弹窗代码<code> *复制代码* *隐藏代码 *#include &lt;Windows.h&gt; int main() &#123;   //调用MessageBoxA函数   //显示一个 没有所有者窗口的、内容为lyl610abc的、标题为tips的、只包含一个按钮:OK的 窗口   MessageBoxA(0, &quot;lyl610abc&quot;, &quot;tips&quot;, 0);   return 0; &#125;</code>运行结果<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402190334225.png" alt="image-20210402190334225">MessageBoxA下面为介绍MessageBoxA的使用文档，<strong>熟悉MessageBoxA的可以跳过</strong>，直接跳到后面的<strong>查看反汇编</strong>即可函数原型<code> *复制代码* *隐藏代码 *int MessageBoxA(  HWND  hWnd,  LPCSTR lpText,  LPCSTR lpCaption,  UINT  uType );</code>参数参数参数类型含义hWndHWND(int)要创建的消息框的所有者窗口的句柄。如果该参数为空，则消息框没有所有者窗口lpTextLPCSTR(CONST CHAR <em>)要显示的消息。如果字符串包含多行，可以在每行之间使用回车符和/或换行符来分隔行lpCaptionLPCSTR(CONST CHAR <em>)对话框的标题。如果该参数为空，则默认标题为ErroruTypeUINT(unsigned int)对话框的内容和行为uType对话框的内容和行为。该参数可以是下列标志组中的标志的<strong>组合</strong>要指示消息框中显示的按钮，请指定以下值之一：宏定义值含义MB_ABORTRETRYIGNORE0x00000002L消息框包含三个按钮:中止、重试和忽略MB_CANCELTRYCONTINUE0x00000006L消息框包含三个按钮:取消、重试、继续。使用此消息框类型而不是MB_ABORTRETRYIGNOREMB_HELP0x00004000L将“帮助”按钮添加到消息框。当用户单击帮助按钮或按下F1时，系统将向所有者发送一条WM_HELP消息MB_OK0x00000000L消息框包含一个按钮:OK。这是默认值MB_OKCANCEL0x00000001L消息框包含两个按钮:OK和CancelMB_RETRYCANCEL0x00000005L消息框包含两个按钮:重试和取消MB_YESNO0x00000004L消息框包含两个按钮:Yes和NoMB_YESNOCANCEL0x00000003LT消息框包含三个按钮:Yes、No和Cancel要在消息框中显示图标，请指定以下值之一：宏定义值含义MB_ICONEXCLAMATION0x00000030L消息框中会出现一个感叹号图标MB_ICONWARNING0x00000030L消息框中会出现一个感叹号图标MB_ICONINFORMATION0x00000040L消息框中会出现一个由小写字母i组成的圆圈图标MB_ICONASTERISK0x00000040L消息框中会出现一个由小写字母i组成的圆圈图标MB_ICONQUESTION0x00000020L一个问号图标出现在消息框中。不再推荐使用问号消息图标，因为它不能清楚地表示特定类型的消息，而且将消息表述为问题可以应用于任何类型的消息。此外，用户可能会将消息符号问号与帮助信息混淆。因此，不要在您的消息框中使用这个问号消息符号。系统继续支持它，只是为了向旧版本兼容MB_ICONSTOP0x00000010L消息框中出现停止标志图标MB_ICONERROR0x00000010L消息框中出现停止标志图标MB_ICONHAND0x00000010L消息框中出现停止标志图标要指定默认按钮，请指定以下值之一：宏定义值含义MB_DEFBUTTON10x00000000L第一个按钮是默认按钮。 除非指定了MB_DEFBUTTON2、MB_DEFBUTTON3或MB_DEFBUTTON4，否则MB_DEFBUTTON1是默认值MB_DEFBUTTON20x00000100L第二个按钮是默认按钮MB_DEFBUTTON30x00000200L第三个按钮是默认按钮.MB_DEFBUTTON40x00000300L第四个按钮是默认按钮若要指示对话框的模式，请指定以下值之一：宏定义值含义MB_APPLMODAL0x00000000L用户必须响应消息框，然后才能在hWnd参数标识的窗口中继续工作。然而，用户可以移动到其他线程的窗口并在这些窗口中工作。 根据应用程序中窗口的层次结构，用户可以移动到线程中的其他窗口。消息框父窗口的所有子窗口都会被自动禁用，但弹出窗口不会。 如果没有指定MB_SYSTEMMODAL或MB_TASKMODAL，则MB_APPLMODAL是默认值MB_SYSTEMMODAL0x00001000L与MB_APPLMODAL相同，只是消息框具有WS_EX_TOPMOST样式。使用系统模式消息框来通知用户需要立即注意的严重的、潜在的破坏性错误(例如，内存耗尽)。这个标志对用户与windows交互的能力没有影响，除了那些与hWnd相关的MB_TASKMODAL0x00002000L与MB_APPLMODAL相同，只是当hWnd参数为NULL时，属于当前线程的所有顶级窗口都被禁用。当调用应用程序或库没有可用的窗口句柄，但仍然需要防止输入到调用线程中的其他窗口而不挂起其他线程时，使用此标志要指定其他选项，请使用下列一个或多个值：宏定义值含义MB_DEFAULT_DESKTOP_ONLY0x00020000L与交互式窗口站的桌面相同。有关更多信息，请参见<a href="https://docs.microsoft.com/en-us/windows/desktop/winstation/window-stations">Window Stations</a>. 如果当前输入的桌面不是默认桌面，MessageBox直到用户切换到默认桌面才会返回。MB_RIGHT0x00080000L文本是右对齐的MB_RTLREADING0x00100000L在希伯来语和阿拉伯语系统上使用从右到左的阅读顺序显示消息和标题文本MB_SETFOREGROUND0x00010000L消息框成为前台窗口。在内部，系统为消息框调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a>函数MB_TOPMOST0x00040000L消息框使用WS_EX_TOPMOST窗口样式创建MB_SERVICE_NOTIFICATION0x00200000L调用者是一个通知用户事件的服务。即使没有用户登录到计算机，该功能也会在当前活动桌面上显示一个消息框。 终端服务:如果调用线程有一个模拟令牌，该函数将消息框定向到模拟令牌中指定的会话。 如果设置此标志，则hWnd参数必须为空。这样可以在hWnd对应的其他桌面上显示该消息框。 有关使用此标志的安全注意事项的信息，请参见<a href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services">Interactive Services</a>。特别要注意的是，这个标志可以在锁定的桌面上生成交互式内容，因此应该只用于非常有限的场景，比如资源耗尽。返回值返回值类型：int如果消息框有一个取消按钮，如果ESC键被按下或取消按钮被选中，该函数将返回IDCANCEL值。如果消息框没有取消按钮，按ESC将没有效果-除非MB_OK按钮存在。如果出现MB_OK按钮，按“ESC”键，返回值为“IDOK”。如果函数失败，返回值为0。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>如果函数成功，返回值是下面的菜单项值之一:返回码值描述IDABORT3Abort按钮被选中IDCANCEL2Cancel按钮被选中IDCONTINUE11Continue按钮被选中IDIGNORE5Ignore按钮被选中IDNO7No按钮被选中IDOK1OK按钮被选中IDRETRY4Retry按钮被选中IDTRYAGAIN10Try Again按钮被选中IDYES6Yes按钮被选中通过将uType参数设置为对应的标志值，可以在消息框中使用以下系统图标图标Flag 值<img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconhand.png" alt="Icon for MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR"><strong>MB_ICONHAND</strong>, <strong>MB_ICONSTOP</strong>, 或 <strong>MB_ICONERROR</strong><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconquestion.png" alt="Icon for MB_ICONQUESTION"><strong>MB_ICONQUESTION</strong><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconexclamation.png" alt="Icon for MB_ICONEXCLAMATION and MB_ICONWARNING"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconasterisk.png" alt="Icon for MB_ICONASTERISK and MB_ICONINFORMATION"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong>查看反汇编<code> *复制代码* *隐藏代码 *9:     MessageBoxA(0,&quot;lyl610abc&quot;,&quot;tips&quot;,0); 00401028 8B F4          mov      esi,esp 0040102A 6A 00          push     0 0040102C 68 28 20 42 00    push     offset string &quot;tips&quot; (00422028) 00401031 68 1C 20 42 00    push     offset string &quot;lyl610abc&quot; (0042201c) 00401036 6A 00          push     0 00401038 FF 15 AC A2 42 00  call     dword ptr [__imp__MessageBoxA@16 (0042a2ac)] 0040103E 3B F4          cmp      esi,esp 00401040 E8 2B 00 00 00    call     __chkesp (00401070)</code>这里截取出关键的代码<code> *复制代码* *隐藏代码 *0040102A 6A 00          push     0 0040102C 68 28 20 42 00    push     offset string &quot;tips&quot; (00422028) 00401031 68 1C 20 42 00    push     offset string &quot;lyl610abc&quot; (0042201c) 00401036 6A 00          push     0 00401038 FF 15 AC A2 42 00  call     dword ptr [__imp__MessageBoxA@16 (0042a2ac)]</code>其余代码说明<code> *复制代码* *隐藏代码 *00401028 8B F4          mov      esi,esp          //保存执行前的esp(栈顶)到esi 0040103E 3B F4          cmp      esi,esp          //比较esi和执行完call后的esp(栈顶) 00401040 E8 2B 00 00 00    call     __chkesp (00401070)     //调用检测esp的函数</code>用来检测，调用完函数后堆栈是否保持平衡，是C语言自动生成的，这里无需关注解析反汇编<code> *复制代码* *隐藏代码 *0040102A 6A 00          push     0 0040102C 68 28 20 42 00    push     offset string &quot;tips&quot; (00422028) 00401031 68 1C 20 42 00    push     offset string &quot;lyl610abc&quot; (0042201c) 00401036 6A 00          push     0</code>前四行代码是依次压入四个参数（从右到左压入），这和调用协定相关，在<a href="https://www.52pojie.cn/thread-1380788-1-1.html">逆向基础笔记九 C语言内联汇编和调用协定</a>已说过，这里不再赘述<code> *复制代码* *隐藏代码 *00401038 FF 15 AC A2 42 00  call     dword ptr [__imp__MessageBoxA@16 (0042a2ac)]</code>调用call这里，可以看到这是一个间接调用，形式为call [地址]，所以这里要查看一下其实际地址里存储的内容是什么，也就是其实际call的地址通过内存窗口可以得到，其实际call的地址为77D507EA<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402192114225.png" alt="image-20210402192114225">所以此时的代码相当于<code> *复制代码* *隐藏代码 *00401038     call     77D507EA</code>这里为什么是一个间接call，77D507EA代表什么？这里<strong>采用间接call的原因是引用了导入表</strong>，关于导入表和导出表的内容之后的笔记会再做说明这里的77D507EA<strong>代表的是MessageBoxA函数的地址</strong>每个电脑的MessageBoxA函数的地址<strong>不一定相同</strong>，它取决于系统的user32.dll中导出表中给出的地址（这里调用的MessageBoxA是由user32.dll提供的）可以用IDA来验证这一点：找到系统中的user32.dll（在32位的xp中在C:\WINDOWS\system32下，在64位系统中则有2个，一个在C:\Windows\SysWOW64下(32位的dll)，一个也在C:\WINDOWS\system32下(64位的dll)，<strong>具体使用哪个取决于程序是32位还是64位</strong>）<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402193359108.png" alt="image-20210402193359108">将其用IDA打开，找到导出表，然后在导出表中搜索得到MessageBoxA<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402193459557.png" alt="image-20210402193459557">可以看到它的地址和前面得到的一致，为77D507EA，验证来源完毕<strong>注意此时的系统是XP32位</strong>，在其它高版本的系统中这里的Address<strong>并不一定能和前面的一致</strong>，这里主要是为了说明<strong>函数的来源与导入表和导出表有关</strong>，也说明了<strong>为何不同系统的MessageBoxA的地址不一定相同</strong>，为后面的学习作个铺垫<strong>准确得到函数地址的方法为</strong>：如果想要得到MessageBoxA函数的（其它函数同理）地址，首先要找到一个有调用这个函数所属的模块的程序（MessageBoxA所属的模块为user32.dll），使用OD附加来查找：一般来说只要是图形化的程序都会调用user32.dll这个模块，于是这里就随便拿一个exe程序就行，这里以dbgview.exe为例使用OD打开dbgview.exe，然后单击图中所指的e，或者使用快捷键Alt+E<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202400705.png" alt="image-20210402202400705">在弹出来的窗口中找到user32.dll，双击<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202544557.png" alt="image-20210402202544557">在弹出来的反汇编界面按快捷键 Ctrl+N<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202741746.png" alt="image-20210402202741746">然后在新窗口找到MessageBoxA对应的地址即可<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202903145.png" alt="image-20210402202903145">此时得到的地址就是准确的MessageBoxA地址了自写反汇编测试测试代码既然得到了MessageBoxA的函数地址，就无需间接调用了，可以直接调用它，于是自写代码如下：<code> *复制代码* *隐藏代码 *#include&lt;stdio.h&gt; #include &lt;windows.h&gt; int MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;      int ret;   //这里的地址填前面通过OD得到的MessageBoxA地址,每个系统不一定相同   //先前是在xp系统中测试的，那时的MessageBoxA为77D507EA   //此时换到WIN10 X64 测试，修改MessageBoxA的值      int addr = 0x76a3ee90;      __asm &#123;           push hWnd                     push lpCaption      push lpText           push uType           call addr           mov ret, eax      &#125;      return ret; &#125; int main(int argc, char* argv[]) &#123;      MyMessageBoxA(0, &quot;lyl610abc&quot;, &quot;tips&quot;, 0);      return 0; &#125;</code>测试结果<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402203720618.png" alt="image-20210402203720618">依然能够正常弹窗，测试成功反汇编转为硬编码(字节码)通过先前的学习可以知道在计算机中，无论是执行的代码还是数据都是以二进制来存储的，为了方便查看，进制查看工具将内容以十六进制的方式展示所以为了给程序添加弹窗，显然就不是直接将反汇编写入PE文件中，而是<strong>要将反汇编对应的硬编码(字节码)写入到PE文件中</strong>如何将反汇编转化为硬编码？这个是<strong>反汇编引擎</strong>所做的事，在OD或VC中的反汇编引擎已经将反汇编对应的硬编码(字节码)给出了有关反汇编引擎的内容也属于硬编码相关的知识，<strong>看以后要不要开这个坑</strong>将前面写的反汇编再稍作修改，将参数写死，并且去掉返回值的接收修改反汇编代码<code> *复制代码* *隐藏代码 *#include&lt;stdio.h&gt; #include &lt;windows.h&gt; void MyMessageBoxA() &#123;   //获取MessageBoxA的地址      int addr = (int)&amp;MessageBoxA;      printf(&quot;addr:%X\n&quot;, addr);   //&quot;lyl610abc&quot;对应的ASCII编码 6c 79 6c 36 31 30 61 62 63      unsigned char bytes[] = &#123; 0x6c,0x79,0x6c,0x36,0x31,0x30,0x61,0x62,0x63,0x00 &#125;;   //&quot;tips&quot;对应的ASCII编码      unsigned char bytes2[] = &#123; 0x74,0x69,0x70,0x73 &#125;;      //申请内存，该内存的属性为可执行 可读可写      LPVOID _lpText = VirtualAlloc(NULL, sizeof(byte), MEM_COMMIT, PAGE_EXECUTE_READWRITE);      //申请内存，该内存的属性为可执行 可读可写      LPVOID _lpCaption = VirtualAlloc(NULL, sizeof(byte), MEM_COMMIT, PAGE_EXECUTE_READWRITE);      //将硬编码写入申请的有权限的内存中      WriteProcessMemory(INVALID_HANDLE_VALUE, (LPVOID)_lpText, (BYTE*)bytes, sizeof(bytes), 0);      //将硬编码写入申请的有权限的内存中      WriteProcessMemory(INVALID_HANDLE_VALUE, (LPVOID)_lpCaption, (BYTE*)bytes2, sizeof(bytes2), 0);      __asm &#123;           push 0           push _lpCaption           push _lpText           push 0           call addr      &#125; &#125; int main(int argc, char* argv[]) &#123;      MyMessageBoxA();      return 0; &#125;</code>OD模拟代码操作<strong>先总结一下上面修改后的反汇编代码做了什么</strong>获得MessageBoxA的函数地址将字符串对应的ASCII码写入到<strong>可读可写</strong>的一片内存中压入参数调用MessageBoxA函数调用完后跳转回原本要执行的代码<strong>然后在OD中复现操作</strong>用OD随便载入一个<strong>包含user32.dll模块</strong>的程序，我这里直接拿前面的代码编译后的程序来作演示<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402232452491.png" alt="image-20210402232452491">按照前面总结的步骤来<strong>1.MessageBoxA在OD中的地址是已知的无需获取</strong></em></em>2.将字符串对应的ASCII码写入到可读可写的一片内存中<strong>首先是选取一块可读可写的内存，很显然，接下来要执行的代码一定是可读可写可执行的，于是这里就无须申请内存了，直接将下面的代码覆盖即可解决了选取内存的问题，接下来就是将字符串对应的ASCII码写入内存即可，但这要放在压入参数之后，原因后面会说明，现在先看压入参数</strong>3.压入参数<strong>第一个参数为0，直接将其对应的反汇编修改为push 0即可<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402233328019.png" alt="image-20210402233328019">第二个参数为_lpCaption，要写入的字符串为”tips”，但此时字符串还没写入内存，也就是并不确定字符串的内存地址，但可以确定一个大致的范围，要存放字符串的地方就在下方不远处，于是这里可以暂时先填写离这里不远的随便一个内存地址</strong>用来占位，等之后确定了字符串的内存地址后再回来修改<strong>这里就随便选取下面的地址00401156于是将反汇编修改为push 0x00401156<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402233751226.png" alt="image-20210402233751226">第三个参数为_lpText，要写入的字符串为”lyl610abc”，和前面的_lpCaption一样，先填入push xxxx占位，之后再回来修改于是依旧将其反汇编修改为push 0x00401156<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234015934.png" alt="image-20210402234015934">第四个参数为0，直接将其对应的反汇编修改为push 0即可<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234129978.png" alt="image-20210402234129978"><strong>4.调用MessageBoxA函数</strong>直接修改反汇编为call MessageBoxA即可<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234323243.png" alt="image-20210402234323243"><strong>5.调用完后跳转回原本要执行的代码</strong>这里是为了</strong>模拟之后执行完弹窗代码后再跳回程序入口<strong>这里随便模拟一个</strong>长跳转<strong>即可，修改反汇编代码为jmp 000412D0<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234825725.png" alt="image-20210402234825725">6.填充字符串到内存中下面的代码因为前面的绝对跳转是不会执行的，因此可以用来充当数据区，这也是</strong>要将字符串的填充放在后面的原因<strong>先填充_lpText，也就是”lyl610abc”选中跳转下的那一行，右键→二进制→编辑<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402235240410.png" alt="image-20210402235240410">选中ASCII，并将要写入内存的字符串 “lyl610abc”填入<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402235524407.png" alt="image-20210402235524407">填入后再选中Hex那一行，在后面添加00（字符串以’\0’结尾）<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000305968.png" alt="image-20210403000305968">添加完00后得到<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000401936.png" alt="image-20210403000401936">然后确定即可修改完得到<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000507711.png" alt="image-20210403000507711">这是第三个参数_lpText就可以修正了，将前面的压入第三个参数的反汇编修改为 push 0x00401148<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000803899.png" alt="image-20210403000803899">同样的方法填充第二个参数_lpCaption，也就是”tips”这里先记录一下其地址为0x00401152，然后开始修改<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001042513.png" alt="image-20210403001042513">修改完后得到：<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001221815.png" alt="image-20210403001221815">最后再修正先前push的用来占位的地址即可<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001315492.png" alt="image-20210403001315492">修改完成，这里记录一下修改的十六进制代码为<code> *复制代码* *隐藏代码 *6A 00 68 52 11 40 00 68 48 11 40 00 6A 00 E8 A7 F6 94 77 E9 88 01 C4 FF 6C 79 6C 36 31 30 61 62 63 00 74 69 70 73 00</code>修改完成后不断按F8单步步过，直call user32.MessageBoxA这<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001554670.png" alt="image-20210403001554670">可以看到，对应的参数是没有问题的最后再按F8单步步过即可看到结果：<img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001651536.png" alt="image-20210403001651536">能够按照代码弹框，完成( •̀ ω •́ )✧说明限于篇幅原因，这次的笔记主要讲解了</strong>弹窗代码的编写流程<strong>，之后的笔记则是将上面的硬编码稍作修改然后写入PE文件中再修改PE入口点来实现最终目的终于来到</strong>实战环节**了，前面关于知识点介绍的笔记看的人数一言难尽，希望通过实战能够勾起大家的兴趣，一起学习共同进步O(∩_∩)O最后再附上 上面OD修改的程序，有兴趣的可以跟着做一做</p><p><a href="https://www.52pojie.cn/forum.php?mod=attachment&aid=MjI1NDQyMHw4N2RlZThiOHwxNjIzNzQyMzE4fDB8MTQwODg2Ng==">MessageBoxA.zip</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1408866-1-1.html">大佬</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pe总结5</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%935/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%935/</url>
      
        <content type="html"><![CDATA[<p>继续具体学习PE的各个结构细节，前面学完了标准PE头，接着学习扩展PE头</p><p>由于PE文件头的内容较多，故要拆分为多个笔记，此笔记主要为<strong>扩展PE头</strong></p><p>PS：扩展PE头的成员较多，可以<strong>先看个大概后结合下面的实战分析</strong>来学习扩展PE头的成员</p><h1 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h1><h2 id="扩展PE头所属"><a href="#扩展PE头所属" class="headerlink" title="扩展PE头所属"></a>扩展PE头所属</h2><p><strong>扩展PE头是PE文件头中的一个成员</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328200236487.png" alt="img"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210329125412730.png" alt="img"></p><hr><h3 id="32位所属"><a href="#32位所属" class="headerlink" title="32位所属"></a>32位所属</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;                                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                               //标准PE头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;                                //扩展PE头 32位</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><hr><h3 id="64位所属"><a href="#64位所属" class="headerlink" title="64位所属"></a>64位所属</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">    DWORD Signature;                                       //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                          //标准PE头        </span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;                //扩展PE头 64位</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><hr><h2 id="两种扩展PE头差异"><a href="#两种扩展PE头差异" class="headerlink" title="两种扩展PE头差异"></a>两种扩展PE头差异</h2><h3 id="两种结构"><a href="#两种结构" class="headerlink" title="两种结构"></a>两种结构</h3><p>扩展PE头的结构根据程序是32位或64位而分成了两种结构，而PE文件头则因扩展PE头的差异也被分成了两种结构</p><table><thead><tr><th align="left">PE文件头结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">_IMAGE_NT_HEADERS</td><td align="left">32位程序对应的PE文件头结构</td></tr><tr><td align="left">_IMAGE_NT_HEADERS64</td><td align="left">64位程序对应的PE文件头结构</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER32</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER32</strong></td><td align="left">扩展PE头 32位</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS64</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识，固定值不可变</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER64</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER64</strong></td><td align="left">扩展PE头 64位</td></tr></tbody></table><hr><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><h4 id="32位结构体"><a href="#32位结构体" class="headerlink" title="32位结构体"></a>32位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><h4 id="64位结构体"><a href="#64位结构体" class="headerlink" title="64位结构体"></a>64位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;</span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><hr><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><table><thead><tr><th align="left">成员\扩展PE头</th><th align="left">_IMAGE_OPTIONAL_HEADER</th><th align="left">_IMAGE_OPTIONAL_HEADER64</th></tr></thead><tbody><tr><td align="left">BaseOfData</td><td align="left">DWORD</td><td align="left">无此成员</td></tr><tr><td align="left">ImageBase</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr></tbody></table><p>可以看到，64位相比于32位其实并没有太大的区别，只是删去了一个成员 以及 五个成员的数据类型由DWORD变为ULONGLONG</p><p>因为其<strong>区别并不明显</strong>，因此以<strong>32位</strong>结构体作为例子分析，64位结构体也<strong>近似相同</strong></p><hr><h2 id="32位扩展PE头分析"><a href="#32位扩展PE头分析" class="headerlink" title="32位扩展PE头分析"></a>32位扩展PE头分析</h2><p>扩展PE头中的成员较多，一般情况只需掌握部分重点即可（重点为表格中加黑的成员）</p><p>下面的分析参考自官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">ns-winnt-image_optional_header32</a>和《Windows PE 权威指南》</p><p>PS：下面的分析较为冗长,类似参考文档，<strong>可以先跳过，先看下面的实战分析</strong>，<strong>根据实战里的数据到对应的成员参考其含义</strong></p><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Magic</strong></td><td align="left">WORD(2字节)</td><td align="left">镜像文件的状态，可用于判断程序是32位还是64位</td></tr><tr><td align="left">MajorLinkerVersion</td><td align="left">BYTE(字节)</td><td align="left">链接器的主要版本号</td></tr><tr><td align="left">MinorLinkerVersion</td><td align="left">BYTE(字节)</td><td align="left">链接器的次要版本号</td></tr><tr><td align="left">SizeOfCode</td><td align="left">DWORD(4字节)</td><td align="left">代码段的大小</td></tr><tr><td align="left">SizeOfInitializedData</td><td align="left">DWORD(4字节)</td><td align="left">初始化数据段的大小</td></tr><tr><td align="left">SizeOfUninitializedData</td><td align="left">DWORD(4字节)</td><td align="left">未初始化数据段的大小</td></tr><tr><td align="left"><strong>AddressOfEntryPoint</strong></td><td align="left">DWORD(4字节)</td><td align="left">程序入口</td></tr><tr><td align="left">BaseOfCode</td><td align="left">DWORD(4字节)</td><td align="left">代码开始的基址</td></tr><tr><td align="left">BaseOfData</td><td align="left">DWORD(4字节)</td><td align="left">数据开始的基址</td></tr><tr><td align="left"><strong>ImageBase</strong></td><td align="left">DWORD(4字节)</td><td align="left">内存镜像基址</td></tr><tr><td align="left"><strong>SectionAlignment</strong></td><td align="left">DWORD(4字节)</td><td align="left">内存对齐</td></tr><tr><td align="left"><strong>FileAlignment</strong></td><td align="left">WORD(2字节)</td><td align="left">文件对齐</td></tr><tr><td align="left">MajorOperatingSystemVersion</td><td align="left">WORD(2字节)</td><td align="left">标识操作系统版本号 主版本号</td></tr><tr><td align="left">MinorOperatingSystemVersion</td><td align="left">WORD(2字节)</td><td align="left">标识操作系统版本号 次版本号</td></tr><tr><td align="left">MajorImageVersion</td><td align="left">WORD(2字节)</td><td align="left">PE文件自身的版本号</td></tr><tr><td align="left">MinorImageVersion</td><td align="left">WORD(2字节)</td><td align="left">PE文件自身的版本号</td></tr><tr><td align="left">MajorSubsystemVersion</td><td align="left">WORD(2字节)</td><td align="left">运行所需子系统版本号</td></tr><tr><td align="left">MinorSubsystemVersion</td><td align="left">WORD(2字节)</td><td align="left">运行所需子系统版本号</td></tr><tr><td align="left">Win32VersionValue</td><td align="left">DWORD(4字节)</td><td align="left">子系统版本的值，必须为0</td></tr><tr><td align="left"><strong>SizeOfImage</strong></td><td align="left">DWORD(4字节)</td><td align="left">Image大小</td></tr><tr><td align="left"><strong>SizeOfHeaders</strong></td><td align="left">DWORD(4字节)</td><td align="left">所有头+节表按照文件对齐后的大小</td></tr><tr><td align="left"><strong>CheckSum</strong></td><td align="left">DWORD(4字节)</td><td align="left">校验和</td></tr><tr><td align="left">Subsystem</td><td align="left">WORD(2字节)</td><td align="left">子系统</td></tr><tr><td align="left">DllCharacteristics</td><td align="left">WORD(2字节)</td><td align="left">文件特性 不只是针对DLL文件的</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">DWORD(4字节)</td><td align="left">初始化时保留的栈大小</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">DWORD(4字节)</td><td align="left">初始化时实际提交的大小</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">DWORD(4字节)</td><td align="left">初始化时保留的堆大小</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">DWORD(4字节)</td><td align="left">初始化时实践提交的大小</td></tr><tr><td align="left">LoaderFlags</td><td align="left">DWORD(4字节)</td><td align="left">调试相关</td></tr><tr><td align="left">NumberOfRvaAndSizes</td><td align="left">DWORD(4字节)</td><td align="left">目录项数目</td></tr><tr><td align="left"><strong>DataDirectory[16]</strong></td><td align="left">IMAGE_DATA_DIRECTORY[16]=128字节</td><td align="left">指向数据目录中第一个IMAGE_DATA_DIRECTORY结构的指针**(数据目录项)**</td></tr></tbody></table><hr><h3 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h3><p>镜像文件的状态。该成员可以是以下值之一</p><table><thead><tr><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_NT_OPTIONAL_HDR_MAGIC</td><td align="left">该文件是一个可执行的映像。这个值在32位应用程序中定义为IMAGE_NT_OPTIONAL_HDR32_MAGIC，在64位应用程序中定义为IMAGE_NT_OPTIONAL_HDR64_MAGIC</td></tr><tr><td align="left">IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b</td><td align="left">该文件是一个可执行的映像（32位）</td></tr><tr><td align="left">IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b</td><td align="left">该文件是一个可执行的映像（64位）</td></tr><tr><td align="left">IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107</td><td align="left">该文件是ROM镜像</td></tr></tbody></table><hr><h3 id="MajorLinkerVersion"><a href="#MajorLinkerVersion" class="headerlink" title="MajorLinkerVersion"></a>MajorLinkerVersion</h3><p>链接器版本号</p><hr><h3 id="MinorLinkerVersion"><a href="#MinorLinkerVersion" class="headerlink" title="MinorLinkerVersion"></a>MinorLinkerVersion</h3><p>链接器次要版本号</p><hr><h3 id="SizeOfCode"><a href="#SizeOfCode" class="headerlink" title="SizeOfCode"></a>SizeOfCode</h3><p>代码段的大小(以字节为单位)，如果有多个代码段，则为所有这些代码段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="SizeOfInitializedData"><a href="#SizeOfInitializedData" class="headerlink" title="SizeOfInitializedData"></a>SizeOfInitializedData</h3><p>初始化数据段的大小(以字节为单位)，如果有多个初始化数据段，则为所有这些数据段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="SizeOfUninitializedData"><a href="#SizeOfUninitializedData" class="headerlink" title="SizeOfUninitializedData"></a>SizeOfUninitializedData</h3><p>未初始化数据段的大小(以字节为单位)，如果有多个未初始化数据段，则为所有这些数据段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h3><p>一个指向入口点函数的指针，<strong>相对</strong>于Image的基址。</p><ol><li>对于可执行文件，这是起始地址</li><li>对于设备驱动程序，这是初始化函数的地址</li><li>入口点函数对于dll是可选的。当没有入口点存在时，该成员为零</li></ol><hr><h3 id="BaseOfCode"><a href="#BaseOfCode" class="headerlink" title="BaseOfCode"></a>BaseOfCode</h3><p>指向代码段开头的指针，相对于ImageBase。编译器填的 没用（不一定准确）</p><hr><h3 id="BaseOfData"><a href="#BaseOfData" class="headerlink" title="BaseOfData"></a>BaseOfData</h3><p>指向数据段开头的指针，相对于ImageBase。编译器填的 没用（不一定准确）</p><hr><h3 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a>ImageBase</h3><p>Image(PE文件)载入内存时第一个字节的首选地址。<strong>该值是64K字节的倍数</strong></p><ul><li>dll的默认值是0x10000000</li><li>应用程序的默认值为0x00400000,</li><li>Windows CE上的默认值为0x00010000</li></ul><hr><h3 id="SectionAlignment"><a href="#SectionAlignment" class="headerlink" title="SectionAlignment"></a>SectionAlignment</h3><p>加载到内存中的节的对齐方式，以字节为单位。该值必须大于或等于<strong>FileAlignment</strong>(文件对齐)成员。默认值是系统的页面大小</p><hr><h3 id="FileAlignment"><a href="#FileAlignment" class="headerlink" title="FileAlignment"></a>FileAlignment</h3><p>Image(PE文件)中各节的原始数据(以字节为单位)的对齐方式。该值应该是512到64K(包括)之间2的幂。缺省值是512。如果SectionAlignment成员小于系统页面大小，则该成员必须与SectionAlignment相同</p><hr><h3 id="MajorOperatingSystemVersion"><a href="#MajorOperatingSystemVersion" class="headerlink" title="MajorOperatingSystemVersion"></a>MajorOperatingSystemVersion</h3><p>所需操作系统的主要版本号</p><hr><h3 id="MinorOperatingSystemVersion"><a href="#MinorOperatingSystemVersion" class="headerlink" title="MinorOperatingSystemVersion"></a>MinorOperatingSystemVersion</h3><p>所需操作系统的次要版本号</p><hr><h3 id="MajorImageVersion"><a href="#MajorImageVersion" class="headerlink" title="MajorImageVersion"></a>MajorImageVersion</h3><p>镜像（PE文件）的主版本号</p><hr><h3 id="MinorImageVersion"><a href="#MinorImageVersion" class="headerlink" title="MinorImageVersion"></a>MinorImageVersion</h3><p>镜像（PE文件）的次要版本号</p><hr><h3 id="MajorSubsystemVersion"><a href="#MajorSubsystemVersion" class="headerlink" title="MajorSubsystemVersion"></a>MajorSubsystemVersion</h3><p>子系统的主要版本号</p><hr><h3 id="Win32VersionValue"><a href="#Win32VersionValue" class="headerlink" title="Win32VersionValue"></a>Win32VersionValue</h3><p>该成员是保留的，并且必须为0</p><hr><h3 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h3><p>Image的大小，以字节为单位，包括所有头。必须是多个SectionAlignment</p><p>内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment的整数倍</p><hr><h3 id="SizeOfHeaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a>SizeOfHeaders</h3><p>下列项的组合大小，舍入为“文件对齐”成员中指定值的倍数</p><ul><li>IMAGE_DOS_HEADER（DOS MZ头） 中的最后一个成员e_lfanew </li><li>PE文件头标志 signature 的 大小 4字节</li><li>IMAGE_FILE_HEADER（标准PE头）的大小</li><li>扩展PE头的大小</li><li>所有节头（节表）的大小</li></ul><p>SizeOfHeaders=</p><p>{</p><p>e_lfanew</p><p>+sizeof(signature)</p><p>+sizeof(_IMAGE_FILE_HEADER)</p><p>+sizeof(_IMAGE_OPTIONAL_HEADER)</p><p>+sizeof(_IMAGE_SECTION_HEADER)</p><p>}(文件对齐)</p><p>即 DOS部首+PE文件头+节表 按照文件对齐后的大小</p><hr><h3 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a>CheckSum</h3><p>Image(PE文件)校验和。以下文件在加载时进行验证:所有驱动程序，在引导时加载的任何DLL，以及加载到关键系统进程中的任何DLL</p><hr><h3 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h3><p>运行此映像所需的子系统。定义了以下值：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_SUBSYSTEM_UNKNOWN</td><td align="left">0</td><td align="left">未知的子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_NATIVE</td><td align="left">1</td><td align="left">不需要子系统(设备驱动程序和本机系统进程)</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_GUI</td><td align="left">2</td><td align="left">Windows图形用户界面子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_CUI</td><td align="left">3</td><td align="left">Windows字符模式用户界面(CUI)子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_OS2_CUI</td><td align="left">5</td><td align="left">OS/2 CUI子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_POSIX_CUI</td><td align="left">7</td><td align="left">POSIX CUI子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td><td align="left">9</td><td align="left">Windows CE系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_APPLICATION</td><td align="left">10</td><td align="left">可扩展固件接口(EFI)应用程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER</td><td align="left">11</td><td align="left">带有引导服务的EFI驱动程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</td><td align="left">12</td><td align="left">带有运行时服务的EFI驱动程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_ROM</td><td align="left">13</td><td align="left">EFI ROM镜像</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_XBOX</td><td align="left">14</td><td align="left">Xbox系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION</td><td align="left">16</td><td align="left">启动应用程序</td></tr></tbody></table><hr><h3 id="DllCharacteristics"><a href="#DllCharacteristics" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h3><h4 id="官方文档版本"><a href="#官方文档版本" class="headerlink" title="官方文档版本"></a>官方文档版本</h4><p>Image的DLL特性，定义了以下值</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">0x0001</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0002</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0004</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0008</td><td align="left">保留，必须为0</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA</td><td align="left">0x0020</td><td align="left">具有64位地址空间的ASLR</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</td><td align="left">0x0040</td><td align="left">DLL可以在加载时重新定位</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</td><td align="left">0x0080</td><td align="left">强制进行代码完整性检查。如果你设置了这个标志，并且section只包含未初始化的数据，那么将该section的IMAGE_SECTION_HEADER的PointerToRawData成员设置为0;否则，由于无法验证数字签名，Image将无法加载</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NX_COMPAT</td><td align="left">0x0100</td><td align="left">该映像与数据执行预防(DEP)兼容</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</td><td align="left">0x0200</td><td align="left">映像可以被隔离，但不应该被隔离</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_SEH</td><td align="left">0x0400</td><td align="left">该映像不使用结构化异常处理(SEH)。在此映像中不能调用任何处理程序</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_BIND</td><td align="left">0x0800</td><td align="left">不要绑定映像</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_APPCONTAINER</td><td align="left">0x1000</td><td align="left">映像应该在AppContainer中执行</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</td><td align="left">0x2000</td><td align="left">一个WDM驱动</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_GUARD_CF</td><td align="left">0x4000</td><td align="left">映像支持控制流保护(Control Flow Guard)</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</td><td align="left">0x8000</td><td align="left">该映像是终端服务器感知的</td></tr></tbody></table><hr><h4 id="PE权威指南版本"><a href="#PE权威指南版本" class="headerlink" title="PE权威指南版本"></a>PE权威指南版本</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330140944224.png" alt="image-20210330140944224"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330141007450.png" alt="image-20210330141007450"></p><hr><h3 id="SizeOfStackReserve"><a href="#SizeOfStackReserve" class="headerlink" title="SizeOfStackReserve"></a>SizeOfStackReserve</h3><p>为堆栈保留的字节数。只有SizeOfStackCommit成员指定的内存在加载时被提交;其余的页面每次只提供一个页面，直到达到这个预留大小</p><hr><h3 id="SizeOfStackCommit"><a href="#SizeOfStackCommit" class="headerlink" title="SizeOfStackCommit"></a>SizeOfStackCommit</h3><p>要提交给堆栈的字节数</p><hr><h3 id="SizeOfHeapReserve"><a href="#SizeOfHeapReserve" class="headerlink" title="SizeOfHeapReserve"></a>SizeOfHeapReserve</h3><p>为本地堆保留的字节数。只有SizeOfHeapCommit成员指定的内存在加载时被提交;其余的页面每次只提供一个页面，直到达到这个预留大小</p><hr><h3 id="SizeOfHeapCommit"><a href="#SizeOfHeapCommit" class="headerlink" title="SizeOfHeapCommit"></a>SizeOfHeapCommit</h3><p>要为本地堆提交的字节数</p><hr><h3 id="LoaderFlags"><a href="#LoaderFlags" class="headerlink" title="LoaderFlags"></a>LoaderFlags</h3><p>该成员已过时</p><hr><h3 id="NumberOfRvaAndSizes"><a href="#NumberOfRvaAndSizes" class="headerlink" title="NumberOfRvaAndSizes"></a>NumberOfRvaAndSizes</h3><p>可选头的其余部分中的目录条目数。每个条目都描述了一个位置和大小</p><hr><h3 id="DataDirectory"><a href="#DataDirectory" class="headerlink" title="DataDirectory"></a>DataDirectory</h3><p>指向数据目录中第一个IMAGE_DATA_DIRECTORY结构的指针</p><p>所需目录条目的索引号。该参数可以是以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td><td align="left">7</td><td align="left">特定于体系结构的数据，预留为0</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td><td align="left">5</td><td align="left">基地址重定位表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td><td align="left">11</td><td align="left">绑定导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td><td align="left">14</td><td align="left">COM描述符表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_DEBUG</td><td align="left">6</td><td align="left">调试表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td><td align="left">13</td><td align="left">延迟导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td><td align="left">3</td><td align="left">异常表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td><td align="left">0</td><td align="left">导出表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td><td align="left">8</td><td align="left">全局指针的相对虚拟地址</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_IAT</td><td align="left">12</td><td align="left">导入地址表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td><td align="left">1</td><td align="left">导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td><td align="left">10</td><td align="left">加载配置表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_RESOURCE</td><td align="left">2</td><td align="left">资源表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_SECURITY</td><td align="left">4</td><td align="left">安全表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_TLS</td><td align="left">9</td><td align="left">线程本地存储表</td></tr></tbody></table><hr><h2 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h2><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>从先前分析的标准PE头的结尾开始看起，选中部分为扩展PE头，共占224字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330141822154.png" alt="image-20210330141822154"></p><hr><p>按顺序依次将数据填入对应的成员得到：</p><table><thead><tr><th align="left">成员</th><th align="left">值</th></tr></thead><tbody><tr><td align="left"><strong>Magic</strong></td><td align="left">0x010B</td></tr><tr><td align="left">MajorLinkerVersion</td><td align="left">0x09</td></tr><tr><td align="left">MinorLinkerVersion</td><td align="left">0x00</td></tr><tr><td align="left">SizeOfCode</td><td align="left">0x00199200</td></tr><tr><td align="left">SizeOfInitializedData</td><td align="left">0x000BEC00</td></tr><tr><td align="left">SizeOfUninitializedData</td><td align="left">0x00000000</td></tr><tr><td align="left"><strong>AddressOfEntryPoint</strong></td><td align="left">0x0016AF12</td></tr><tr><td align="left">BaseOfCode</td><td align="left">0x00001000</td></tr><tr><td align="left">BaseOfData</td><td align="left">0x0019B000</td></tr><tr><td align="left"><strong>ImageBase</strong></td><td align="left">0x00400000</td></tr><tr><td align="left"><strong>SectionAlignment</strong></td><td align="left">0x00001000</td></tr><tr><td align="left"><strong>FileAlignment</strong></td><td align="left">0x00000200</td></tr><tr><td align="left">MajorOperatingSystemVersion</td><td align="left">0x0005</td></tr><tr><td align="left">MinorOperatingSystemVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MajorImageVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MinorImageVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MajorSubsystemVersion</td><td align="left">0x0005</td></tr><tr><td align="left">MinorSubsystemVersion</td><td align="left">0x0000</td></tr><tr><td align="left">Win32VersionValue</td><td align="left">0x00000000</td></tr><tr><td align="left"><strong>SizeOfImage</strong></td><td align="left">0x00298000</td></tr><tr><td align="left"><strong>SizeOfHeaders</strong></td><td align="left">0x00000400</td></tr><tr><td align="left"><strong>CheckSum</strong></td><td align="left">0x0025cd89</td></tr><tr><td align="left">Subsystem</td><td align="left">0x0002</td></tr><tr><td align="left">DllCharacteristics</td><td align="left">0x8140</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">0x00100000</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">0x00001000</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">0x00100000</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">0x00001000</td></tr><tr><td align="left">LoaderFlags</td><td align="left">0x00000000</td></tr><tr><td align="left">NumberOfRvaAndSizes</td><td align="left">0x00000010</td></tr><tr><td align="left"><strong>DataDirectory[16]</strong></td><td align="left">留作之后的笔记</td></tr></tbody></table><hr><h3 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h3><p><strong>鉴于篇幅和实用性考虑，只分析比较重要的成员</strong></p><hr><h4 id="Magic-1"><a href="#Magic-1" class="headerlink" title="Magic"></a>Magic</h4><p>Magic的值为0x010B，根据前面的分析可知：该文件是一个可执行的映像（32位）</p><hr><h4 id="AddressOfEntryPoint-1"><a href="#AddressOfEntryPoint-1" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h4><p>AddressOfEntryPoint的值为0x0016AF12，根据前面的分析可知：一个指向入口点函数的指针，<strong>相对</strong>于Image的基址是0x0016AF12</p><p>而Image的基址就是后面的 ImageBase = 0x00400000</p><p>于是该指针的的绝对地址为基址+偏移=0x00400000+0x0016AF12=0x0056AF12</p><p>于是得到了该程序的程序入口点为0x0056AF12，为了验证其准确性，使用OD打开程序</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144334813.png" alt="image-20210330144334813"></p><p>可以看到OD自动中断在了程序入口点0x0056AF12</p><hr><p>PS：如果OD暂停到了其它地方，则需要设置一下OD的中断点：</p><p>选项→调试设置（或使用快捷键Alt+0）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144509629.png" alt="image-20210330144509629"></p><hr><p>事件→主模块入口点</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144628298.png" alt="image-20210330144628298"></p><hr><h4 id="ImageBase-1"><a href="#ImageBase-1" class="headerlink" title="ImageBase"></a>ImageBase</h4><p>ImageBase的值为0x00400000，根据前面的分析可知：ImageBase正好是应用程序的默认值0x00400000</p><p>且ImageBase=0x00400000是64K字节的倍数</p><hr><h4 id="SectionAlignment、FileAlignment、SizeOfHeaders"><a href="#SectionAlignment、FileAlignment、SizeOfHeaders" class="headerlink" title="SectionAlignment、FileAlignment、SizeOfHeaders"></a>SectionAlignment、FileAlignment、SizeOfHeaders</h4><p>有关内存对齐和文件对齐的相关内容 在<a href="https://www.52pojie.cn/thread-1393291-1-1.html">PE文件笔记二 PE文件的两种状态</a>已经学习过了，这里不再赘述</p><hr><h4 id="SizeOfImage-1"><a href="#SizeOfImage-1" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h4><p>SizeOfImage的值为0x00298000，根据前面的分析可知：</p><p>SizeOfImage表示内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment的整数倍</p><p>于是打开程序，并使用WinHex查看其在内存中的状态（在<a href="https://www.52pojie.cn/thread-1393291-1-1.html">PE文件笔记二 PE文件的两种状态</a>中已经演示过，这里不再赘述，直接看结果）</p><p>用WinHex附加上程序后，拉到最底部，查看文件的最大偏移量</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330150941336.png" alt="image-20210330150941336"></p><hr><p>可以看到此时的最大偏移量为697FFF，用最大偏移量减去ImageBase 0x400000得到相对偏移为297FFF=SizeOfImage-1</p><p>验证了SizeOfImage可以比实际的值大</p><p>再验证SizeOfImage为内存对齐SectionAlignment的整数倍：</p><p>SizeOfImage/SectionAlignment=0x00298000/0x1000=0x298，可以整除，验证完毕</p><hr><h4 id="CheckSum-1"><a href="#CheckSum-1" class="headerlink" title="CheckSum"></a>CheckSum</h4><p>CheckSum从头部开始 两两字节不断相加，一直相加到最后，期间如果溢出，则直接舍去溢出部分，最后加完的结果再加上整个文件的长度就得到了CheckSum，操作系统就是通过这种方式来检验文件是否被修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152330856.png" alt="image-20210330152330856"></p><hr><p>但只对以下文件在加载时进行验证:所有驱动程序，在引导时加载的任何DLL，以及加载到关键系统进程中的任何DLL</p><p>此时程序本身并不属于上面提到的文件类型，于是此时的CheckSum并不生效</p><p>由于CheckSum的计算比较麻烦，于是这里就略去CheckSum计算的验证，简单说明了CheckSum的计算原理</p><p>下面来验证一下CheckSum的作用范围，此时程序的CheckSum应该是无效的</p><p>CheckSum的值为0x0025cd89，将它修改为0</p><p><strong>1.找到CheckSum</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152551798.png" alt="image-20210330152551798"></p><hr><p><strong>2.选中CheckSum，鼠标右键→编辑</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152634764.png" alt="image-20210330152634764"></p><hr><p><strong>3.填充选块</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152830026.png" alt="image-20210330152830026"></p><hr><p><strong>4.填充0</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152847852.png" alt="image-20210330152847852"></p><hr><p><strong>5.修改完毕</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152923193.png" alt="image-20210330152923193"></p><hr><p><strong>6.保存，然后打开程序</strong></p><p>使用快捷键 Ctrl+S 保存，确定</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152952218.png" alt="image-20210330152952218"></p><hr><p>打开程序，依旧可以正常运行，验证完毕</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330153037836.png" alt="image-20210330153037836"></p><hr><h4 id="Subsystem-1"><a href="#Subsystem-1" class="headerlink" title="Subsystem"></a>Subsystem</h4><p>Subsystem的值为0x0002，根据前面的分析可知：运行该程序所需子系统为：Windows图形用户界面子系统</p><hr><h4 id="DllCharacteristics-1"><a href="#DllCharacteristics-1" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h4><p>DllCharacteristics的值为0x8140</p><h5 id="通过PE权威指南"><a href="#通过PE权威指南" class="headerlink" title="通过PE权威指南"></a>通过PE权威指南</h5><p>转化为二进制得到：1000000101000000</p><p>数据位为1的位数有：第6位，第8位，第15位</p><p>根据前面的分析可知：DLL可以在加载时重新定位、该映像与数据执行预防(DEP)兼容、该映像是终端服务器感知的</p><hr><h5 id="通过官方文档"><a href="#通过官方文档" class="headerlink" title="通过官方文档"></a>通过官方文档</h5><p>DllCharacteristics的值为0x8140=0x8000+0x0100+0x0040</p><p>根据前面的分析可知：DLL可以在加载时重新定位、该映像与数据执行预防(DEP)兼容、该映像是终端服务器感知的</p><hr><h2 id="自写代码解析PE文件头"><a href="#自写代码解析PE文件头" class="headerlink" title="自写代码解析PE文件头"></a>自写代码解析PE文件头</h2><p>在先前代码的基础上，进一步改进</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\dbgview64.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330165824365.png" alt="image-20210330165824365"></p><h4 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330165958055.png" alt="image-20210330165958055"></p><hr><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>代码基于上一次的笔记<a href="https://www.52pojie.cn/thread-1404818-1-1.html#37730344_%E4%BB%A3%E7%A0%81%E5%B0%8F%E8%A7%A3">PE文件笔记四 PE文件头之标准PE头</a>改进了判断程序32位或64位的方法，并没有什么太大的变动，有关代码的分析在上一次笔记已经给出，这里也就不再赘述</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>扩展PE头根据程序是32位或64位而对应两种不同的结构</li><li>根据扩展PE头的第一个成员Magic可以判断出程序是32位的还是64位的</li><li>两种扩展PE头结构实际相差不多，掌握了32位的结构其实也相当于掌握了64位的结构</li><li>扩展PE头英文虽然为optional header，译为可选头，但它其实必不可少且极其重要</li><li>扩展PE头中的DataDirectory内容涉及较多，留作之后</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的<a href="https://www.52pojie.cn/thread-1405930-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe总结4</title>
      <link href="2021/06/15/PE%E6%80%BB%E7%BB%934/"/>
      <url>2021/06/15/PE%E6%80%BB%E7%BB%934/</url>
      
        <content type="html"><![CDATA[<p>转载好文 (๑•̀ㅂ•́)و✧</p><p>继续具体学习PE的各个结构细节，前面学完了DOS部首，接着学习PE文件头</p><p>由于PE文件头的内容较多，故要拆分为多个笔记，此笔记主要为<strong>标准PE头</strong></p><h1 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h1><h2 id="PE文件头结构"><a href="#PE文件头结构" class="headerlink" title="PE文件头结构"></a>PE文件头结构</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328200236487.png" alt="image-20210328200236487"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403212229062.png" alt="image-20210403212229062"></p><hr><h3 id="两种PE文件头"><a href="#两种PE文件头" class="headerlink" title="两种PE文件头"></a>两种PE文件头</h3><p>PE文件头的结构有两种，<strong>分别对应32位的程序和64位的程序</strong>，它们的<strong>差异在于扩展PE头的结构</strong></p><table><thead><tr><th align="left">PE文件头结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">_IMAGE_NT_HEADERS</td><td align="left">32位程序对应的PE文件头结构</td></tr><tr><td align="left">_IMAGE_NT_HEADERS64</td><td align="left">64位程序对应的PE文件头结构</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER32</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER32</strong></td><td align="left">扩展PE头 32位</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS64</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识，固定值不可变</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER64</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER64</strong></td><td align="left">扩展PE头 64位</td></tr></tbody></table><hr><h3 id="结构体截图"><a href="#结构体截图" class="headerlink" title="结构体截图"></a>结构体截图</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328204339552.png" alt="image-20210328204339552"></p><hr><h3 id="结构体代码"><a href="#结构体代码" class="headerlink" title="结构体代码"></a>结构体代码</h3><h4 id="32位结构体"><a href="#32位结构体" class="headerlink" title="32位结构体"></a>32位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;               //标准PE头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;     //扩展PE头 32位</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><hr><h4 id="64位结构体"><a href="#64位结构体" class="headerlink" title="64位结构体"></a>64位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">    DWORD Signature;                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;               //标准PE头 </span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;     //扩展PE头 64位</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><h2 id="PE文件头标志"><a href="#PE文件头标志" class="headerlink" title="PE文件头标志"></a>PE文件头标志</h2><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>根据DOS MZ头的最后一个成员找到PE文件头的首部，也就是PE文件头标志的首部</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328202904227.png" alt="image-20210328202904227"></p><p>可以看到，PE文件头标志<strong>固定</strong>为 50 45 00 00 ，对应ASCII为“PE ” ，是用来判断文件是否为PE文件的标识之一，还有一个PE标识为MZ头</p><table><thead><tr><th align="left">PE文件头标志</th><th align="left">对应C语言变量</th><th align="left">数据宽度</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">Signature</td><td align="left">DWORD（4字节）</td><td align="left">50 45 00 00对应ASCII为“PE ”</td><td align="left">PE文件标识</td></tr></tbody></table><hr><h2 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h2><h3 id="结构体截图-1"><a href="#结构体截图-1" class="headerlink" title="结构体截图"></a>结构体截图</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328204842798.png" alt="image-20210328204842798"></p><hr><h3 id="结构体代码-1"><a href="#结构体代码-1" class="headerlink" title="结构体代码"></a>结构体代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;//可以运行在什么样的CPU上   任意：0    Intel 386以及后续：14C   x64：8664  </span><br><span class="line">    WORD    NumberOfSections;//表示节的数量</span><br><span class="line">    DWORD   TimeDateStamp;//编译器填写的时间戳 与文件属性里面(创建时间、修改时间)无关</span><br><span class="line">    DWORD   PointerToSymbolTable;//调试相关</span><br><span class="line">    DWORD   NumberOfSymbols;//调试相关</span><br><span class="line">    WORD    SizeOfOptionalHeader;//可选PE头的大小(32位PE文件：0xE0  64位PE文件：0xF0)</span><br><span class="line">    WORD    Characteristics;//文件属性</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><hr><h3 id="成员详情"><a href="#成员详情" class="headerlink" title="成员详情"></a>成员详情</h3><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">Machine</td><td align="left">WORD(2字节)</td><td align="left">程序支持的CPU</td><td align="left">任意：0  Intel 386以及后续：14C  x64：8664</td></tr><tr><td align="left">NumberOfSections</td><td align="left">WORD(2字节)</td><td align="left">节的数量</td><td align="left">不大于96</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">DWORD(4字节)</td><td align="left">编译器填写的时间戳</td><td align="left">与文件属性里面(创建时间、修改时间)无关</td></tr><tr><td align="left">PointerToSymbolTable</td><td align="left">DWORD(4字节)</td><td align="left">指向符号表</td><td align="left">调试相关</td></tr><tr><td align="left">NumberOfSymbols</td><td align="left">DWORD(4字节)</td><td align="left">符号表中的符号个数</td><td align="left">调试相关</td></tr><tr><td align="left">SizeOfOptionalHeader</td><td align="left">WORD(2字节)</td><td align="left">可选PE头结构大小</td><td align="left">32位PE文件：0xE0 64位PE文件：0xF0</td></tr><tr><td align="left">Characteristics</td><td align="left">WORD(2字节)</td><td align="left">文件属性</td><td align="left">由数据位拼接而成，详见下方</td></tr></tbody></table><hr><h4 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h4><p>计算机的体系结构类型。映像文件只能在指定的计算机或模拟指定计算机的系统上运行。此成员可以是以下值之一：</p><table><thead><tr><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">宏定义IMAGE_FILE_MACHINE_I386 = 0x014c</td><td align="left">x86</td></tr><tr><td align="left">宏定义IMAGE_FILE_MACHINE_IA64 = 0x0200</td><td align="left">Intel IPF</td></tr><tr><td align="left">宏定义IMAGE_FILE_MACHINE_AMD64 = 0x8664</td><td align="left">x64</td></tr></tbody></table><p>IA64：就是所谓的安腾（Itanium）(IPF)，Intel跟HP联合折腾的一种64-bits全新架构，与x86系列不兼容</p><hr><h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h4><p>节数。这表示紧跟在PE文件头后面的节表的大小。请注意，Windows加载程序将节数限制为96。</p><hr><h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>Image时间戳的低32位。这表示<strong>链接器</strong>创建Image的日期和时间。根据系统时钟，该值以自1970年1月1日午夜（00:00:00）后经过的秒数表示。</p><hr><h4 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title="PointerToSymbolTable"></a>PointerToSymbolTable</h4><p>符号表的偏移量，以字节为单位，如果不存在COFF符号表，则为零。</p><p>COFF是指通用对象文件格式，在Microsoft 实现叫做可移植可执行 (PE) 文件格式，在Linux上的实现叫做（可执行与可链接）ELF文件格式；COFF全拼为：Common Object File Format</p><hr><h4 id="NumberOfSymbols"><a href="#NumberOfSymbols" class="headerlink" title="NumberOfSymbols"></a>NumberOfSymbols</h4><p>符号表中的符号数</p><hr><h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h4><p>扩展PE头的大小，以字节为单位。对于对象文件（object files），此值应为0。</p><p>32位的PE文件默认值为0xE0 64位PE文件默认值为0xF0  <strong>该值可变</strong></p><hr><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>Image的文件属性，其值对应的数据位含义为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328211930866.png" alt="image-20210328211930866"></p><hr><p>Characteristics的数据宽度为WORD（2字节=16 bits）</p><p>假设Characteristics的十六进制为0102，分析其文件属性</p><p>首先将十六进制转化为二进制：0000 0001 0000 0010</p><p>此时可以发现数据位1和8的位置的值为1（数据位由0开始），对照上面可得出：文件属性为 文件是可执行的、只在32位平台上运行</p><hr><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p>紧跟着上面PE文件头标志的实例分析，继续分析标准PE头对应的各个属性</p><p>根据标准PE头各个成员的数据宽度不难得出标准PE头的总宽度为：20字节（4个WORD+3个DWORD=4×2+3×4=20）</p><p>因此从前面PE文件头标志后再数20个字节都是标准PE头的数据</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328235126574.png" alt="image-20210328235126574"></p><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">4C 01 05 00 6B 01 AE 55 00 00 00 00 00 00 00 00 E0 00 02 01</span><br></pre></td></tr></table></figure><hr><p>得到：</p><table><thead><tr><th align="left">成员</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">Machine</td><td align="left">x86</td><td align="left">14C</td></tr><tr><td align="left">NumberOfSections</td><td align="left">有5个节</td><td align="left">5</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">编译器填充的时间戳</td><td align="left">55 AE 01 6B</td></tr><tr><td align="left">PointerToSymbolTable</td><td align="left">调试相关</td><td align="left">00 00 00 00</td></tr><tr><td align="left">NumberOfSymbols</td><td align="left">调试相关</td><td align="left">00 00 00 00</td></tr><tr><td align="left">SizeOfOptionalHeader</td><td align="left">可选PE头结构大小为E0</td><td align="left">E0</td></tr><tr><td align="left">Characteristics</td><td align="left">文件属性为 文件可执行且只在32位平台上运行</td><td align="left">102</td></tr></tbody></table><hr><h2 id="自写代码解析PE文件头"><a href="#自写代码解析PE文件头" class="headerlink" title="自写代码解析PE文件头"></a>自写代码解析PE文件头</h2><p>因为有人提议用VS2019来编写，于是这里改成VS2019中的代码，但其实在VC6中也通用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;windows.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\sixonezero\\Desktop\\dbgview64.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建标准PE头对应的结构体指针</span><br><span class="line">    _IMAGE_FILE_HEADER* file;</span><br><span class="line">    //让标准PE头指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小</span><br><span class="line">    file = (_IMAGE_FILE_HEADER*)((UINT)peId + sizeof(DWORD));</span><br><span class="line">    //输出file-&gt;Machine</span><br><span class="line">    printf(&quot;file-&gt;Machine:%X\n&quot;, file-&gt;Machine);</span><br><span class="line">    //根据file-&gt;Machine判断程序为 x86或IPF或x64</span><br><span class="line">    switch (file-&gt;Machine) &#123;</span><br><span class="line">    //程序为32位</span><br><span class="line">    case IMAGE_FILE_MACHINE_I386:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;x86 program\n&quot;);</span><br><span class="line">        //确定程序为32位则扩展PE头确定为_IMAGE_OPTIONAL_HEADER</span><br><span class="line">        //创建扩展PE头对应的结构体指针   </span><br><span class="line">        _IMAGE_OPTIONAL_HEADER* opt;</span><br><span class="line">        //让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">        opt = (_IMAGE_OPTIONAL_HEADER*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出opt-&gt;Magic</span><br><span class="line">        printf(&quot;opt-&gt;Magic:%X\n&quot;, opt-&gt;Magic);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    //程序为IPF</span><br><span class="line">    case IMAGE_FILE_MACHINE_IA64:</span><br><span class="line">        printf(&quot;IPF program\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    //程序为64位</span><br><span class="line">    case IMAGE_FILE_MACHINE_AMD64:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;x64 program\n&quot;);</span><br><span class="line">        //确定程序为64位则扩展PE头确定为_IMAGE_OPTIONAL_HEADER64</span><br><span class="line">        //创建扩展PE头对应的结构体指针</span><br><span class="line">        _IMAGE_OPTIONAL_HEADER64* opt;</span><br><span class="line">        //让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">        opt = (_IMAGE_OPTIONAL_HEADER64*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出opt-&gt;Magic</span><br><span class="line">        printf(&quot;opt-&gt;Magic:%X\n&quot;, opt-&gt;Magic);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>分别演示32位程序和64位程序的运行结果</p><h4 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330163616404.png" alt="image-20210330163616404"></p><hr><h4 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330163506517.png" alt="image-20210330163506517"></p><h3 id="代码小解"><a href="#代码小解" class="headerlink" title="代码小解"></a>代码小解</h3><p>代码中判断程序是32位或64位是看file-&gt;Machine的值来进行判断的，但其实这里<strong>并不一定准确</strong>，实际上<strong>应当判断opt-&gt;Magic才最为准确的</strong>。但关于扩展PE头的内容留作之后，这里为了学习标准PE头，故先采用这种方式进行判断，后面也会修正为使用opt-&gt;Magic来判断程序为32位或64位</p><hr><p>代码中大部分都有注释，并不难理解，主要说明一下 让指针指向对应地址 的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">//让标准PE头指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小</span><br><span class="line">file = (_IMAGE_FILE_HEADER*)((UINT)peId + sizeof(DWORD));</span><br><span class="line">//让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">opt = (_IMAGE_OPTIONAL_HEADER*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">//让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">opt = (_IMAGE_OPTIONAL_HEADER64*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br></pre></td></tr></table></figure><hr><p>指针的地址 = 首地址 + 偏移 这个没有什么好说的，主要在指针前的一个（UINT）强制类型转换</p><p>为什么要在指针前加一个（UINT）的强制类型转换？</p><p>这就涉及到指针的加减问题了，详解可参考：<a href="https://www.52pojie.cn/thread-1387007-1-1.html#37278091_%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E5%87%8F">指针的加减</a></p><p>这里简单引用一下指针加减的结论：</p><p>无论是指针的加亦或是减（这里只演示了加法，但减法同理），其加或减的<strong>单位</strong>为去掉一个*后的数据宽度</p><p>也就是<strong>实际增减的数值=去掉一个*后的数据宽度 × 增减的数值</strong></p><hr><p>上面的指针都是一级结构体指针，DWORD，_IMAGE_FILE_HEADER，_IMAGE_OPTIONAL_HEADER,_IMAGE_OPTIONAL_HEADER64</p><p>去掉一个*后的数据宽度为结构体的大小，但是我们这里<strong>想要进行的增减的单位应该为字节</strong>，而不是结构体的大小，于是要将指针类型强转为UINT(无符号整数)类型（数据宽度为字节），使得其每次增减的单位为字节</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>PE文件头的起始位置由DOS MZ头的最后一个成员确定</li><li>PE文件头标志固定ASCII为“PE ”，若不是则说明该文件非PE文件</li><li>标准PE头的第一个成员Machine可以判断程序为32位或64位</li><li>标准PE头的第二个成员NumberOfSections表示后面节的个数</li><li>可选PE头结构大小可变，且在标准PE头的第六个成员SizeOfOptionalHeader指定</li><li>标准PE头的最后一个成员Characteristics说明了该文件的属性</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解的<a href="https://www.52pojie.cn/thread-1404818-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe总结3</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%933/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<p>先转载一下怕以后找不到ヽ(✿ﾟ▽ﾟ)ノ</p><p>前面学习了PE结构的总体结构，接下来将具体学习PE的各个结构细节</p><p>这次学习的结构为DOS 部首</p><h1 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h1><h2 id="DOS部首结构"><a href="#DOS部首结构" class="headerlink" title="DOS部首结构"></a>DOS部首结构</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326211401967.png" alt="image-20210326211401967"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326235719068.png" alt="image-20210326235719068"></p><hr><table><thead><tr><th align="left">DOS部首结构</th><th align="left">对应C中的结构体</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DOS ‘MZ’ HEADER</td><td align="left">_IMAGE_DOS_HEADER</td><td align="left">DOS MZ头 结构体</td></tr><tr><td align="left">DOS stub</td><td align="left">无</td><td align="left">DOS 存根</td></tr></tbody></table><hr><h2 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h2><h3 id="结构体截图"><a href="#结构体截图" class="headerlink" title="结构体截图"></a>结构体截图</h3><p>在winnt.h中找到_IMAGE_DOS_HEADER，得到以下截图（具体查找对应C结构体方法在<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1391994&page=1&extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">PE文件笔记一 PE介绍</a>中已经说明了，这里不再赘述）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326212749211.png" alt="image-20210326212749211"></p><hr><h3 id="结构体代码"><a href="#结构体代码" class="headerlink" title="结构体代码"></a>结构体代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码 隐藏代码typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">   WORD   e_magic;                     // Magic number</span><br><span class="line">   WORD   e_cblp;                      // Bytes on last page of file</span><br><span class="line">   WORD   e_cp;                        // Pages in file</span><br><span class="line">   WORD   e_crlc;                      // Relocations</span><br><span class="line">   WORD   e_cparhdr;                   // Size of header in paragraphs</span><br><span class="line">   WORD   e_minalloc;                  // Minimum extra paragraphs needed</span><br><span class="line">   WORD   e_maxalloc;                  // Maximum extra paragraphs needed</span><br><span class="line">   WORD   e_ss;                        // Initial (relative) SS value</span><br><span class="line">   WORD   e_sp;                        // Initial SP value</span><br><span class="line">   WORD   e_csum;                      // Checksum</span><br><span class="line">   WORD   e_ip;                        // Initial IP value</span><br><span class="line">   WORD   e_cs;                        // Initial (relative) CS value</span><br><span class="line">   WORD   e_lfarlc;                    // File address of relocation table</span><br><span class="line">   WORD   e_ovno;                      // Overlay number</span><br><span class="line">   WORD   e_res[4];                    // Reserved words</span><br><span class="line">   WORD   e_oemid;                     // OEM identifier (for e_oeminfo)</span><br><span class="line">   WORD   e_oeminfo;                   // OEM information; e_oemid specific</span><br><span class="line">   WORD   e_res2[10];                  // Reserved words</span><br><span class="line">   LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line"> &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><hr><h3 id="结构体成员分析"><a href="#结构体成员分析" class="headerlink" title="结构体成员分析"></a>结构体成员分析</h3><p>_IMAGE_DOS_HEADER结构体的成员并不少，但在现在需要学习的只有两个</p><p>因为：</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>DOS部首，可以说是Windows的<strong>历史遗留问题</strong>了，因为Windows程序最早是在DOS系统（16位系统）上运行的</p><p>所以该部分<strong>主要是给DOS用的</strong>（向下兼容）</p><hr><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>目前在32位或64位 WINDOWS系统上还有效的只有两个成员了：</p><ul><li>第一个成员：e_magic</li><li>最后一个成员：e_lfanew</li></ul><hr><h4 id="成员详情"><a href="#成员详情" class="headerlink" title="成员详情"></a>成员详情</h4><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">注释</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">e_magic</td><td align="left">WORD(2字节)</td><td align="left">Magic number</td><td align="left"><strong>PE文件判断标识</strong></td><td align="left">固定为4d 5a (ASCII=’MZ’)</td></tr><tr><td align="left">e_lfanew</td><td align="left">LONG(4字节)</td><td align="left">File address of new exe header</td><td align="left"><strong>存储PE头首地址</strong></td><td align="left">不定</td></tr></tbody></table><hr><h4 id="验证其余成员无效性"><a href="#验证其余成员无效性" class="headerlink" title="验证其余成员无效性"></a>验证其余成员无效性</h4><p>前面说到在目前的系统中，只有两个成员是有效的，为验证这一点，将其余成员全部置为0试试</p><p><strong>1.用WinHex或UltraEdit等十六进制编辑器打开一个程序</strong></p><p>这里采用<strong>WinHex</strong>进行操作，并选中其余成员部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326223305500.png" alt="image-20210326223305500"></p><hr><p><strong>2.将选中的部分，也就是其余成员部分全部修改为0</strong></p><p>右键→编辑→填充选块 （快捷键Ctrl+L）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224239328.png" alt="image-20210326224239328"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224313607.png" alt="image-20210326224313607"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224403422.png" alt="image-20210326224403422"></p><hr><p>确定修改后：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224440179.png" alt="image-20210326224440179"></p><hr><p><strong>3.保存修改的文件</strong></p><p>文件→保存（快捷键Ctrl+S）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224522965.png" alt="image-20210326224522965"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224557452.png" alt="image-20210326224557452"></p><hr><p><strong>4.执行修改后的文件</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326220814513.png" alt="image-20210326220814513"></p><hr><p>可以看到程序仍然可以正常运行，验证了：其余成员在32位及以上的Windows系统中<strong>无效</strong></p><h2 id="Dos-Stub"><a href="#Dos-Stub" class="headerlink" title="Dos Stub"></a>Dos Stub</h2><p>Dos Stub在32位及以上的Windows系统中其实也无效，但不妨研究一下他的作用</p><p><strong>1.截取出Dos Stub部分的数据</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224705523.png" alt="image-20210326224705523"></p><p>选中部分为Dos Stub，其数据范围由_IMAGE_DOS_HEADER结构体中的最后一个成员e_lfanew决定</p><hr><p><strong>2.复制选中部分也就是Dos Stub部分的数据</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224751035.png" alt="image-20210326224751035"></p><hr><p><strong>3.将数据粘贴到记事本中</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326225328310.png" alt="image-20210326225328310"></p><hr><h3 id="对应数据"><a href="#对应数据" class="headerlink" title="对应数据"></a>对应数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000FD661975B9077726B9077726B90777260448E126BB077726B07FE226A2077726A755F326BE077726B07FE426A6077726B9077626E8057726B07FF4267D077726B07FF32651077726A755E326B8077726B907E026BB077726B07FE626B807772652696368B90777260000000000000000</span><br></pre></td></tr></table></figure><hr><h3 id="对应数据反汇编"><a href="#对应数据反汇编" class="headerlink" title="对应数据反汇编"></a>对应数据反汇编</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码PUSH CS</span><br><span class="line">POP DS</span><br><span class="line">MOV DX,000E</span><br><span class="line">MOV AH,09</span><br><span class="line">INT 21</span><br><span class="line">MOV AX,4C01</span><br><span class="line">INT 21</span><br><span class="line">DB 54</span><br><span class="line">DB 68</span><br><span class="line">DB 69</span><br><span class="line">DB 00</span><br><span class="line">DB 33</span><br><span class="line">DB 70</span><br><span class="line">……</span><br></pre></td></tr></table></figure><hr><p>通过<strong>16位的反汇编引擎</strong>即可得到对应的反汇编代码</p><p>这里我们主要关注DB段，也就是汇编中数据段部分有DB 54；DB 68；DB 69 ……</p><p>在WINHEX中找到其对应的数据部分，查看其对应的ASCII</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326231526001.png" alt="image-20210326231526001"></p><hr><p>数据部分为This program cannot be run in DOS</p><p>结合前面的两个INT 21 中断 不难猜测出该段数据对应的16位反汇编为输出数据部分的内容：This program cannot be run in DOS</p><h2 id="自写代码解析DOS-MZ头"><a href="#自写代码解析DOS-MZ头" class="headerlink" title="自写代码解析DOS MZ头"></a>自写代码解析DOS MZ头</h2><p>了解了DOS部首的结构以后就可以自己写代码来读取DOS MZ头了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Documents and Settings\\Administrator\\桌面\\dbghelp.dll&quot;,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile,NULL,PAGE_READONLY,0,0,0);</span><br><span class="line">    //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap,FILE_MAP_READ,0,0,0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">        dos=(_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出结构体的第一个成员，以十六进制输出</span><br><span class="line">        printf(&quot;%X\n&quot;,dos-&gt;e_magic);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326234752508.png" alt="image-20210326234752508"></p><p>可以看到能够正确地得到DOS MZ头对应的第一个成员的值：5A4D（对应ASCII为MZ）</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>DOS部首分为两部分：DOS ‘MZ’ HEADER 和 DOS stub</li><li>DOS ‘MZ’ HEADER对应的结构体_IMAGE_DOS_HEADER中仅第一个成员和最后一个成员在32位及以上的WINDOWS系统上有效</li><li>DOS Stub对应为一串反汇编代码，其功能和输出This program cannot be run in DOS相关</li><li>DOS ‘MZ’ HEADER中无效的成员部分可用来填充shellcode来达到其它目的</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1403011-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 re -re1</title>
      <link href="2021/06/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre1/"/>
      <url>2021/06/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre1/</url>
      
        <content type="html"><![CDATA[<p>一天一道ctf系列</p><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5073&page=1">攻防世界re1</a></p><p>这道题我们有两种解法，先说说第一种</p><h4 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h4><p>我们先直接拖入ida</p><p><img src="https://img-blog.csdnimg.cn/20190506221846329.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgxNTA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>f5查看伪代码，如上图，可以分析出flag保存在v9中，然后再和v5比较，如果相同则输出aflag。所以我们可以猜测flag的值作为常量保存在了程序内部，那么我们直接查看字符串。</p><p><img src="https://img-blog.csdnimg.cn/20190506223041162.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgxNTA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>为啥找不到呢 ？</p><p>一脸懵逼的我打开了百度搜索，看到了这个大佬的<a href="https://blog.csdn.net/qq_40481505/article/details/89893552">文章</a></p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210615110705664.png" alt="image-20210615110705664"></p><p>大概意思是ida在反编译过程中采用的是下降法，这种方法很少会误将数据当作代码进行反编译，但是这次很不幸，我们的flag呗反编译了，所以解决方法是：在IDA打开文件时选择binary file,在此模式下IDA不会进行反编译，此时再打开strings界面就可发现flag。</p><p>开始实践：<br><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210615111021666.png" alt="image-20210615111021666"></p><p>成功找到</p><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>正常流程进入main函数，发现flag输入v9中且和v5比较，所以我们推测flag存储在v5中，通过源码追踪v5。</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816175750099-2081804484.png" alt="img"></p><p>可以看到，xmmword_413E34赋值给了v5，所以xmmword_413E34就是我们要找的值，双击进去，得到了一串数字。</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816175915527-148146356.png" alt="img"></p><p>将数字转化为字符串</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816180036597-1259453797.png" alt="img"></p><p>因为计算机采取的是小端存储，所以我们倒着输入就成功了</p><h4 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag!"></a>get flag!</h4><p>DUTCTF{We1c0met0DUTCTF}</p>]]></content>
      
      
      <categories>
          
          <category> ctf-re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp定律脱壳</title>
      <link href="2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/"/>
      <url>2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>esp定律脱壳</p><p>————————————纯属个人理解，如有不对求大佬指正。</p><p>看了好多关于esp定律脱壳的文章，都没看懂，o(≧口≦)o，可能是本人太笨了吧。所以就来浅谈一下自己对于esp脱壳的理解。</p><p>个人对于esp脱壳的理解是先把壳跑完，此时的oep就是真正的程序入口。然后再将源程序通过工具dump出来为一个exe文件，再进行一些修复操作，就脱壳完毕了。</p><p>接下来是实战操作 ┭┮﹏┭┮ ，我直接通过buuctf里的<a href="https://buuoj.cn/challenges#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90">新年快乐</a>题目来操作吧。</p><h4 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h4><p>首先拖入ide中，我们会发现只有两个函数，是不是很可疑，</p><p><img src="https://img-blog.csdnimg.cn/20201113093639895.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="没脱壳拖入ida"></p><p>所以我们直接将它拖入Exeinfope中</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210614185118093.png" alt="image-20210614185118093"></p><p>可以看到该exe文件里有一个UPX壳，那么我们就开始脱壳吧。</p><h4 id="esp脱壳"><a href="#esp脱壳" class="headerlink" title="esp脱壳"></a>esp脱壳</h4><p>esp定律脱壳（个人理解）：<br>在外壳代码中有一个pushad的指令，该指令会将所有的寄存器的值都压入栈中也就是说在pushad指令之后esp的值就是指向外壳的代码段了，等之后运行完外壳程序，我们只要找到OEP就可以了</p><p>关于esp定律如果有不懂的话推荐看一下这个<a href="https://www.52pojie.cn/thread-294844-1-1.html">文章</a>，或者百度。反正都比我讲的好多了。 o(￣ヘ￣o＃)</p><h5 id="拖入od"><a href="#拖入od" class="headerlink" title="拖入od"></a>拖入od</h5><p>将exe拖入X32dbg开始分析，首先找到pushad，</p><p><img src="https://img-blog.csdnimg.cn/20201114084054781.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>双击进入，将eip指向这里</p><p><img src="https://img-blog.csdnimg.cn/20201114084329271.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后f8单步运行，此时我们可以看到esp的变化，右键esp，转到内存窗口设置断点</p><p><img src="https://img-blog.csdnimg.cn/20201114084603988.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设置内存断点"></p><p><img src="https://img-blog.csdnimg.cn/20201114084842340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设断点"></p><p>运行，关于这两步操作我来做一下解释，因为pushad以后esp指向的是外壳的代码段，所以我们将断点设置在此处，然后运行到此处以后，就可以找到我们的程序入口oep了。</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210614185448616.png" alt="image-20210614185448616"></p><p>此时，程序停下来以后，往上看我们可以看到popad，该指令刚好与pushad对应，可以将内存器里的值进行还原。找到下面jmp指令要跳转的位置就是我们的程序的入口oep。</p><p><img src="https://img-blog.csdnimg.cn/202011140852477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>oep已找到，接下来开始dump</p><h4 id="dump操作"><a href="#dump操作" class="headerlink" title="dump操作"></a>dump操作</h4><p>（这里忘截图了，直接挂大佬的操作图了）<img src="https://img-blog.csdnimg.cn/20201114091101713.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>操作如下：<img src="https://img-blog.csdnimg.cn/20201114091242417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114092646790.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后再fixdump一下，会弹下图，如果未弹出，可以先perebuild（具体操作与fixdump相同）然后再fixdump（具体原理还在挖掘中）</p><p><img src="https://img-blog.csdnimg.cn/20201114092717465.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092726792.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092735101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092739904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>脱壳完成！</p><p>另外鸣谢大佬，挂上大佬<a href="https://blog.csdn.net/weixin_46287316/article/details/109669066?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base">文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe总结2（转载）</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%932/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<p>一篇转载文章，转载于：<a href="https://www.52pojie.cn/thread-1393291-1-1.html">https://www.52pojie.cn/thread-1393291-1-1.html</a><br>一个PE文件可以分为两种状态：运行态和非运行态</p><p>非运行态：当一个PE文件尚未被运行时，其数据<strong>存储在磁盘中</strong>，也就是<a href="https://www.52pojie.cn/thread-1391994-1-1.html">PE个人笔记一之PE介绍</a>中PE的状态</p><p>运行态：当一个PE文件被打开后，PE文件的相关数据将被<strong>装载到内存中</strong>，此时为运行态</p><hr><p>在细讲PE两种状态前，回顾先前在笔记一中的相关内容：</p><h2 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316164115579.png" alt="image-20210316164115579"></p><h2 id="整体结构表"><a href="#整体结构表" class="headerlink" title="整体结构表"></a>整体结构表</h2><table><thead><tr><th align="left">结构</th><th align="left">对应C数据结构</th><th align="left">默认占用空间大小（单位字节）</th></tr></thead><tbody><tr><td align="left">DOS MZ头</td><td align="left">_IMAGE_DOS_HEADER</td><td align="left">64</td></tr><tr><td align="left">DOS Stub</td><td align="left">仅在MS-DOS系统下有效，不作研究</td><td align="left">不固定</td></tr><tr><td align="left">PE文件头</td><td align="left">_IMAGE_NT_HEADERS</td><td align="left">4+20+224=248</td></tr><tr><td align="left">PE文件头标志</td><td align="left">Signature</td><td align="left">4</td></tr><tr><td align="left">PE文件表头/标准PE头</td><td align="left">_IMAGE_FILE_HEADER</td><td align="left">20</td></tr><tr><td align="left">PE文件表头可选部分/扩展PE头</td><td align="left">_IMAGE_OPTIONAL_HEADER</td><td align="left">224</td></tr><tr><td align="left">块表/节表</td><td align="left">_IMAGE_SECTION_HEADER</td><td align="left">40</td></tr><tr><td align="left">块/节</td><td align="left">无</td><td align="left">由块表/节表决定</td></tr></tbody></table><hr><h1 id="非运行态"><a href="#非运行态" class="headerlink" title="非运行态"></a>非运行态</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先前的笔记一中只是简单介绍了非运行态下如何判断一个文件是否为PE文件</p><p>接下来讲讲为何能通过之前的方法来判断PE文件</p><hr><p><strong>判断PE文件的流程</strong>可概括为如下三步：</p><ol><li>判断头2个字节是否为4D 5A（ASCII码为MZ）</li><li>找到3Ch位置数据</li><li>根据第二步中的位置数据再找到对应的地址，判断这个地址是否为50 45 00 00（对应ACSII码为PE..）</li></ol><hr><table><thead><tr><th align="left">地址</th><th align="left">长度（单位字节）</th><th align="left">对应C的数据结构</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的第一个成员e_magic</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的最后一个成员e_lfanew</td><td align="left">指出PE头文件偏移位置</td><td align="left">不定</td><td align="left">不定</td></tr><tr><td align="left">[3C]</td><td align="left">4</td><td align="left">Signature</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>下面结合实例再来分析：</p><p>这次使用WinHex这个工具来进行查看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315210005799.png" alt="image-20210315210005799"></p><hr><p>此时对应的表格数据为：</p><table><thead><tr><th align="left">地址</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">指出PE头文件偏移位置</td><td align="left">F0</td><td align="left"></td></tr><tr><td align="left">F0</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>上面对一个PE文件的判断只涉及了DOS MZ头和PE文件头中的PE文件头标志</p><p>下面继续分析其它结构</p><hr><h2 id="后续分析"><a href="#后续分析" class="headerlink" title="后续分析"></a>后续分析</h2><h3 id="PE文件头标志和标准PE头"><a href="#PE文件头标志和标准PE头" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p>从先前的PE的结构继续向后看24个字节（PE文件头标志的大小+标准PE头大小 4+20）得到扩展PE头的首地址</p><p>先前的地址为：F0</p><p>后来的地址为：0xF0+24=240+24=264=0x108</p><p>所以从F0～108为PE文件头标志和标准PE头</p><p>从108开始就是扩展PE头了</p><p>PE文件头标志和标准PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315212241373.png" alt="image-20210315212241373"></p><hr><h3 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p>从先前得到的扩展PE头地址继续向后看224个字节（扩展PE头大小）得到块表的首地址</p><p>先前的地址为：108</p><p>后来的地址为：0x108+224=264+224=488=0x1E8</p><p>所以从108~1E8为扩展PE头</p><p>从1E8开始就是块表了</p><p>扩展PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315213947563.png" alt="image-20210315213947563"></p><hr><h3 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h3><p>从先前得到的块表头地址继续向后看40个字节（块表大小）得到第二个块表的首地址</p><p>先前的地址为：1E8</p><p>后来的地址为：0x1E8+40=488+40=528=0x210</p><p>所以从1E8~210为第一个块表</p><p>从210开始就是第二个块表了</p><p>第一个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315234922585.png" alt="image-20210315234922585"></p><hr><p>同理可得剩下的几个块表</p><p>第二个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235048573.png" alt="image-20210315235048573"></p><p>地址从210~238</p><hr><p>第三个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235154581.png" alt="image-20210315235154581"></p><p>地址从238~260</p><hr><p>第四个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235402774.png" alt="image-20210315235402774"></p><p>地址从260~288</p><hr><p>第五个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235504709.png" alt="image-20210315235504709"></p><p>地址从288~2B0</p><hr><h4 id="汇总块表"><a href="#汇总块表" class="headerlink" title="汇总块表"></a>汇总块表</h4><table><thead><tr><th align="left">块名称</th><th align="left">块地址</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">1E8~210</td></tr><tr><td align="left">.rdata</td><td align="left">210~238</td></tr><tr><td align="left">.data</td><td align="left">238~260</td></tr><tr><td align="left">.rsrc</td><td align="left">260~288</td></tr><tr><td align="left">.reloc</td><td align="left">288~2B0</td></tr></tbody></table><hr><h3 id="块表后的空隙"><a href="#块表后的空隙" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>块表后面跟着的应该是块，但在块表后和块之前却多出了一段空间</p><p>这里为2B0~400</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316000131381.png" alt="image-20210316000131381"></p><hr><p>先前的PE结构中间都没有空隙，为<strong>连续存储</strong></p><p>但在<strong>块表和块之间是可能存在空隙的</strong>，这个空隙里一般被填充为编译器插入的数据（也可以没有,就是此时的情况）</p><p>这段空隙的修改并不会导致程序不可运行，因而可被拿来写入自己想要的代码来对程序进行修改</p><hr><p><strong>为什么会存在这段空隙？</strong></p><p>这段空隙存在的原因在于块表和块并没有<strong>连续存储</strong></p><p>所以这段空隙的存在与否及长度 取决于 <strong>块的起始位置</strong></p><p>而块的起始位置则<strong>由扩展PE头中的某个成员决定</strong></p><hr><p>给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SizeOfHeaders成员（DWORD类型占4个字节）</p><p>SizeOfHeaders的含义为<strong>3个头按照文件对齐后的大小</strong>：（DOS头大小+PE头大小+块表大小）加完的结果进行<strong>文件对齐</strong>后得到的大小</p><p>头大小相加很好理解，按照之前得到的头大小和为：2B0，于是问题就在于文件对齐</p><h4 id="什么是文件对齐"><a href="#什么是文件对齐" class="headerlink" title="什么是文件对齐"></a>什么是文件对齐</h4><p>讲到文件对齐就涉及到扩展PE头中的另一个成员：FileAlignment（DWORD类型占4个字节）</p><p>文件对齐就是要求SizeOfHeaders必须为FileAlignment的<strong>整数倍</strong></p><hr><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为108</p><p>从108开始往后找36个字节（中间间隔了1个WORD，2个BYTE，8个DWORD，即1<em>2+2</em>1+8*4=36）</p><p>FileAlignment的地址为：0x108+36=264+36=300=0x12C</p><p>FileAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003503508.png" alt="image-20210316003503508"></p><p>FileAlignment为00 00 02 00=0x200（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是FileAlignment的整数倍</p><p>于是将SizeOfHeaders设置为FileAlignment的整数倍：(2B0/200+1)*200=400</p><p>得出的SizeOfHeaders的大小应该为0x400</p><hr><p>再来验证一下SizeOfHeaders的大小</p><p>前面得到的FileAlignment的地址为12C</p><p>从12C开始往后找24个字节（中间间隔了6个WORD，3个DWORD，即6<em>2+3</em>4=24）</p><p>SizeOfHeaders的地址为：0x12C+24=300+24=324=0x144</p><p>SizeOfHeaders：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003735412.png" alt="image-20210316003735412"></p><p>SizeOfHeaders为 00 00 04 00=0x400（小端存储）</p><p>得到的大小和计算出来的大小一致，验证完毕</p><hr><h4 id="为什么要文件对齐"><a href="#为什么要文件对齐" class="headerlink" title="为什么要文件对齐"></a>为什么要文件对齐</h4><p>和内存对齐一样，都是为了使执行时的效率更高，有关内存对齐可参考：<a href="https://www.52pojie.cn/thread-1385641-1-1.html#37246226_%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">逆向基础笔记十八 汇编 结构体和内存对齐</a></p><p>PS：上面的内存对齐为程序中<strong>局部的内存对齐</strong>，主要针对的是编程时的变量、结构体等，和后面要讲的内存对齐要区别开</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块的起始地址由块表中的PointerToRawData决定，<strong>第一个块</strong>的起始地址则由上面的SizeOfHeaders决定</p><p>块部分存储的为数据，如何存储由块表决定，这里主要探讨<strong>每个块的 起始地址、块大小、结束地址</strong>，其它留作之后的笔记</p><p>给出块表在C中的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#define IMAGE_SIZEOF_SHORT_NAME              8</span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;                        //&lt;--- 块的大小</span><br><span class="line">    DWORD   PointerToRawData;                //&lt;--- 块在磁盘文件中的偏移</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><hr><h4 id="块的起始地址"><a href="#块的起始地址" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>找到结构体中的PointerToRawData成员（DWORD类型占4个字节）</p><p>PointerToRawData的含义为<strong>该块在磁盘文件中的偏移</strong></p><p>前面已经知道第一个块表的首地址为1E8</p><p>从1E8开始往后找20个字节（中间间隔了1个BYTE[8]，3个DWORD，即1<em>8+3</em>4=20）</p><p>PointerToRawData的地址为：0x1E8+20=488+20=508=0x1FC</p><p>PointerToRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316011603629.png" alt="image-20210316011603629"></p><p>PointerToRawData为00 00 04 00=0x400</p><p>和通过SizeOfHeaders得到的一致，验证了<strong>第一个</strong>块的PointerToRawData由SizeOfHeaders决定</p><h4 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h4><p>SizeOfRawData为块的大小（文件对齐后）</p><p>SizeOfRawData就在PointerToRawData前面</p><p>所以其地址为：PointerToRawData地址-4=0x1FC-4=0x1F8</p><p>SizeOfRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316152420615.png" alt="image-20210316152420615"></p><p>SizeOfRawData为00 92 19 00=0x199200</p><p>块的大小和前面三个头(DOS部首+PE文件头+块表)的大小一样，也要<strong>满足文件对齐</strong></p><p>先前得到的FileAlignment为0x200，这里的SizeOfRawData：0x199200为FileAlignment的整数倍，满足文件对齐</p><hr><h4 id="块的结束地址-下一个块的起始地址"><a href="#块的结束地址-下一个块的起始地址" class="headerlink" title="块的结束地址(下一个块的起始地址)"></a>块的结束地址(下一个块的起始地址)</h4><p>块的结束地址为块的起始地址+块的大小</p><p>即块的结束地址=0x400+0x199200=199600</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316153738194.png" alt="image-20210316153738194"></p><hr><p>可以看到第一个块和第二个块之前是<strong>存在空隙</strong>的，这段空隙也是由于<strong>文件对齐</strong>产生的</p><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>在非运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>文件对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>文件对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SizeOfHeaders</td><td align="left">扩展PE头</td><td align="left">头大小（文件对齐后）</td></tr><tr><td align="left">FileAlignment</td><td align="left">扩展PE头</td><td align="left">文件对齐</td></tr><tr><td align="left">PointerToRawData</td><td align="left">块表</td><td align="left">第一个块表的PointerToRawData由SizeOfHeaders决定，后面块表的PointerToRawData由前一个块表的PointerToRawData+SizeOfRawData决定</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">块表</td><td align="left">块表的大小（文件对齐后）</td></tr></tbody></table><hr><p>记录一下各结构的起始和结束位置，方便和运行态进行比较</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">0</td><td align="left">F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">F0</td><td align="left">1E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">1E8</td><td align="left">2B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">0</td><td align="left">400</td><td align="left">0x400（文件对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">400</td><td align="left">199600</td><td align="left">0x199200（文件对齐后）</td></tr></tbody></table><hr><h1 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h1><p>前面介绍了非运行态（硬盘状态）下PE文件的结构，现在看看运行态（内存状态）下PE文件的结构</p><h2 id="加载运行态的PE文件"><a href="#加载运行态的PE文件" class="headerlink" title="加载运行态的PE文件"></a>加载运行态的PE文件</h2><p><strong>1.启动PE文件</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132316337.png" alt="image-20210316132316337"></p><hr><p><strong>2.然后返回WinHex，点击工具→打开RAM(R)… 或直接使用快捷键Alt+F9</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132406704.png" alt="image-20210316132406704"></p><hr><p><strong>3.打开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132549551.png" alt="image-20210316132549551"></p><p><strong>选中我们要分析的PE文件，使其展开</strong></p><hr><p><strong>4.展开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132819269.png" alt="image-20210316132819269"></p><p><strong>选中.exe打开</strong></p><hr><p><strong>5.最后确定即可</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316133031067.png" alt="image-20210316133031067"></p><hr><h2 id="分析运行态的PE文件"><a href="#分析运行态的PE文件" class="headerlink" title="分析运行态的PE文件"></a>分析运行态的PE文件</h2><p>按照先前分析的流程，再分析一遍运行态下的PE文件</p><h3 id="DOS部首和PE头标志"><a href="#DOS部首和PE头标志" class="headerlink" title="DOS部首和PE头标志"></a>DOS部首和PE头标志</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134218062.png" alt="image-20210316134218062"></p><p>此时的DOS部首起始地址为400000，结束地址为4000F0</p><hr><h3 id="PE文件头标志和标准PE头-1"><a href="#PE文件头标志和标准PE头-1" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134123745.png" alt="image-20210316134123745"></p><p>此时PE文件头的起始地址为4000F0，结束地址为400108</p><hr><h3 id="扩展PE头-1"><a href="#扩展PE头-1" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134503765.png" alt="image-20210316134503765"></p><p>此时PE文件头的起始地址为400108，结束地址为4001E8</p><hr><h3 id="块表-1"><a href="#块表-1" class="headerlink" title="块表"></a>块表</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134642926.png" alt="image-20210316134642926"></p><p>此时块表的起始地址为4001E8，结束地址为4002B0</p><hr><h3 id="块表后的空隙-1"><a href="#块表后的空隙-1" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>从前面的分析来看，在块表前的结构在运行态和非运行态除了起始地址不同以外，其它地方并无不同</p><p>起始地址的由来等相关内容留作之后的笔记说明</p><p>按照经验，块表后的空隙也应该是持续到先前的400+400000=400400</p><p>于是前往查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135241232.png" alt="image-20210316135241232"></p><hr><p>发现并非如此，400400仍然为空隙</p><p>先前分析得知在非运行态块表后的空隙是因为文件对齐产生的</p><p>而在运行态中，显然就<strong>不是由文件对齐决定的</strong></p><hr><p>接着向下查看，找到<strong>块的起始位置</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135922474.png" alt="image-20210316135922474"></p><hr><p>发现此时块的起始位置为401000，偏移为1000，而不是 非运行态的400</p><p>于是熟悉的问题又回来了：</p><p><strong>为什么会存在这段空隙？</strong></p><p>和先前的文件对齐类似，当程序处于运行态时，会有另一种对齐方式：<strong>内存对齐</strong></p><p>和内存对齐相关的属性和文件对齐（FileAlignment）类似，也是取决于扩展PE头中的一个成员</p><hr><p>再次给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;                        //&lt;--- 内存对齐</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SectionAlignment成员，会发现它就在FileAlignment（文件对齐）成员的上面</p><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为400108</p><p>从400108开始往后找32个字节（中间间隔了1个WORD，2个BYTE，7个DWORD，即1<em>2+2</em>1+7*4=32）</p><p>SectionAlignment的地址为：0x400108+32=0x400000+264+32=0x400000+296=0x400128</p><p>SectionAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316141510008.png" alt="image-20210316141510008"></p><p>SectionAlignment为00 10 00 00=0x1000（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是SectionAlignment的整数倍</p><p>头大小应该设置为SectionAlignment的整数倍：(2B0/1000+1)*1000=1000</p><p>PS：这里的头大小不会被设置到SizeOfHeaders，因为SizeOfHeaders为文件对齐专用</p><h3 id="块-1"><a href="#块-1" class="headerlink" title="块"></a>块</h3><p>在非运行态中，块的起始位置由PointerToRawData决定，且PointerToRawData必须为FileAlignment的整数倍</p><p>但在运行态中，块的起始位置则并不由PointerToRawData决定，PointerToRawData和SizeOfHeaders一样都为文件对齐专用</p><p>运行态块存储涉及内容较多，这里只查看一下第一个块的起始地址、结束地址和大小，<strong>不作具体探究</strong>，其它留作之后的笔记</p><h4 id="块的起始地址-1"><a href="#块的起始地址-1" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>第一个块的起始地址取决于（DOS部首+PE文件头+块表）的总大小进行内存对齐后的结果</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162649154.png" alt="image-20210316162649154"></p><p>第一个块的起始地址=0x400000+0x1000=0x401000</p><hr><h4 id="块的结束地址"><a href="#块的结束地址" class="headerlink" title="块的结束地址"></a>块的结束地址</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162347979.png" alt="image-20210316162347979"></p><p>第一个块的结束地址=0x59B000</p><hr><h4 id="块的大小-1"><a href="#块的大小-1" class="headerlink" title="块的大小"></a>块的大小</h4><p>块的大小=块的结束地址-块的起始地址=0x59B000-0x401000=0x19A000（满足内存对齐）</p><hr><p><strong>运行态时，块的大小满足内存对齐，非先前的文件对齐</strong></p><hr><h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p>在运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>内存对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>内存对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SectionAlignment</td><td align="left">扩展PE头</td><td align="left">内存对齐</td></tr></tbody></table><hr><p>各结构的起始和结束位置：</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">400000</td><td align="left">4000F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">4000F0</td><td align="left">4001E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">4001E8</td><td align="left">4002B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">400000</td><td align="left">401000</td><td align="left">0x1000（内存对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">401000</td><td align="left">59B000</td><td align="left">0x19A000（内存对齐后）</td></tr></tbody></table><hr><h1 id="对比PE两种状态"><a href="#对比PE两种状态" class="headerlink" title="对比PE两种状态"></a>对比PE两种状态</h1><p>本笔记主要针对PE两种状态中的文件对齐和内存对齐进行比较，<strong>其它的内容暂时没有涉及</strong>，将在后续笔记里陆续提到</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>无论是在运行态还是在非运行态，DOS部首、PE文件头、块表块表均为连续存储，中间没有空隙</p><p>第一个块表的首地址都受DOS部首大小+PE文件头大小+块表大小影响，都需要对齐</p><p>块和块之间也都需要对齐</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>运行态和非运行态的起始地址不同</p><p>在非运行态中，块表和块之间的空隙由<strong>文件对齐</strong>产生，块和块之间的空隙由<strong>文件对齐</strong>产生</p><p>在运行态中，块表和块之间的空隙由<strong>内存对齐</strong>产生，块和块之间的空隙由<strong>内存对齐</strong>产生</p><hr><h2 id="非运行态和运行态映射图"><a href="#非运行态和运行态映射图" class="headerlink" title="非运行态和运行态映射图"></a>非运行态和运行态映射图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316163800340.png" alt="image-20210316163800340"></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记一 PE介绍</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%931/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%931/</url>
      
        <content type="html"><![CDATA[<p>近期发现了一个超牛逼的大佬，和大佬写的超详细的pe总结，所以就根据（抄袭）大佬文章做一些pe总结来巩固学习。</p><p>先挂上大佬文章链接：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89</a></p><h5 id="可执行文件的格式"><a href="#可执行文件的格式" class="headerlink" title="可执行文件的格式"></a>可执行文件的格式</h5><hr><h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><p>PE(Portable Executable)<strong>文件结构</strong></p><h4 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h4><p>ELF(Executable and Linking Format)<strong>文件结构</strong></p><hr><h5 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h5><p>.exe .dll .sys都是windows下常见的可执行文件。（他们都遵循pe文件结构大二的格式）</p><hr><h5 id="常见的非可执行文件"><a href="#常见的非可执行文件" class="headerlink" title="常见的非可执行文件"></a>常见的非可执行文件</h5><ul><li>.txt .png .mp4等等都是非可执行文件，它们都需要使用其它可执行文件的软件进行加载</li><li>.txt可以使用Notepad、UltraEdit等 文本 工具查看</li><li>.png可以使用PhotoShop等 图片 工具查看</li><li>.mp4可以使用PotPlayer等 播放器 工具查看</li></ul><hr><h5 id="为什么要学习pe"><a href="#为什么要学习pe" class="headerlink" title="为什么要学习pe"></a>为什么要学习pe</h5><ul><li>pe是windows下可执行文件必须遵循的规范</li><li>对软件的加壳与脱壳都基于pe</li><li>EXE文件如何加载到内存中也涉及PE的知识</li><li>一个合格的逆向人员，必须熟悉PE</li></ul><hr><h5 id="如何识别pe文件"><a href="#如何识别pe文件" class="headerlink" title="如何识别pe文件"></a>如何识别pe文件</h5><p>不管是.exe .dll还是.sys ，他们都是pe文件，所以他们的前两个字节一定都是4D 5A(ASCII码为MZ)</p><p>我们用winhex打开三种文件观察一下（这里直接没用大佬的三张图）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131655743.png" alt="exe文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131945543.png" alt="dll文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315132009119.png" alt="sys文件"></p><hr><h5 id="3Ch位置的数据（不做总结了）"><a href="#3Ch位置的数据（不做总结了）" class="headerlink" title="3Ch位置的数据（不做总结了）"></a>3Ch位置的数据（不做总结了）</h5><hr><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>如果一个文件，它的头两个字节为4D 5A（ASCII码为MZ），并且通过3Ch位置的数据再找到的位置里的数据为PE则基本可以断定这个文件是Windows下的可执行文件（满足PE结构）</p><hr><h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><p>随便拉一个图片png文件进来看看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315134549954.png" alt="image-20210315134549954"></p><p>很显然，开头的两个字节就已经表明它不是一个PE文件了</p><p>PS：识别可执行文件不能通过文件的后缀名来判断，而应该采用上述的方式进行判断，因为后缀名是可以改的。</p><hr><p>通过前面列举的知识，我们已经知道如何识别一个pe文件了，但是为什么是查看一个文件的前2个字节和3Ch的位置，以及其它位置数据作用呢。</p><p>这便是PE结构所<strong>规定</strong>的</p><h5 id="下面是PE文件的总体结构"><a href="#下面是PE文件的总体结构" class="headerlink" title="下面是PE文件的总体结构"></a>下面是PE文件的总体结构</h5><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144634951.png" alt="pe文件结构"></p><hr><p>可以看到先前判断PE文件特征里的头两个字节对应这里的文件头：DOS ‘MZ’ HEADER</p><p>后面根据3Ch得到的50 45（对应ACSII码为PE）对应这里的PE文件头中的”PE”</p><hr><p>（接下来是重点）</p><hr><h5 id="pe在c中的定义"><a href="#pe在c中的定义" class="headerlink" title="pe在c中的定义"></a>pe在c中的定义</h5><p>pe文件结构自然也是一种数据结构（比较复杂的数据结构）</p><p>在c语言中的winnt.h这个头文件中定义了pe文件结构相关的结构体。</p><p>所以我们可以直接通过c语言中的pe的定义来更好的学习pe</p><p>（直接cv大佬）</p><p>随便创建一个空的控制台项目，然后引入winnt.h这个头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103747813.png" alt="image-20210612103747813"></p><p>然后在引入的头文件处右键转到文档</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103935331.png" alt="image-20210612103935331"></p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104002548.png" alt="image-20210612104002548"></p><p>接下来大佬就会根据这个头文件来学习pe文件的总体结构了</p><hr><h5 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h5><p>该部分结构对应winnt.h中的**_IMAGE_DOS_HEADER**结构体</p><p>可以在先前打开的winnt.h中Ctrl+F搜索_IMAGE_DOS_HEADER</p><p>查找后得到</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104222424.png" alt="image-20210612104222424"></p><p>这里贴上大佬提出来的字段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><hr><p>这里我们只需要关注这两个字段就好了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WORD   e_magic                *    <span class="string">&quot;MZ标记&quot;</span> 用于判断是否为可执行文件.</span><br><span class="line">DWORD  e_lfanew;              *    PE头相对于文件的偏移，用于定位PE文件</span><br></pre></td></tr></table></figure><hr><h3 id="PE文件头-NT头"><a href="#PE文件头-NT头" class="headerlink" title="PE文件头(NT头)"></a>PE文件头(NT头)</h3><p>该部分结构对应winnt.h中的**_IMAGE_NT_HEADERS**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>可以看到PE文件头对应的结构体中还包含了其它结构体，这里依旧只介绍大体作用，细节留作之后的笔记</p><p>这里的PE文件头相对于先前的DOS部首则是<strong>给Windows使用的</strong></p><hr><h3 id="块表-节表"><a href="#块表-节表" class="headerlink" title="块表(节表)"></a>块表(节表)</h3><p>该部分结构对应winnt.h中的**_IMAGE_SECTION_HEADER**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>块表主要用来表示当前文件一共分为几个部分，和后面的块相对应</p><p>块表决定了后面的块，每一块从哪里开始，里面存储的数据是什么等等</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块部分是由前面的块表决定的，是具体的存储数据的部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144652675.png" alt="image-20210315144652675"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315195059766.png" alt="image-20210315195059766"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/PE.png" alt="PE"></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构新增节</title>
      <link href="2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/"/>
      <url>2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>首先先了解一下节表</strong></p><p>如下图，打开一个exe文件，我们可以看到有多个节表。<br><img src="https://img-blog.csdnimg.cn/20210611093247579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要有这么多节表呢？每个节表都有自己的任务与功能，所以我们可以手动添加一个节来实现我们自己想实现的功能。</p><hr><p>然后我们在了解一下节表的主要成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//8个字节名字.自己可以起.编译器也可以给定.不重要.</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;       </span><br><span class="line">            DWORD   VirtualSize;           <span class="comment">//节数据没有对齐后的大小.也就是没有对齐.节数据有多大.</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;　　　　　　　　　　<span class="comment">//加载到内存中的第一个字节的地址.也就是虚拟地址.节在内存中哪里开始.内存中的VA + ImageBase 才是真正的节开始位置</span></span><br><span class="line">    DWORD   SizeOfRawData;　　　　　　　　　　 <span class="comment">//修改这个属性的值,即可扩大节.并且在PE文件中添加相应的0数据进行填充.</span></span><br><span class="line">    DWORD   PointerToRawData;　　　　　　　　  <span class="comment">//在文件中的偏移.是文件对齐成员倍数.</span></span><br><span class="line">    DWORD   PointerToRelocations;           <span class="comment">//一下都是调试相关.</span></span><br><span class="line">    DWORD   PointerToLinenumbers;           <span class="comment">//</span></span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;　　　　　　　　　　<span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>重点了解以下成员</p><blockquote><p>Name[IMAGE_SIZEOF_SHORT_NAME]:我们可以随便起一个自己喜欢的名字 VirtualSize：是在内存中的真实大小<br>VirtualAddress：是加载到内存中第一个字节的偏移地址 SizeOfRawData：该节在文件对齐后的大小</p></blockquote><hr><p>了解过节表以后，我们再来整理一下操作步骤。</p><p>[TOC]</p><h1 id="1-判断是否有空间新增一个节。"><a href="#1-判断是否有空间新增一个节。" class="headerlink" title="1.判断是否有空间新增一个节。"></a>1.判断是否有空间新增一个节。</h1><p>使用工具打开一个exe文件，我们只需要40个字节，所以空间足够<br><img src="https://img-blog.csdnimg.cn/20210611122435362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="2-在节表的最后一个成员后新增一个成员。"><a href="#2-在节表的最后一个成员后新增一个成员。" class="headerlink" title="2.在节表的最后一个成员后新增一个成员。"></a>2.在节表的最后一个成员后新增一个成员。</h1><p>添加的新成员我们可以选择直接复制text节表，因为text作为代码段，可读可写可执行，非常完美。如下图，我们已经添加好了数据。<br><img src="https://img-blog.csdnimg.cn/20210611122700675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="3-修改节的数量。"><a href="#3-修改节的数量。" class="headerlink" title="3.修改节的数量。"></a>3.修改节的数量。</h1><p>标准pe头中有一个字段为 NumberOfSections，该字段控制文件中节的数量<br>，所以我们讲该字段的值加一，如下图，原来为08，我们修改为09</p><p><img src="https://img-blog.csdnimg.cn/20210611153418937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="4-修改sizeOfImage的大小"><a href="#4-修改sizeOfImage的大小" class="headerlink" title="4.修改sizeOfImage的大小"></a>4.修改sizeOfImage的大小</h1><p>修改前：<br>可选头中：SizeofImage ：000AC000<br><img src="https://img-blog.csdnimg.cn/20210611154120619.png" alt="在这里插入图片描述"></p><p>我们新增了0x1000节数据大小.那么我们的镜像大小也要加0x1000大小进行映射.注意.要按照内存对齐。<br>我们的原镜像大小以及按照内存对齐的方式存放了. 就是0xAC000. 那么我们加了0x1000的数据就是 0x1E000大小.我们修改为0xAD000。</p><hr><h1 id="5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍"><a href="#5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍" class="headerlink" title="5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)"></a>5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)</h1><p>插入了0x1000字节，填充为0</p><hr><h1 id="6-添加新增节表的属性"><a href="#6-添加新增节表的属性" class="headerlink" title="6.添加新增节表的属性"></a>6.添加新增节表的属性</h1><p>想要添加一个节表，首先我们需要为这个节表指明内存中开始展开的位置，文件中展开的位置，以及节表的大小。<br>这三个属性的字段分别是VirtualAddress、PointerToRawData、SizeOfRawData。然后我们在pe中把他们找出来并修改。<br>例如上一个节表对齐后的展开位置为 0xAc000 那么我们就修改为 0xAd000<br>修改前：<br><img src="https://img-blog.csdnimg.cn/20210611182603575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>修改后：</p><p><img src="https://img-blog.csdnimg.cn/20210611182610388.png" alt="在这里插入图片描述"></p><p>节.sizeofRawData修改<br>这个成员就是节数据按照文件对齐后的大小.取决于我们给这个节添加多少数据，这里我们之前添加了0x1000个字节。<br>　　这里修改为1000<br>　　<br><img src="https://img-blog.csdnimg.cn/20210611182619861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.PointerRawToData 文件偏移修改<br>最后修改的就是节在文件中哪里展开的. 这个我们需要看上一个节的文件偏移.以及节数据大小. 算出来的.<br>例如：<br>新增节的上一个节，偏移位置为1000，节数据在文件中对齐后的尺寸为100，那么1000-1100都是上一个节的数据</p><p>.tttt上一个节在文件中的偏移为8200，大小为600；<br>　那么tttt节的文件偏移就为8800<br>　<img src="https://img-blog.csdnimg.cn/20210611182634534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.VirtualSize修改<br>申请的新节空间大小，1000</p><p>节.PointerRawToData 文件偏移修改<br>我们新增节一般都是要求可读可写可执行的，所以这里直接修改为60000020。</p><p>实验结果：<br>新增节后的文件正常执行</p><p><img src="https://img-blog.csdnimg.cn/20210611182641868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>部分内容转载于：<a href="https://blog.csdn.net/weixin_43742894/article/details/115376779">https://blog.csdn.net/weixin_43742894/article/details/115376779</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构在空白区添加代码</title>
      <link href="2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"><a href="#想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。" class="headerlink" title="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"></a><strong>想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。</strong></h2></blockquote><p>1.查找本机MessageBoxA地址<br>2.打开OD调试工具拖入要添加的exe程序。<br>3.在命令中输入 : （输入后按下回车键）<br>4.找任意一段空白区添加上代码 （最好是添加到 空白区开始预留一行的位置，便于以后再添加更多代码节约空间）<br>5.计算E8跳转的地址<br>6.修改OEP （程序入口的点）</p><blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2></blockquote><table><thead><tr><th>汇编指令</th><th>硬编码</th></tr></thead><tbody><tr><td>call</td><td>E8 00 00 00 00</td></tr><tr><td>jmp</td><td>E9 00 00 00 00</td></tr><tr><td>push</td><td>6A 00</td></tr></tbody></table><h2 id="1-查找本机MessageBoxA地址"><a href="#1-查找本机MessageBoxA地址" class="headerlink" title="1.查找本机MessageBoxA地址"></a>1.查找本机MessageBoxA地址</h2><p>1.打开OD调试工具拖入要添加的exe程序。<br>讲你想要修改的exe程序拖入od调试工具中，这里我们需要注意该exe程序必须有user32.dll，否则没有我们要添加的代码–MessageA函数的地址。<br><img src="https://img-blog.csdnimg.cn/20210609215454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-在命令中输入-（输入后按下回车键）"><a href="#2-在命令中输入-（输入后按下回车键）" class="headerlink" title="2.在命令中输入 : （输入后按下回车键）"></a>2.在命令中输入 : （输入后按下回车键）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp MessageBoxA</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210609215640888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如此一来，我们就成功在MessageA函数的地址下了断点。点击断点的窗口即可查看我们设置好的断点。<br><img src="https://img-blog.csdnimg.cn/20210609215811850.png" alt="在这里插入图片描述"></p><h2 id="开始添加代码"><a href="#开始添加代码" class="headerlink" title="开始添加代码"></a>开始添加代码</h2><p>1.接下来就该添加我们想要添加的代码了，随便找一个空白位置，然后我们计算call后的值，<br>call后的值=调用函数的地址-message函数的地址-5（call命令本身所占的内存大小），现在调用函数的地址是在问价中的地址，而不是在内存中的地址，所以首先我们需要找到程序载入内存的基地址ImageBase，在扩展PE头的第 28 个字节后面的 4 个字节表示的 ImageBase ( 程序基地址 )，如下图<br><img src="https://img-blog.csdnimg.cn/20210610205831374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1表示扩展pe头，2表示标准pe头），所以当前调用函数的地址为我们在文件中添加call指令的地址加上imagebase的值，所以call后的值=MessageBoxA的地址 - 当前调用函数的地址 - 5<br>此时计算好地址后，查看对应的硬编码，首先是三个push：6A 00 6A 00 6A 00 6A 00 然后是call 指令 E8，然后写如我们计算好的地址，记得小端存储。<br>代码我们已经写好了，那么我们现在应该想想怎么使程序到这个地址来执行我们添加的代码，我们可以修改程序的入口函数eop，（在扩展PE头的第 16 个字节后面的 4 个字节），如下图<br><img src="https://img-blog.csdnimg.cn/20210610211816996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1程序入口:0x401170（相对于程序基地址）2，扩展PE头的开始）<br>把程序拖入OD，程序第一次停止的的地址就是程序入口<br><img src="https://img-blog.csdnimg.cn/20210610212056621.png" alt="在这里插入图片描述"></p><p>所以只要修改程序入口地址，把程序入口改为调用函数的地址，然后在调用后再返回到真正的程序入口，就可以在程序执行前执行我们想调用的函数</p><p>修改程序入口为0x600</p><p><img src="https://img-blog.csdnimg.cn/20210610212115474.png" alt="在这里插入图片描述"></p><p>现在就9可以达到在程序执行前调用MessgaBoxA函数的效果，但是要执行完这个函数后，再返回到真正的程序入口，不然程序不能够正常运行，于是又要在我们要调用的函数后面再制造一个返回到真正程序入口处的机器码<br>这里就在用到jmp这个指令，表示直接跳转到某个指定的地址</p><p>先看一下jmp要如何使用</p><p><img src="https://img-blog.csdnimg.cn/20210610212230109.png" alt="在这里插入图片描述"></p><p>这里jmp的使用方法其实和call的规律一样只是开头的 E8 变成了 E9</p><p><img src="https://img-blog.csdnimg.cn/20210610212236672.png" alt="在这里插入图片描述"></p><p>所以E9后面的值应该是</p><p>jmp后的值 = 程序入口的地址 - 当前的地址 - 5 = 0x401170 - 0x40060D - 5 = 0x0B5E</p><p>当前的地址应该是0x40060D</p><p>所以修改后就是这样的<br><img src="https://img-blog.csdnimg.cn/20210610212246737.png" alt="在这里插入图片描述"></p><p>此时把程序另存为message_test.exe, 运行出现了我们预期的效果<br><img src="https://img-blog.csdnimg.cn/20210610212254405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>源程序的代码是很简单，但是要注意要有MessageBoxA函数</p><p>不然在最开始没有user32dll，我也不知道为什么，但如果是正常的程序都会有user32dll(因为一般的程序都有窗口)</p><p>我是用下面的代码做的实验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// messge.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nothing...&quot;</span>);</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">&quot;这是已有的弹框&quot;</span>,<span class="string">&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单介绍一点点PE文件头结构</p><p>DOS头部分：</p><p>DOS MZ 文件头 (64字节):<br>前 64 个字节，最后 8 个字节表示 PE 文件头的开始位置, DOS 块结束前的位置，绿色箭头指向PE文件头的开始<br><img src="https://img-blog.csdnimg.cn/20210610212422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>DOS 块 (不确定):<br>链接器可插入数据</p><p>PE文件头:</p><p>PE文件标识 (4字节):<br>50 45 00 00</p><p>标准 PE 头 (20字节):</p><p>扩展 PE 头</p><p>(32位 224 [0xE0] , 64 位 240 [0xF0] ):</p><pre><code>  第 36 个字节开始的后 4 个字节表示 硬盘 中文件对齐的字节数大小,  前 4 个字节表示 内存 中文件对齐的字节数大小,  第 60 个字节开始的四个字节表示整个文件头的大小( DOS 部分+ PE 文件头),一定是对齐字节数的整数倍  第 16 个字节后面的 4 个字节表示程序入口(相对 ImageBase )  第 28 个字节后面面的 4 个字节表示的 ImageBase ( 程序基地址 )</code></pre><p>图片与部分内容转载于<a href="https://blog.csdn.net/m0_49490199/article/details/111657821">https://blog.csdn.net/m0_49490199/article/details/111657821</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于硬编码的一些理解（水）</title>
      <link href="2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/"/>
      <url>2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在最近的学习过程中，了解到了硬编码这一个名词，于是就去百度了一下，从字面意思上来看，我对硬编码的理解就是一种类似于编程语言的东西，但百度过后发现好像每一篇文章对硬编码的讲解都不大一样，搞得我一脸懵逼，于是就来总结一下各篇文章的讲解。首先我们看一下百度百科的结果：</p><blockquote><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。<br>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。<br>硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。<br>另一方面，软编码数据对用户输入，HTTP服务器响应或配置文件等任意信息进行编码，并在运行时确定。</p></blockquote><p>看完以后仍然一脸懵逼，于是继续百度，过程中看到了一个例子：<br><strong>硬编码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">　　a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a直接用固定数值2限定死了，如果想要修改的话(修改a的值或者==号右边的值都是很不方便的，而且很容易出错）很不方便。</p><p><strong>软编码</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">　　a ++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a和b都是变量名称，我们完全可以在初始化a和b的时候给二者赋值，不必直接用固定数值限定死，这样有利于方便修改，可谓”占据制高点，统筹全局”。<br>转载于:<a href="https://www.cnblogs.com/zhongshujunqia/p/4611543.html">https://www.cnblogs.com/zhongshujunqia/p/4611543.html</a></p><p>看过这两条例子以后，大概了解到硬编码只是一种编程方式。再结合百度百科的结果：<strong>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。</strong>大概了解到硬编码是把一个本来应该（可以）写到配置信息中的信息直接在程序代码中写死了。<br>例如，写了一个收发邮件的程序，用户名，密码，服务器地址等最好做成外部配置， 但是如果直接写死在程序代码中，每次改信息时需要重新编译了……这种程序不好维护。一般懒的程序员或者初学者这种程序产量较大。<br>在计算机程序或文本编辑中，hardcode(这个词比hard code用起来要频繁一些)是指将可变变量用一个固定值来代替的方法。<br>用这种方法编译后，如果以后需要更改此变量就非常困难了。<br>大部分程序语言里，可以将一个固定数值定义为一个标记，然后用这个特殊标记来取代变量名称。当标记名称改变时，变量名不变，这样，当重新编译整个程序时，所有变量都不再是固定值，这样就更容易的实现了改变变量的目的。<br>尽管通过编辑器的查找替换功能也能实现整个变量名称的替换，但也很有可能出现多换或者少换的情况，而在计算机程序中，任何小错误的出现都是不可饶恕的。<br>最好的方法是单独为变量名划分空间，来实现这种变化，就如同前面说的那样，将需要改变的变量名暂时用一个定义好的标记名称来代替就是一种很好的方法。<br>通常情况下，都应该避免使用hardcode方法。有时也用hardcode来形容那些非常难学的语言，比如C或者C++语言，相对的，用softcode来形容象VB这类简单好用的程序语言。<br><strong>hardcode就是固化的代码</strong>。有的代码不能写死，不然修改起来很麻烦。比如说写链接写死<a href="http://www.abc.com,所有的地方都用这个,如果下次域名变了,那么就要找到所有的www.abc.com修改成新的域名./">www.abc.com，所有的地方都用这个，如果下次域名变了，那么就要找到所有的www.abc.com修改成新的域名。</a><br>但是如果用一个常量来存放<a href="http://www.abc.com,然后所有链接都引用常量,那么以后修改就只要修改常量了./">www.abc.com，然后所有链接都引用常量，那么以后修改就只要修改常量了。</a></p><p>部分内容参考于<a href="https://zhuanlan.zhihu.com/p/54134459">https://zhuanlan.zhihu.com/p/54134459</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件对齐</title>
      <link href="2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/"/>
      <url>2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>内存对齐与文件对齐</strong></p></blockquote><p>一个pe文件无论在磁盘和内存中存放都会进行对齐，但他们的对齐值会不相同。<br>PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。<br>PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。<br>rva与fov的相互转换</p><blockquote><p><strong>RVA与FOV的相互转换</strong></p></blockquote><p>为什么要转换：可以通过内存位置.找到文件中这个数据的位置. 或者反之. 如果找到就可以进行修改了。<br>RVA(Relative Virtual Address)指的是内存中的一个数据相对于文件头位置的偏移量。<br>举个例子：<br>当我们想要访问一个数据时，如果 Windows 装载器将一个PE 文件装入到 00400000h 处的内存中，而某个区块中的某个数据被装入 0040…xh 处，那么这个数据的 RVA 就是（0040…xh - 00400000h ）= …xh。(RVA = 虚拟地址-ImageBase(模块基址.程序一开始的地址.))<br>FOV与RVA大致相同，FOV指的是文件在硬盘中时访问的数据的的位置相对于文件头位置的偏移量。<br>所以由此我们可以看到他们之间的关系。当rva的位置在文件头中时，由于rva还没有收到拉伸的影响，所以此时rva等于fov的值。<br>当不在文件头中时，我们只需要计算出数据的位置，与该数据所在的节的差值，然后该差值是与硬盘中的数据所在位置与所在节的差值相同，所以我们先求出差值=rva-节<em>virtualadress(内存对齐值)。然后fov=差值+节</em>pointertorawData(文件对齐值)。</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/06/01/pe%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/01/pe%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a><strong>DOS头</strong></h2></blockquote><p>typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header<br>WORD   e_magic;                     // 一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>WORD   e_cblp;                      <br>WORD   e_cp;                        <br>WORD   e_crlc;                      <br>WORD   e_cparhdr;                <br>WORD   e_minalloc;                  <br>WORD   e_maxalloc;                <br>WORD   e_ss;                      <br>WORD   e_sp;                      <br>WORD   e_csum;                <br>WORD   e_ip;                        <br>WORD   e_cs;                        <br>WORD   e_lfarlc;                <br>WORD   e_ovno;                <br>WORD   e_res[4];      <br>WORD   e_oemid;                  <br>WORD   e_oeminfo;                  <br>WORD   e_res2[10];                <br>LONG   e_lfanew;                    //Offset to start of PE header   指向PE文件头<br>  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;                                        </p><blockquote><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a><strong>PE文件头</strong></h2></blockquote><p>IMAGE_NT_HEADERS STRUCT<br>DWORD Signature                    PE文件标识<br>IMAGE_FILE_HEADER  FileHeader     pe标准文件头<br>IMAGE_OPTIONAL_HEADER32 OptionalHeader<br>IMAGE_NT_HEADERS ENDS                                        </p><blockquote><h2 id="pe标准文件头"><a href="#pe标准文件头" class="headerlink" title="pe标准文件头"></a><strong>pe标准文件头</strong></h2></blockquote><p>typedef struct_IMAGE_FILE_HEADER{<br>WORD Machine;          //可以运行在什么cpu上，任意: 0   Intel 386以及后续: 14C   x86: 8864<br>WORD NumberOfSections;                  //表示节的数量(一共有多少个节)<br>DWORD TimeDataStamp;              //编写器填写的时间戳 与文件属性里面(创建时间、修改时间)无关<br>DWORD PointerToSymbolTable          //调试相关<br>DWORD PointerOfSymbols;             //调试相关<br>WORD SizeOfOptionalHeader             //可选PE头的大小(32位PE文件;  0xE0 64位PE文件: 0xF0)<br>WORD Characteristics;               //文件属性<br>}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;                                        </p><blockquote><h2 id="pe可选文件头"><a href="#pe可选文件头" class="headerlink" title="pe可选文件头"></a><strong>pe可选文件头</strong></h2></blockquote><p>//32位的可选pe头长度为E0， 64位的可选pe头长度为F0</p><p>WORD    Magic;        *                说明文件类型：10B 32位下的PE文件     20B 64位下的PE文件<br>BYTE    MajorLinkerVersion;<br>BYTE    MinorLinkerVersion;<br>DWORD   SizeOfCode;*                所有代码节的和，必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfInitializedData;*                已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfUninitializedData;*                未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   AddressOfEntryPoint;*                程序入口<br>DWORD   BaseOfCode;*                代码开始的基址，编译器填的   没用<br>DWORD   BaseOfData;*                数据开始的基址，编译器填的   没用<br>DWORD   ImageBase;*                内存镜像基址<br>DWORD   SectionAlignment;*                内存对齐<br>DWORD   FileAlignment;*                文件对齐<br>WORD    MajorOperatingSystemVersion;<br>WORD    MinorOperatingSystemVersion;<br>WORD    MajorImageVersion;<br>WORD    MinorImageVersion;<br>WORD    MajorSubsystemVersion;<br>WORD    MinorSubsystemVersion;<br>DWORD   Win32VersionValue;<br>DWORD   SizeOfImage;*                内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍<br>DWORD   SizeOfHeaders;*                所有头+节表按照文件对齐后的大小，否则加载会出错<br>DWORD   CheckSum;*                校验和，一些系统文件有要求.用来判断文件是否被修改.<br>WORD    Subsystem;<br>WORD    DllCharacteristics;<br>DWORD   SizeOfStackReserve;*                初始化时保留的堆栈大小<br>DWORD   SizeOfStackCommit;*                初始化时实际提交的大小<br>DWORD   SizeOfHeapReserve;*                初始化时保留的堆大小<br>DWORD   SizeOfHeapCommit;*                初始化时实践提交的大小<br>DWORD   LoaderFlags;<br>DWORD   NumberOfRvaAndSizes;*                目录项数目，剩余结构体的数量            </p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
