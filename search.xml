<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个最简单的小暴破</title>
      <link href="2021/06/24/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%8F%E6%9A%B4%E7%A0%B4%20/"/>
      <url>2021/06/24/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%8F%E6%9A%B4%E7%A0%B4%20/</url>
      
        <content type="html"><![CDATA[<p>爆破的软件是自己编写的一个很简单的注册弹窗软件，用e语言编写的，文章写的很粗糙。如有不对还望大佬指正。</p><p>首先我们需要理解程序验证的流程</p><blockquote><p>a、点击注册按钮</p></blockquote><blockquote><p>b、读取注册码</p></blockquote><blockquote><p>c、判断注册码是否合法</p></blockquote><blockquote><p>d、提示用户是否注册成功</p></blockquote><p>   暴破的时候我们就可以从以上四点为入手点，首先将程序拖入od，此时我们先找到读取编辑框内容的API函数：GetWindowTextA函数，ctrl+g转到该函数以后，设置一个断点，然后运行程序，但是我们发现运行不了，为什么呢？<br>   我们看一下对战窗口，可以看到函数的三个参数。第一个参数是：包含文本的窗口或控件的句柄。 第二个参数表示将接收文本的缓冲区。如果字符串与缓冲区一样长或长，则该字符串将被截断并以空字符结尾。，第三个参数表示的是要复制到缓冲区的最大字符数，包括空字符。如果文本超过此限制，则会被截断。<br><img src="https://img-blog.csdnimg.cn/20210624134132575.png" alt="在这里插入图片描述"><br>有的人这里会发现一直运行不了，就是因为第一个二参数的判断字柄是标签栏而不是编辑框。所以只需要shift+f2加上一个条件断点[esp+4]!=…….就行了<br>，然后我们继续运行，此时我们就可以正常往编辑框输入东西了，我们输入1111111。<br>我们再来回顾一下程序验证的流程，读取注册码后会判断注册码是否合法，然后提示用户是否注册成功。所以我们只需要先找到提示的地方，再往回找就能找到判断注册码的地方了。ctrl+f8自动步过。<br>这里有点小疑惑，因为程序又停止在了我们读取注册码的的地方了。视频上的老师只是说又读了一遍，具体为什么还望各位大佬指点一二。继续自动步过。<br>终于，程序又停止了，并弹出了弹窗提示我们注册失败，所以我们可以判断这个call函数时提示我们注册失败的函数。<br><img src="https://img-blog.csdnimg.cn/2021062414195230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们可以左键对准这个call找到im…点开 edit label，可以重命名：这个就是弹出消息框的call<br><img src="https://img-blog.csdnimg.cn/20210624142231981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时我们再向上翻找，可以看到有个与我们刚才重命名的call的名字一样的call<br><img src="https://img-blog.csdnimg.cn/20210624142413410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个可能就是提示注册成功的call。<br>此时提示用户的函数我们找到了，接下来就该往回找我们的判断函数了，王辉翻看了一下，发现了这个<br><img src="https://img-blog.csdnimg.cn/20210624142958552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到这是一个je指令，也就是条件跳转，就是我们的if判断，然后看他跳转的地址，在一个jmp指令的后面，此时我们约摸这就知道这是一个if else语句了。接下来当然就该修改这个if语句了，直接将je指令全部用nop填充，就相当于我们取消了判断。此时我们就相当于将这个程序破解掉了，此时不管我们输入什么，他都会提醒我们注册成功了。这就是一个最简单的暴破了。</p><p>然后我们开始第二种暴破方式，先将我们填充的nop还原，我们知道，jcc指令是否跳转取决于我们的标志寄存器：efl寄存器（efl寄存器有四位，因为od无法显示更多位，我们的c、p、a、z、等寄存器的值都是从efl寄存器的值中拆出来的，所以我们再修改以上寄存器的值是，其实是相当于在修改efl寄存器的值）。所以我们可以通过修改标志寄存器z寄存器，使其等于0，从而使je指令不执行跳转，jcc指令是否跳转取决于z寄存器的值。</p><p>我们还可以将提示是否注册成功作为入手点，ctrl+g查找messagebox函数并跳转，下过断点以后，f8单步一直走，我们也会走到提示失败的地方<br><img src="https://img-blog.csdnimg.cn/2021062414510046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种方法视频作者原话是按照经验往回走去寻找关键点，按照经验的意思是走多少没有定值，因为每一个作者，每一种语言写出来的都会不一样。这种方法我找半天没找到，就不找了T^T。大概意思是通过messagebox函数作为入口点继续找到我们的关键点，也就是那个je指令，然后破解就行了。</p><p>还有一种方法是搜索字符串，因为在搜索字符串的时候od会自动给我们加一下备注（我的没有T^T），这些备注又是就会给我们提供巨大的帮助。所以说一个好的工具还是很重要的啊。</p><p>说到字符串搜索，od里面实现这个功能的的不是od本身，而是od中的一个插件。所以我们也可以使用ida来搜索字符串，打开ida，shift+f12查看字符串窗口，然后ctrl+f5搜索字符串。我们先搜索一个“注册失败”尝尝咸淡，芜湖，淡了，啥也没搜出来，为什么呢？因为ida默认是不支持中文的的，所以如果我们使用ida搜索中文的时候，我们需要给ida增添一个属性。<br>先右击ida点开属性，然后在目标里加入: -dCULTURE=all 就可以了。但是我又搜了一下，发现我的还是啥也搜不出来，可能是我的exe文件有点毛病吧，程序员的悲欢并不相通（T^T）。</p><p>我就直接看着视频写笔记吧T^T</p><p>查找“注册失败”，然后双击进去，找到对应的函数，按x可以查看调用该函数的位置，双击进去，记住代码的位置，用od打开，ctrl+g输入我们刚才记住的位置，转到目标地址，发现对这个地址“不太熟啊”，不慌，我们先下个断点，然后继续往下单步运行，很快啊，就弹出了“注册失败”了，那么我们就开始往上寻找我们的关键点了。找到了一个je远眺跳到jmp的下面，这个大概率就是我们的要找的关键点，使用nop填充je，再次运行一下，果然“注册成功”。</p><p>这就是我们关于一个简单的小暴破的一些笔记了，接下来该保存了。选中我们修改的位置，右键 —-&gt;复制到可执行文件—&gt;所有修改—&gt;全部复制，然后在弹出的框上右键—&gt;保存文件 就完成了！</p><p>还有一种方法，内存查找法，我们可以直接在堆栈窗口中查找字符串，点击m，然后右键查找，输入“注册失败”，转到堆栈窗口后下个内存访问断点，然后运行od会发现od自动停了下来，停下来的的地方就是我们下的的断点的地方，此时我们只需要f8单步寻找关键点就可以了。</p><p>还有一种方法是硬件查找发，操作过程与内存查找法差不多，只需要在下内存访问断电的时候下硬件访问断点就可以了</p>]]></content>
      
      
      <categories>
          
          <category> reserve -crackme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reserve -crackme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF reverse SimpleRev</title>
      <link href="2021/06/24/buuctf%20SimpleRev/"/>
      <url>2021/06/24/buuctf%20SimpleRev/</url>
      
        <content type="html"><![CDATA[<p>每天一道ctf，能多不能少</p><p>题目<a href="https://buuoj.cn/challenges#SimpleRev">链接</a><br>首先拖入ida<br>打开以后查看main函数<br><img src="https://img-blog.csdnimg.cn/2021062319480561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图<br>可以看出，Dercy函数里的信息很重要，双击进入Dercy函数，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Decry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> src[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_QWORD *)src = <span class="string">&#x27;SLCDN&#x27;</span>;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="string">&#x27;wodah&#x27;</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  text = join(key3, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v9);         <span class="comment">// 让text等于key3+v9</span></span><br><span class="line">                                                <span class="comment">// key3 = &quot;kills&quot;</span></span><br><span class="line">                                                <span class="comment">// v9   = &quot;hadow&quot;     //因为小端序存储</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 则text = &quot;killshadow&quot;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(key, key1);                            <span class="comment">// 将key1复制给key</span></span><br><span class="line">                                                <span class="comment">// key = &quot;ADSFK&quot;</span></span><br><span class="line">  <span class="built_in">strcat</span>(key, src);                             <span class="comment">// 将src处的字符串拼接到key后</span></span><br><span class="line">                                                <span class="comment">// key = &quot;ADSFKNDCLS&quot;</span></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  getchar();                                    <span class="comment">// 获取输入（清空缓冲区？）</span></span><br><span class="line">  v5 = <span class="built_in">strlen</span>(key);                             <span class="comment">// v5 = key的长度   v5 = 10</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key[v3 % v5] &gt; <span class="number">64</span> &amp;&amp; key[v3 % v5] &lt;= <span class="number">90</span> )<span class="comment">// if(key[v3]&gt;64 &amp;&amp; key[v3]&lt;=90)</span></span><br><span class="line">                                                <span class="comment">// key[v3] = key[v3]+32</span></span><br><span class="line">                                                <span class="comment">// ：将大写字母转换成小写字母</span></span><br><span class="line">      key[i] = key[v3 % v5] + <span class="number">32</span>;               <span class="comment">// key = &quot;adsfkndcls&quot;</span></span><br><span class="line">    ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>, src);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="string">&#x27;\n&#x27;</span> )                           <span class="comment">// 如果输入的为换行符，则退出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="string">&#x27; &#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v2;                                     <span class="comment">// 如果输入的为空格，则v2加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &lt;= <span class="number">96</span> || v1 &gt; <span class="number">122</span> )               <span class="comment">// 如果输入的v1不为小写字母</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v1 &gt; <span class="number">64</span> &amp;&amp; v1 &lt;= <span class="number">90</span> )              <span class="comment">// 如果v1为大写字母</span></span><br><span class="line">          str2[v2] = (v1 - <span class="number">39</span> - key[v3++ % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;<span class="comment">// 对str2[v2]进行处理（v2为0每次加1）</span></span><br><span class="line">                                                <span class="comment">// str1[v2] = (v1-key[v3]+58)%26 + 97</span></span><br><span class="line">                                                <span class="comment">// 变换后str1[v2]存放小写字母</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;                                         <span class="comment">// 如果输入的值v1为小写字母</span></span><br><span class="line">        str2[v2] = (v1 - <span class="number">39</span> - key[v3++ % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;<span class="comment">// 做同样处理</span></span><br><span class="line">      &#125;                                         <span class="comment">// 如果不为大小写字母，则不进行处理</span></span><br><span class="line">      <span class="keyword">if</span> ( !(v3 % v5) )                         <span class="comment">// 如果循环到key的最后一位</span></span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);                           <span class="comment">// 打印处一个空格</span></span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(text, str2) )                    <span class="comment">// 如果text和str2存储的相同，则成功</span></span><br><span class="line">                                                <span class="comment">// text = &quot;killshadow&quot;</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下代码，join函数是一个自定义函数，点进去看一下，<br><img src="https://img-blog.csdnimg.cn/20210623195104918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>分析的到处，该函数可以将两个参数拼接在一起。继续往下分析，先是将两个字符串拼接成keys，然后转化为小写，然后将其进行了加密。比较的text就是我们的得到的flag。直接写照着代码解密就可以了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;adsfkndcls&#x27;</span></span><br><span class="line">key_ = <span class="string">&#x27;&#x27;</span></span><br><span class="line">v3=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        flag = <span class="built_in">ord</span>(key[v3%<span class="built_in">len</span>(key)])</span><br><span class="line">        <span class="keyword">if</span> flag &gt; <span class="number">64</span> <span class="keyword">and</span> flag &lt;=<span class="number">90</span>:</span><br><span class="line">                key_ += <span class="built_in">chr</span>(<span class="built_in">ord</span>(key[v3%<span class="built_in">len</span>(key)])+<span class="number">32</span>)</span><br><span class="line">        v3=v3+<span class="number">1</span></span><br><span class="line">ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>):</span><br><span class="line">                tmp=<span class="built_in">chr</span>(<span class="built_in">ord</span>(text[i]) - <span class="number">97</span> + <span class="number">26</span>*j - <span class="number">97</span> + <span class="built_in">ord</span>(key [v3%<span class="built_in">len</span>(key)]) + <span class="number">39</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(tmp)&gt;<span class="number">64</span> <span class="keyword">and</span> <span class="built_in">ord</span>(tmp) &lt;<span class="number">91</span>:</span><br><span class="line">                        ans+=tmp</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        v3=v3+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> ans</span><br></pre></td></tr></table></figure><p>好了，运行得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> ctf-re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF reverse 刮开有奖</title>
      <link href="2021/06/18/BUUCTF%20reverse%20%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/"/>
      <url>2021/06/18/BUUCTF%20reverse%20%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/</url>
      
        <content type="html"><![CDATA[<p>每天一道ctf，能多不能少</p><p>题目<a href="https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96">链接</a></p><p>下载好以后双击点开<br><img src="https://img-blog.csdnimg.cn/20210618200148365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>发现是这么个玩意儿，但我们却没法对它进行操作，好吧，查一下壳，然后直接用ida打开，查看主函数，这里我发现主函数是这种的<br><img src="https://img-blog.csdnimg.cn/20210618200008840.png" alt="在这里插入图片描述"></p><p>   学识短浅的我只能去百度，大概了解了一下：windows支持两种应用程序，一种是一种是基于控制台用户界面的应用程序（Console User Interface，简称CUI），另一种是基于图形用户界面的程序（Graphic User Interface，简称GUI）。然后main函数和WinMain函数分别是这两种应用程序的主函数（不知道这样理解做没错，原话是这样的：main函数和WinMain 函数是分别做为CUI和GUI的进入点函数被使用的。）废话不多说，继续我们的ctf。</p><p>所以我们打开主函数，然后查看反码。<br><img src="https://img-blog.csdnimg.cn/20210618200616703.png" alt="在这里插入图片描述"><br>这里面的函数是一个windowsAPI函数，作用是从一个对话框资源中创建一个模态对话框。参数我并不太明白，百度了一下也没百度出个结果，看了其他大佬的wp是这样说的的：<br><img src="https://img-blog.csdnimg.cn/20210618201111717.png" alt="在这里插入图片描述"><br>继续往下，查看代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">INT_PTR __stdcall <span class="title">DialogFunc</span><span class="params">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">2</span>]; <span class="comment">// [esp+8h] [ebp-20030h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+10h] [ebp-20028h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+14h] [ebp-20024h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+18h] [ebp-20020h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [esp+20h] [ebp-20018h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+24h] [ebp-20014h]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [esp+28h] [ebp-20010h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+30h] [ebp-20008h]</span></span><br><span class="line">  CHAR String[<span class="number">65536</span>]; <span class="comment">// [esp+34h] [ebp-20004h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">65536</span>]; <span class="comment">// [esp+10034h] [ebp-10004h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">272</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">273</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 == <span class="number">1001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(String, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">    GetDlgItemTextA(hDlg, <span class="number">1000</span>, String, <span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(String) == <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7[<span class="number">0</span>] = <span class="number">90</span>;</span><br><span class="line">      v7[<span class="number">1</span>] = <span class="number">74</span>;</span><br><span class="line">      v8 = <span class="number">83</span>;</span><br><span class="line">      v9 = <span class="number">69</span>;</span><br><span class="line">      v10 = <span class="number">67</span>;</span><br><span class="line">      v11 = <span class="number">97</span>;</span><br><span class="line">      v12 = <span class="number">78</span>;</span><br><span class="line">      v13 = <span class="number">72</span>;</span><br><span class="line">      v14 = <span class="number">51</span>;</span><br><span class="line">      v15 = <span class="number">110</span>;</span><br><span class="line">      v16 = <span class="number">103</span>;</span><br><span class="line">      sub_4010F0(v7, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">      <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v18[<span class="number">0</span>] = String[<span class="number">5</span>];</span><br><span class="line">      v18[<span class="number">2</span>] = String[<span class="number">7</span>];</span><br><span class="line">      v18[<span class="number">1</span>] = String[<span class="number">6</span>];</span><br><span class="line">      v4 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sub_401000(v18, <span class="built_in">strlen</span>(v18));</span><br><span class="line">      <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v18[<span class="number">1</span>] = String[<span class="number">3</span>];</span><br><span class="line">      v18[<span class="number">0</span>] = String[<span class="number">2</span>];</span><br><span class="line">      v18[<span class="number">2</span>] = String[<span class="number">4</span>];</span><br><span class="line">      v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sub_401000(v18, <span class="built_in">strlen</span>(v18));</span><br><span class="line">      <span class="keyword">if</span> ( String[<span class="number">0</span>] == v7[<span class="number">0</span>] + <span class="number">34</span></span><br><span class="line">        &amp;&amp; String[<span class="number">1</span>] == v10</span><br><span class="line">        &amp;&amp; <span class="number">4</span> * String[<span class="number">2</span>] - <span class="number">141</span> == <span class="number">3</span> * v8</span><br><span class="line">        &amp;&amp; String[<span class="number">3</span>] / <span class="number">4</span> == <span class="number">2</span> * (v13 / <span class="number">9</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;ak1w&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;V1Ax&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        MessageBoxA(hDlg, <span class="string">&quot;U g3t 1T!&quot;</span>, <span class="string">&quot;@_@&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 != <span class="number">1</span> &amp;&amp; (_WORD)a3 != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  EndDialog(hDlg, (<span class="keyword">unsigned</span> __int16)a3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(总结一下新学的函数：<br><strong>memset</strong>函数：<br>include &lt;string.h&gt;<br>void *memset(void *s, int c, unsigned long n);<br>初始化的万能函数，可以直接操作函数。可以将指针变量s指向的前n个字节的内存单元用一个整数c替换，这里指针是void类型，所以它几乎可以初始化任何数据。</p><p><strong>DialogBox</strong>函数：<br>是一个API函数，作用是从一个对话框资源中创建一个模态对话框。<br>hlnstance：标识一个模块的事例该模块的可执行文件含有对话框模板。<br>IpTemplate：标识对话框模板。此参数可以是指向一个以NULL结尾的字符串的指针，该字符串指定对话框模板名，或是指定对话框模板的资源标识符中的一个整型值。如果此参数指定了一个资源标识符则它的高位字一定为零，且低位字一定含有标识符。一定用MAKEINTRESOURDE宏指令创建此值。<br>hWndParent：指定拥有对话框的窗口。<br>IpDialogFunc：指向对话框过程的指针。有关更详细的关于对话框过程的信息,请参见DialogProc。</p><p><strong>GetDlgItemText函数</strong>：<br>该函数获取对话框中与控制有关的文本或标题。<br>参数：<br>hDlg：指向含有控制的对话框的句柄。<br>nlDDlgltem:指定标题或文本将被检索的控制的标识符。<br>IpString:指向获取标题或文本的缓冲器的指针。<br>nMaxCount：指定被复制到lpString参数指向的缓冲区的字符串的最大长度。如果字符串的字符最大长度超过范围，则该字符串被截断。<br>返回值：如果函数调用成功，则返回值表示被复制缓冲区的字符串的长度，不包括以NULL结尾的字符串。如果函数调用失败,则返回值为零。若想获得更多错误信息，请调用GetLastError函数。<br>备注: GetDlgltemText函数把一个WM_GETTEXT消息发送到控制。)</p><p>观察完这段代码后，我们可以得到如下信息：</p><ol><li>字符串长度可能为8</li><li>函数 sub_4010F0 与函数 sub_401000 可能改变了字符串，需要跟进去瞅一瞅。</li></ol><p> 先看一眼  sub_4010F0 函数<br>okk，接下来先进sub_4010F0看看，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_4010F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = a3;                                  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">for</span> ( i = a2; i &lt;= a3; a2 = i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">4</span> * i;</span><br><span class="line">    v6 = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt; result &amp;&amp; i &lt; result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; *(_DWORD *)(a1 + <span class="number">4</span> * result) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + <span class="number">4</span> * result);</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(_DWORD *)(a1 + <span class="number">4</span> * i) &lt;= v6 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ++i &gt;= result )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = <span class="number">4</span> * i;</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">4</span> * result) = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">        &#125;</span><br><span class="line">        --result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; result );</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4</span> * result) = v6;</span><br><span class="line">    sub_4010F0(a1, a2, i - <span class="number">1</span>);</span><br><span class="line">    result = a3;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实当我做到这里后，基本上就已经做不出来什么了，下面的解题步骤大部分还是参考的大佬的wp，由此可见一个优秀的逆向师傅基本功是一定要打好的，我这糟糕的编程能力还有狭窄的见识，唉，做题的同时也一定要打好基础！！！！！<br>继续干<br>我们将这一段代码执行以下<br><img src="https://img-blog.csdnimg.cn/20210618220453942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>好了，这个函数分析完了，回到dialogfunc函数继续往下看，进入sub_401000 函数里看一看。<br><img src="https://img-blog.csdnimg.cn/20210618233816390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开头分组 后面byte_407839这个数组，通过=号可以判断这个是base64加密，继续往下看，前面v7这个数组经过处理后为:3CEHJNSZagn，所以</p><p>if ( String == v7 + 34                   //String == ‘3’+34  即第一位为’U’<br>        &amp;&amp; v19 == v11                  //第二位为’J’<br>        &amp;&amp; 4 * v20 - 141 == 3 * v9 //第三位(‘E’*3+141)/4 即’W’<br>        &amp;&amp; v21 / 4 == 2 * (v14 / 9)//第四位为’P’<br>        &amp;&amp; !strcmp(v4, “ak1w”)      //V1Ax解码为WP1<br>        &amp;&amp; !strcmp(v5, “V1Ax”) )    //ak1w解码为jMp<br>可以拼得flag</p><p>flag<br>flag{UJWP1jMp}</p><p>总结：编程能力还得有待提升啊，否则一看到大片代码跪了qaq</p>]]></content>
      
      
      <categories>
          
          <category> ctf-re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUctf reverse 不一样的flag</title>
      <link href="2021/06/17/buuctf%20reverse%20%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/"/>
      <url>2021/06/17/buuctf%20reverse%20%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/</url>
      
        <content type="html"><![CDATA[<p>BUUctf reverse 不一样的flag</p><p>每天一到ctf，能多不能少</p><p>今天这道题感觉挺有意思的，题目<a href="https://blog.csdn.net/qq_42967398/article/details/96372054">链接</a></p><p><img src="https://img-blog.csdnimg.cn/20190717220237378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTY3Mzk4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>啊这，考眼力，天真的我直接跑到ida里面搜索字符串去了，搜索半天发现找不到，那么就只能分析一波代码了。</p><p><code>int __cdecl main(int argc, const char **argv, const char **envp)</code><br><code>&#123;</code><br>  <code>char v3; // [esp+17h] [ebp-35h]</code><br>  <code>int v4; // [esp+30h] [ebp-1Ch]</code><br>  <code>int v5; // [esp+34h] [ebp-18h]</code><br>  <code>signed int v6; // [esp+38h] [ebp-14h]</code><br>  <code>int i; // [esp+3Ch] [ebp-10h]</code><br>  <code>int v8; // [esp+40h] [ebp-Ch]</code></p><p>  <code>__main();   v4 = 0;   v5 = 0;   qmemcpy(&amp;v3, _data_start__, 0x19u);</code><br>  <code>while ( 1 )</code><br>  <code>&#123;</code><br>    <code>puts(&quot;you can choose one action to execute&quot;);</code><br>    <code>puts(&quot;1 up&quot;);</code><br>    <code>puts(&quot;2 down&quot;);</code><br>    <code>puts(&quot;3 left&quot;);</code><br>    <code>printf(&quot;4 right\n:&quot;);</code><br>    <code>scanf(&quot;%d&quot;, &amp;v6);</code><br>    <code>if ( v6 == 2 )</code><br>    <code>&#123;</code><br>      <code>++v4;</code><br>    <code>&#125;</code><br>    <code>else if ( v6 &gt; 2 )</code><br>    <code>&#123;</code><br>      <code>if ( v6 == 3 )</code><br>      <code>&#123;</code><br>        <code>--v5;</code><br>      <code>&#125;</code><br>      <code>else</code><br>      <code>&#123;</code><br>        <code>if ( v6 != 4 )</code><br><code>LABEL_13:</code><br>          <code>exit(1);</code><br>        <code>++v5;</code><br>      <code>&#125;</code><br>    <code>&#125;</code><br>    <code>else</code><br>    <code>&#123;</code><br>      <code>if ( v6 != 1 )</code><br>        <code>goto LABEL_13;</code><br>      <code>--v4;</code><br>    <code>&#125;</code><br>    <code>for ( i = 0; i &lt;= 1; ++i )</code><br>    <code>&#123;</code><br>      <code>if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</code><br>        <code>exit(1);</code><br>    <code>&#125;</code><br>    <code>if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == 49 )       exit(1);     if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == 35 )</code><br>    <code>&#123;</code><br>      <code>puts(&quot;\nok, the order you enter is the flag!&quot;);</code><br>      <code>exit(0);</code><br>    <code>&#125;</code><br>  <code>&#125;</code><br><code>&#125;</code><br>找到主要的部分</p><p> <code>if ( v6 != 1 )</code><br>        <code>goto LABEL_13;</code><br>      <code>--v4;</code><br>    <code>&#125;</code><br>    <code>for ( i = 0; i &lt;= 1; ++i )</code><br>    <code>&#123;</code><br>      <code>if ( *(&amp;v4 + i) &lt; 0 || *(&amp;v4 + i) &gt; 4 )</code><br>        <code>exit(1);</code><br>    <code>&#125;</code><br>    <code>if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == 49 )       exit(1);     if ( *((_BYTE *)&amp;v8 + 5 * v4 + v5 - 41) == 35 )</code></p><p>代码看完了以后，一脸懵逼，所以就先看了下面的if语句，看到了49,35？转换成字符看一下</p><p><img src="https://img-blog.csdnimg.cn/20190717220339226.png" alt="在这里插入图片描述"></p><p>还是不太懂，就去看了一下大佬写的wp，才发现这竟然是一道迷宫，纳闷就恍然大悟了，上面的if语句里的v4和v5分别代表着x轴和y轴，我们再看看13行的那个函数，打开以后发现了一串数字，大佬们直接将这个数字分成了五行，就组成了一个迷宫，至于为什么要分成五行，而不是四行，我也不懂，可能是刚好能被5整除组成5X5的迷宫吧，字符串时这个样子的   *11110100001010000101111#，转成迷宫就是这个样子的：</p><p>* 1 1 1 1</p><p>0 1 0 0 0</p><p>0 1 0 1 0</p><p>0 0 0 1 0</p><p>1 1 1 1 #</p><p>按照下面的if语句，可以得出当值等于1的时候就退出，当值等于#的时候就成功钻出了迷宫，再结合前面分析过的if语句，可以得出我们应该这么走</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210617183430724.png" alt="image-20210617183430724"></p><p>转换成走迷宫的指令就是</p><p>222441144222</p><p>走出迷宫，得到flag：222441144222</p>]]></content>
      
      
      <categories>
          
          <category> ctf-re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十七 重定位表</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9317/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9317/</url>
      
        <content type="html"><![CDATA[<p>前面在<a href="https://www.52pojie.cn/thread-1413789-1-1.html">PE文件笔记十六 代码重定位</a>中学习了代码重定位，接着学习重定位表</p><hr><h1 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h1><h2 id="重定位表的作用"><a href="#重定位表的作用" class="headerlink" title="重定位表的作用"></a>重定位表的作用</h2><p>经过前面对导入表和导出表的学习，知道了一个程序运行时一般需要加载多个PE文件</p><p>而每个PE文件在内存中的首地址由扩展PE头中的ImageBase决定；当前面的PE文件<strong>占用</strong>了后面PE文件在内存中位置时，允许后面PE文件<strong>重新选择</strong>一个基地址。这时候就需要对所有的重定位信息进行修正，而<strong>修正的依据</strong>就是PE中的<strong>重定位表</strong></p><p>操作系统会<strong>根据重定位表</strong>对代码予以纠正，使得代码位置移动后仍然能够正确地运行；也就是<strong>代码重定位</strong>的工作由操作系统来完成</p><hr><h2 id="什么是重定位表"><a href="#什么是重定位表" class="headerlink" title="什么是重定位表"></a>什么是重定位表</h2><p>重定位表就是记录<strong>代码位置移动后</strong>修正重定位信息所需要的一种结构</p><p>PS：也就是说当代码位置没有发生移动时，是用不到重定位表的</p><hr><h2 id="定位重定位表"><a href="#定位重定位表" class="headerlink" title="定位重定位表"></a>定位重定位表</h2><h3 id="定位重定位表原理"><a href="#定位重定位表原理" class="headerlink" title="定位重定位表原理"></a>定位重定位表原理</h3><p>像导入表、导出表、重定位表、资源表等表，这些表的起始地址和大小都存储在扩展PE头里的DataDirectory这个数组的成员中，DataDirectory是一个数组，每个数组成员对应一张表</p><p>回顾先前的笔记<a href="https://www.52pojie.cn/thread-1405930-1-1.html#37759493_datadirectory">PE文件笔记五 PE文件头之扩展PE头</a>，能得到重定位表对应的下标为5</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td><td align="left">5</td><td align="left">基地址重定位表</td></tr></tbody></table><p>即DataDirectory[5]表示重定位表</p><p>关于DataDirectory的具体描述在之前的笔记中已经详细说明过了，这里不再赘述：</p><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">DWORD(4字节)</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">DWORD(4字节)</td><td align="left">表的大小</td></tr></tbody></table><hr><h3 id="定位重定位表流程"><a href="#定位重定位表流程" class="headerlink" title="定位重定位表流程"></a>定位重定位表流程</h3><ol><li>找到扩展PE头的最后一个成员DataDirectory</li><li>获取DataDirectory[5]</li><li>通过DataDirectory[5].VirtualAddress得到导入表的RVA</li><li>将导出表的RVA转换为FOA，在文件中定位到导入表</li></ol><hr><h2 id="按流程定位重定位表"><a href="#按流程定位重定位表" class="headerlink" title="按流程定位重定位表"></a>按流程定位重定位表</h2><h3 id="要分析的实例"><a href="#要分析的实例" class="headerlink" title="要分析的实例"></a>要分析的实例</h3><p>这次分析的实例还是先前的EverEdit.exe</p><p>程序在后面的附件中，有需要可以自行取用</p><hr><h3 id="找到DataDirectory"><a href="#找到DataDirectory" class="headerlink" title="找到DataDirectory"></a>找到DataDirectory</h3><p>使用WinHex打开EverEdit.exe，先找到PE文件头的起始地址：0xF0</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408115132092.png" alt="image-20210408115132092"></p><hr><p>再数24个字节（PE文件头标志大小+标准PE头大小），到达扩展PE头：0xF0+24=240+24=264=0x108</p><p>然后在数224-128=96个字节（扩展PE头大小减去DataDirectory大小）DataDirectory大小= _IMAGE_DATA_DIRECTORY大小×16=8*16</p><p>DataDirectory首地址 = 扩展PE头地址+96=0x108+96=264+96=360=0x168</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410110128746.png" alt="image-20210410110128746"></p><hr><h3 id="获取DataDirectory-5"><a href="#获取DataDirectory-5" class="headerlink" title="获取DataDirectory[5]"></a>获取DataDirectory[5]</h3><p>而重定位表为DataDirectory[5]</p><p>重定位表地址 = DataDirectory首地址 + sizeof(IMAGE_DATA_DIRECTORY)×5=0x168+8×5=360+40=400=0x190</p><p>DataDirectory[5].VirtualAddress</p><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">0x00281000</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">0x00015B68</td><td align="left">表的大小</td></tr></tbody></table><hr><h3 id="得到重定位表的RVA"><a href="#得到重定位表的RVA" class="headerlink" title="得到重定位表的RVA"></a>得到重定位表的RVA</h3><p>于是得到导出表对应的RVA为：0x281000</p><hr><h3 id="RVA转换FOA"><a href="#RVA转换FOA" class="headerlink" title="RVA转换FOA"></a>RVA转换FOA</h3><p>但是IMAGE_DATA_DIRECTORY中的VirtualAddress是RVA，需要将其转换成FOA</p><p>关于RVA转FOA的内容在<a href="https://www.52pojie.cn/thread-1408576-1-1.html"> PE文件笔记七 VA与FOA转换</a>中已经详细说明了，这里不再赘述</p><p>此时使用PE工具：DIE来进行RVA和FOA的转换，没有使用自己所写的工具</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410110646553.png" alt="image-20210410110646553"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410111127733.png" alt="image-20210410111127733"></p><p>获得了FOA为0x241c00，也就是重定位表的位置了，定位完成</p><hr><h2 id="重定位表的结构"><a href="#重定位表的结构" class="headerlink" title="重定位表的结构"></a>重定位表的结构</h2><p>定位到了重定位表后自然要了解重定位表的结构才能解读重定位表的内容</p><p>与导入表类似，重定位表指针指向的位置是一个数组，而不像导出表一样只有一个结构。这个数组的每一项都是如下结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_BASE_RELOCATION &#123;</span><br><span class="line">    DWORD   VirtualAddress;                //重定位内存页的起始RVA</span><br><span class="line">    DWORD   SizeOfBlock;                //重定位块的长度</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410113358120.png" alt="image-20210410113358120"></p><hr><h3 id="重定位表的划分"><a href="#重定位表的划分" class="headerlink" title="重定位表的划分"></a>重定位表的划分</h3><p>可以看到，<strong>重定位表被分为一个个重定位块</strong></p><p>每个重定位块的大小由SizeOfBlock决定，<strong>重定位块大小 = SizeOfBlock</strong></p><p><strong>为什么重定位表要被分为一个个重定位块？</strong></p><p>答：为了<strong>节省空间</strong></p><hr><p>举个例子：</p><p>假设有一堆数据：</p><p>0x0080 0610</p><p>0x8006 5000</p><p>0x0080 0520</p><p>0x0080 5210</p><p>……</p><hr><p>这些数据都是0x0080XXXX的格式，假设数据共有N个</p><p>如果按照正常的存储方式，需要N×4 = 4N个字节的空间才能存储下</p><p>如果按照基地址+偏移的方式来存储：</p><p>即先存储一个基地址：0x0080 0000 （DWORD 4字节）</p><p>之后存储的数据只需要存储偏移即可：</p><p>0x0080 0610 → 0x0610     (WORD 2字节)</p><p>0x8006 5000 → 0x5000     (WORD 2字节)</p><p>0x0080 0520 → 0x0520     (WORD 2字节)</p><p>0x0080 5210 → 0x5210     (WORD 2字节)</p><p>……                      → …… - 0x00800000     (WORD 2字节)</p><hr><p>此时所需要的空间为：4(基地址占用的空间) + 2×N = 2N+4个字节的空间</p><p>对比先前的所需要的空间4N，不难发现，当数据量足够庞大的时候，节省的空间能够接近一半</p><hr><p>通过上面的例子，再来理解_IMAGE_BASE_RELOCATION这个结构体</p><table><thead><tr><th align="left">_IMAGE_BASE_RELOCATION成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">DWORD(4字节)</td><td align="left">数据的基地址的RVA</td></tr><tr><td align="left">SizeOfBlock</td><td align="left">DWORD(4字节)</td><td align="left">重定位块的总大小</td></tr></tbody></table><hr><h3 id="重定位表块是如何设计的"><a href="#重定位表块是如何设计的" class="headerlink" title="重定位表块是如何设计的"></a>重定位表块是如何设计的</h3><p>前面知道了重定位表被划分成一块块重定位块以达到节省空间的目的</p><p>那么<strong>重定位表块是如何设计的？一共有多少个重定位表块？</strong></p><p>重定位表块是根据<strong>物理内存</strong>来设计的</p><p>内存是<strong>以4KB为单位</strong>的，也就是在物理内存上每一个内存的大小划分是4KB，以4KB为一个物理页（这里涉及后面的<strong>内存分页</strong>的知识）</p><p><strong>一个重定位表块对应一个物理页</strong></p><hr><h3 id="重定位表块中的数据项-偏移"><a href="#重定位表块中的数据项-偏移" class="headerlink" title="重定位表块中的数据项(偏移)"></a>重定位表块中的数据项(偏移)</h3><p>前面知道了，重定位表块中SizeOfBlock后的数据部分是作为偏移来使用的，<strong>每一个数据项的大小为(WORD)2字节</strong></p><p>实际上数据项只有<strong>后12位是用来表示偏移</strong>的，<strong>高4位留作它用</strong></p><p>比如：对于一个数据项为：<strong>0011</strong> 0110 0001 0000 共16位(2字节)</p><p>其偏移的数值为：0110 0001 0000 = 0x610</p><hr><p>先说说<strong>为什么只需要拿12位作为偏移便足矣？</strong></p><p>前面提到了物理页的大小是4KB，4KB = 2的12次方 B</p><p>也就是说，在一个物理页内的偏移最大也就是4KB = 2的12次方 B</p><p>于是<strong>只需要使用12位就表示一个物理页内的所有偏移</strong></p><hr><p>了解了为什么只需要12位作为偏移后，再来看看<strong>高4位的作用</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410132326879.png" alt="image-20210410132326879"></p><hr><p>在实际的PE文件中，我们<strong>只能看到0和3这两种情况</strong>（对应二进制为：0000 和 0011），也就是说这一项要么是对齐用的，要么是需要全部修正的</p><p><strong>对于为0的情况</strong>，表明该数据为<strong>对齐</strong>用的填充的<strong>垃圾数据</strong>，所以<strong>不需要对其进行重定位</strong></p><hr><h3 id="重定位表的结尾"><a href="#重定位表的结尾" class="headerlink" title="重定位表的结尾"></a>重定位表的结尾</h3><p>重定位表的结尾为：找到一项_IMAGE_BASE_RELOCATION，其成员的值均为0</p><hr><h2 id="按结构分析重定位表"><a href="#按结构分析重定位表" class="headerlink" title="按结构分析重定位表"></a>按结构分析重定位表</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410133418314.png" alt="image-20210410133418314"></p><hr><p>选中部分为<strong>第一个重定位块</strong>，以它为例进行分析</p><p>将对应的结构填入结构体成员中得到：</p><table><thead><tr><th align="left">_IMAGE_BASE_RELOCATION成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">0x00001000</td><td align="left">数据的基地址的RVA</td></tr><tr><td align="left">SizeOfBlock</td><td align="left">0x00000084</td><td align="left">重定位块的总大小=以VirtualAddress为基地址的数据的个数×2+8</td></tr></tbody></table><hr><p>于是得到了：</p><p>第一个重定位块的基地址的RVA为：0x1000，将其转换成FOA得到：0x400（转换方法说了很多次了，这里不再赘述）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410134516621.png" alt="image-20210410134516621"></p><hr><p>接着再根据SizeOfBlock算出以VirtualAddress为基地址的数据的个数</p><p>个数 = (SizeOfBlock-8)÷2 = (0x84-8)÷2 =(132-8)÷2=124÷2=62个</p><hr><p>接下来看需要修正的第一个数据的偏移为：0x3010</p><p>先将其转换为二进制得到：0011 0000 0001 0000</p><p><strong>高四位</strong>为3，表明该数据有效并且需要对它进行重定位</p><p><strong>低四位</strong>为：0x10，表明该数据的偏移为0x10</p><p>最后用基地址+偏移得到 <strong>完整的地址</strong>为：0x400 + 0x10 =0x410</p><p>用WinHex到0x410的位置查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410135100192.png" alt="image-20210410135100192"></p><p>不难看出该地址存储的数据是一个VA(虚拟地址)，也就是一个<strong>绝对地址</strong>，所以需要修正</p><hr><h1 id="代码实现分析重定位表"><a href="#代码实现分析重定位表" class="headerlink" title="代码实现分析重定位表"></a>代码实现分析重定位表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">        UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        //输出rva</span><br><span class="line">        //printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">        //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">        UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">        //输出PeEnd</span><br><span class="line">        //printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">        //判断rva是否位于PE文件头中</span><br><span class="line">        if (rva &lt; PeEnd) &#123;</span><br><span class="line">                //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">                //printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">                return rva;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                //如果rva在PE文件头外</span><br><span class="line">                //判断rva属于哪个节</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">                        //计算内存对齐后节的大小</span><br><span class="line">                        UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">                        if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                                //找到所属的节</span><br><span class="line">                                //输出内存对齐后的节的大小</span><br><span class="line">                                //printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //未找到</span><br><span class="line">                        printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">                        UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">                        //FOA = 节.PointerToRawData + 差值</span><br><span class="line">                        UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">                        //printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">                        return foa;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void getBaseRelocation(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        _IMAGE_DATA_DIRECTORY relocateDataDirectory = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">        UINT relocateAddress = VaToFoa32(relocateDataDirectory.VirtualAddress + nt-&gt;OptionalHeader.ImageBase, dos, nt, sectionArr);</span><br><span class="line">        _IMAGE_BASE_RELOCATION* relocateDirectory = (_IMAGE_BASE_RELOCATION*)((UINT)dos + relocateAddress);</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">                //判断是否到达结尾</span><br><span class="line">                if (relocateDirectory-&gt;VirtualAddress != 0 &amp;&amp; relocateDirectory-&gt;SizeOfBlock != 0) &#123;</span><br><span class="line">                        int num = (relocateDirectory-&gt;SizeOfBlock - 8) / 2;</span><br><span class="line">                        int i;</span><br><span class="line">                        for (i = 0; i &lt; num-1; i++) &#123;</span><br><span class="line">                                WORD* offset = (WORD*)((UINT)relocateDirectory+8+2*i);</span><br><span class="line">                                //高四位为0011即3</span><br><span class="line">                                if (*offset &gt;= 0x3000) &#123;</span><br><span class="line">                                        printf(&quot;base:%X\toffset:%X\n&quot;, relocateDirectory-&gt;VirtualAddress, *offset-0x3000);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        relocateDirectory =(_IMAGE_BASE_RELOCATION*) ((UINT)relocateDirectory + relocateDirectory-&gt;SizeOfBlock);</span><br><span class="line">                        cnt++;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, cnt);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getBaseRelocation(dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210410151737152.png" alt="image-20210410151737152"></p><hr><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>解析重定位表的代码并不多，主要在于掌握了结构之后知道其边界和数据含义，就可以通过指针找到对应位置输出即可</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>重定位表只有在<strong>代码的位置发生移动</strong>时才有效</li><li>重定位表是为了<strong>解决代码重定位</strong>的问题而设计的，而重定位表块则是为了<strong>节省空间</strong>而设计的</li><li>重定位表块的划分原理在于<strong>内存分页</strong></li></ul><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1414556-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十六 代码重定位</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9316/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9316/</url>
      
        <content type="html"><![CDATA[<p>前面在<a href="https://www.52pojie.cn/thread-1413220-1-1.html">PE文件笔记十五 导入表</a>中学习了导入表，接着要学习重定位表，但在学习重定位表前，要先了解一下代码重定位</p><h1 id="代码重定位"><a href="#代码重定位" class="headerlink" title="代码重定位"></a>代码重定位</h1><p>在学习重定位表之前，要知道什么是代码重定位</p><h2 id="代码重定位定义"><a href="#代码重定位定义" class="headerlink" title="代码重定位定义"></a>代码重定位定义</h2><p>代码重定位是把可执行代码从内存的一个地方<strong>移动</strong>到另外一个地方去，<strong>保证该部分代码还能正常执行</strong></p><h2 id="重定位的提出"><a href="#重定位的提出" class="headerlink" title="重定位的提出"></a>重定位的提出</h2><p>可执行代码从内存的一个地方<strong>移动</strong>到另外一个地方，所有的<strong>字节码(硬编码)均保持不变</strong>；如果代码指令中的某些操作数不<strong>跟着地址发生改变</strong>，势必会导致程序运行出错。这里的某些操作数是指那些使用了<strong>绝对地址</strong>定位的程序指令中的操作数</p><p>为更好地学习重定位，结合下面的实例分析：</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        int result=0;</span><br><span class="line">        _asm&#123;</span><br><span class="line">_code:</span><br><span class="line">                xor eax,eax</span><br><span class="line">                mov al,byte ptr ds:[_data]</span><br><span class="line">                jmp _end</span><br><span class="line">_data:</span><br><span class="line">                _emit 0x61</span><br><span class="line">_end:</span><br><span class="line">                mov result,eax</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%X\n&quot;,result);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>上面的代码十分简短简单，主要看汇编的代码</p><p>汇编代码分为三段：代码段_code、数据段_data、结束段_end</p><hr><h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>代码段就是取出数据段的数据，然后保存到寄存器eax</p><hr><h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>数据段只存储了一个数据0x61</p><hr><h4 id="结束段"><a href="#结束段" class="headerlink" title="结束段"></a>结束段</h4><p>将先前保存到寄存器eax中的数据赋值给变量result</p><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409135527504.png" alt="image-20210409135527504"></p><p>可以看到，代码能够正常地取出数据区的内容并打印出来</p><hr><h3 id="反汇编对应的硬编码"><a href="#反汇编对应的硬编码" class="headerlink" title="反汇编对应的硬编码"></a>反汇编对应的硬编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码5:        _asm&#123;</span><br><span class="line">6:    _code:</span><br><span class="line">7:            xor eax,eax</span><br><span class="line">0040D73F 33 C0                xor         eax,eax</span><br><span class="line">8:            mov al,byte ptr ds:[_data]</span><br><span class="line">0040D741 3E A0 49 D7 40 00    mov         al,ds:[_data (0040d749)]</span><br><span class="line">9:            jmp _end</span><br><span class="line">0040D747 EB 01                jmp         _end (0040d74a)</span><br><span class="line">10:   _data:</span><br><span class="line">11:           _emit 0x61</span><br><span class="line">0040D749 61                   db 61h</span><br><span class="line">12:   _end:</span><br><span class="line">13:           mov result,eax</span><br><span class="line">0040D74A 89 45 FC             mov         dword ptr [ebp-4],eax</span><br><span class="line">14:       &#125;</span><br></pre></td></tr></table></figure><hr><p>这里关注一下出现地址的两个地方的硬编码：</p><h4 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码8:            mov al,byte ptr ds:[_data]</span><br><span class="line">0040D741 3E A0 49 D7 40 00    mov         al,ds:[_data (0040d749)]</span><br></pre></td></tr></table></figure><p>取出0040d749地址对应的数据，取出的数据宽度为一个字节，然后赋值给al（eax的低8位）</p><p>可以看到这里的硬编码直接就是写死的地址0040d749（49 D7 40 00 小端存储），为<strong>绝对地址</strong></p><hr><h4 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码9:            jmp _end</span><br><span class="line">0040D747 EB 01                jmp         _end (0040d74a)</span><br></pre></td></tr></table></figure><p>这里的jmp跳转则是采用偏移的方式，其偏移为01（前面的EB 表示jmp）</p><p>要跳转的地址 = 当前地址 + 当前指令长度 + 偏移 = 0040D747 + 2 + 1 = 0040D74A</p><p>第二处的代码则是采用了<strong>相对地址</strong>的方法进行寻址</p><hr><h2 id="没重定位带来的问题"><a href="#没重定位带来的问题" class="headerlink" title="没重定位带来的问题"></a>没重定位带来的问题</h2><p>前面的代码中存在绝对地址，因此如果将代码移到别的地方必然导致结果错误</p><p>于是为了验证这一点，进行以下的演示：</p><p>首先复制其对应的硬编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">33 C0 3E A0 49 D7 40 00 EB 01 61 89 45 FC</span><br></pre></td></tr></table></figure><hr><p>然后用OD随便打开一个程序</p><p>随便选中一行代码，然后 右键→二进制→编辑（或使用快捷键Ctrl+E）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409141350198.png" alt="image-20210409141350198"></p><hr><p>在弹出来的编辑窗口中，取消勾选保持大小，然后将硬编码粘贴进去</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409141728724.png" alt="image-20210409141728724"></p><hr><p>得到结果：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409141956125.png" alt="image-20210409141956125"></p><hr><p>可以看到，此时采用相对地址的jmp指令后面跳转的地址发生了变化，依然能够跳转到我们想要的位置</p><p>但是mov指令由于采取了绝对地址，它去取的地址仍然是先前的地址，没有对应去取下面的数据：0x61</p><p>也因此导致了，代码位置变化以后，其运行的结果就不正确了</p><hr><h2 id="修正重定位"><a href="#修正重定位" class="headerlink" title="修正重定位"></a>修正重定位</h2><p>通过前面，可以知道，代码出错的原因在于mov指令后面采用了绝对地址</p><p>于是将mov 指令后面的地址改为相对地址即可</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        int result=0;</span><br><span class="line">        _asm&#123;</span><br><span class="line">_code:</span><br><span class="line">                call _call</span><br><span class="line">                xor ebx,ebx                </span><br><span class="line">                mov bl,byte ptr ds:[eax+8]</span><br><span class="line">                jmp _end</span><br><span class="line">_data:</span><br><span class="line">                _emit 0x61</span><br><span class="line">_call:</span><br><span class="line">                mov eax,dword ptr ss:[esp]</span><br><span class="line">                ret</span><br><span class="line">_end:</span><br><span class="line">                mov result,ebx</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%X\n&quot;,result);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="代码说明-1"><a href="#代码说明-1" class="headerlink" title="代码说明"></a>代码说明</h3><p>代码中多了一个_call段，该段用来调用call，根据堆栈的特性，获得的[esp]里存储的地址为xor ebx,ebx这一行指令的地址</p><p>不了解为什么在call里面可以通过这种方法获取到返回地址的可以回顾：<a href="https://www.52pojie.cn/thread-1379952-1-1.html">逆向基础笔记七 堆栈图（重点）</a></p><p>获取到地址后将地址保存到eax中</p><p>之后返回以后通过xor ebx,ebx这一行的地址+偏移8得到_data的地址，此时采用的便是相对地址的方式</p><h3 id="修正后对应的硬编码"><a href="#修正后对应的硬编码" class="headerlink" title="修正后对应的硬编码"></a>修正后对应的硬编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码5:        _asm&#123;</span><br><span class="line">6:    _code:</span><br><span class="line">7:            call _call</span><br><span class="line">0040D73F E8 09 00 00 00       call        _call (0040d74d)</span><br><span class="line">8:            xor ebx,ebx</span><br><span class="line">0040D744 33 DB                xor         ebx,ebx</span><br><span class="line">9:            mov bl,byte ptr ds:[eax+8]</span><br><span class="line">0040D746 3E 8A 58 08          mov         bl,byte ptr ds:[eax+8]</span><br><span class="line">10:           jmp _end</span><br><span class="line">0040D74A EB 06                jmp         _end (0040d752)</span><br><span class="line">11:   _data:</span><br><span class="line">12:           _emit 0x61</span><br><span class="line">0040D74C 61                   popad</span><br><span class="line">13:   _call:</span><br><span class="line">14:           mov eax,dword ptr ss:[esp]</span><br><span class="line">0040D74D 36 8B 04 24          mov         eax,dword ptr ss:[esp]</span><br><span class="line">15:           ret</span><br><span class="line">0040D751 C3                   ret</span><br><span class="line">16:   _end:</span><br><span class="line">17:           mov result,ebx</span><br><span class="line">0040D752 89 5D FC             mov         dword ptr [ebp-4],ebx</span><br><span class="line">18:       &#125;</span><br></pre></td></tr></table></figure><hr><p>这里关注一下出现地址的地方的硬编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码7:            call _call</span><br><span class="line">0040D73F E8 09 00 00 00       call        _call (0040d74d)</span><br></pre></td></tr></table></figure><p>这里的call调用采用偏移的方式，其偏移为09（前面的E8 表示call）</p><p>要跳转的地址 = 当前地址 + 当前指令长度 + 偏移 = 0040D73F + 5 + 9 = 0040D74D</p><p>于是此时的代码就全部是采用相对地址了，此时代码就支持重定位了</p><h2 id="测试重定位后的硬编码"><a href="#测试重定位后的硬编码" class="headerlink" title="测试重定位后的硬编码"></a>测试重定位后的硬编码</h2><p>依旧要先将重定位的硬编码复制出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">E8 09 00 00 00 33 DB 3E 8A 58 08 EB 06 61 36 8B 04 24 C3 89 5D FC</span><br></pre></td></tr></table></figure><hr><p>然后用OD随便打开一个程序</p><p>随便选中一行代码，然后 右键→二进制→编辑（或使用快捷键Ctrl+E）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409141350198.png" alt="image-20210409141350198"></p><hr><p>在弹出来的编辑窗口中，取消勾选保持大小，然后将硬编码粘贴进去</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409145959047.png" alt="image-20210409145959047"></p><hr><p>得到结果：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409150032097.png" alt="image-20210409150032097"></p><p>可以看到采用了相对地址后，移动完代码的位置其代码依然满足我们的需求</p><hr><p>F8单步步过到最后一行代码，查看ebx此时的值</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210409150346087.png" alt="image-20210409150346087"></p><p>可以看到此时的ebx能够正确地获取到数据区的内容( •̀ ω •́ )✧</p><hr><h2 id="采用重定位技术的好处"><a href="#采用重定位技术的好处" class="headerlink" title="采用重定位技术的好处"></a>采用重定位技术的好处</h2><p>从上面的例子中，不难的得出采用重定位技术的好处：</p><p>如果在代码编写中使用重定位技术，你就可以<strong>将代码随意地部署到内存中，而不影响程序的运行</strong></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>采用重定位技术，可以让代码段在<strong>任意</strong>内存中运行</li><li>重定位技术的核心就在：<strong>不使用绝对地址，而使用相对地址</strong></li><li>使用的是绝对地址还是相对地址，归根结底取决于其<strong>对应的硬编码</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十五 导入表</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9315/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9315/</url>
      
        <content type="html"><![CDATA[<p>前面在<a href="https://www.52pojie.cn/thread-1412395-1-1.html">PE文件笔记十四 导出表</a>学习了导出表，接着学习导入表</p><h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><h2 id="导入表作用"><a href="#导入表作用" class="headerlink" title="导入表作用"></a>导入表作用</h2><p>当程序<strong>运行时</strong>，需要<strong>多个</strong>PE文件共同组成</p><p>PE文件提供哪些功能→导出表</p><p>PE文件需要依赖的模块以及依赖这些模块中的哪些函数→导入表</p><hr><h2 id="什么是导入表"><a href="#什么是导入表" class="headerlink" title="什么是导入表"></a>什么是导入表</h2><p>导入表就是记录该PE文件还需要依赖的模块以及依赖这些模块中的哪些函数的一种结构</p><hr><h2 id="定位导入表"><a href="#定位导入表" class="headerlink" title="定位导入表"></a>定位导入表</h2><h3 id="定位导入表原理"><a href="#定位导入表原理" class="headerlink" title="定位导入表原理"></a>定位导入表原理</h3><p>在上一个笔记：<a href="https://www.52pojie.cn/thread-1412395-1-1.html">PE文件笔记十四 导出表</a>中以及提到了，像导入表、导出表、重定位表、资源表等表，这些表的起始地址和大小都存储在扩展PE头里的DataDirectory这个数组的成员中，DataDirectory是一个数组，每个数组成员对应一张表</p><p>回顾先前的笔记，能得到导入表对应的下标为1</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td><td align="left">1</td><td align="left">导入表</td></tr></tbody></table><p>即DataDirectory[1]表示导入表</p><p>关于DataDirectory的具体描述在上一个笔记中已经详细说明过了，这里不再赘述：</p><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">DWORD(4字节)</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">DWORD(4字节)</td><td align="left">表的大小</td></tr></tbody></table><hr><h3 id="定位导入表流程"><a href="#定位导入表流程" class="headerlink" title="定位导入表流程"></a>定位导入表流程</h3><ol><li>找到扩展PE头的最后一个成员DataDirectory</li><li>获取DataDirectory[1]</li><li>通过DataDirectory[1].VirtualAddress得到导入表的RVA</li><li>将导出表的RVA转换为FOA，在文件中定位到导入表</li></ol><hr><h2 id="按流程定位导入表"><a href="#按流程定位导入表" class="headerlink" title="按流程定位导入表"></a>按流程定位导入表</h2><h3 id="要分析的实例"><a href="#要分析的实例" class="headerlink" title="要分析的实例"></a>要分析的实例</h3><p>这次要分析的实例又回归到先前的EverEdit.exe了</p><p>程序在后面的附件中，有需要可以自行取用</p><hr><h3 id="找到DataDirectory"><a href="#找到DataDirectory" class="headerlink" title="找到DataDirectory"></a>找到DataDirectory</h3><p>使用WinHex打开EverEdit.exe，先找到PE文件头的起始地址：0xF0</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408115132092.png" alt="image-20210408115132092"></p><hr><p>再数24个字节（PE文件头标志大小+标准PE头大小），到达扩展PE头：0xF0+24=240+24=264=0x108</p><p>然后在数224-128=96个字节（扩展PE头大小减去DataDirectory大小）DataDirectory大小= _IMAGE_DATA_DIRECTORY大小×16=8*16</p><p>DataDirectory首地址 = 扩展PE头地址+96=0x108+96=264+96=360=0x168</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408115736939.png" alt="image-20210408115736939"></p><hr><h3 id="获取DataDirectory-1"><a href="#获取DataDirectory-1" class="headerlink" title="获取DataDirectory[1]"></a>获取DataDirectory[1]</h3><p>而导入表为DataDirectory[1]，也就是从首地址开始的DataDirectory[0]的偏移之后的8个字节就是描述导入表的IMAGE_DATA_DIRECTORY</p><p>导入表地址 = DataDirectory首地址 + sizeof(IMAGE_DATA_DIRECTORY)=0x168+8=360+8=368=0x170</p><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">0x001CF47C</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">0x00000140</td><td align="left">表的大小</td></tr></tbody></table><hr><h3 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h3><p>于是得到导出表对应的RVA为：0x1CF47C</p><hr><h3 id="RVA转换FOA"><a href="#RVA转换FOA" class="headerlink" title="RVA转换FOA"></a>RVA转换FOA</h3><p>但是IMAGE_DATA_DIRECTORY中的VirtualAddress是RVA，需要将其转换成FOA</p><p>关于RVA转FOA的内容在<a href="https://www.52pojie.cn/thread-1408576-1-1.html"> PE文件笔记七 VA与FOA转换</a>中已经详细说明了，这里不再赘述</p><p>直接使用在笔记七中写的转换代码计算出对应的FOA：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">        UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        //输出rva</span><br><span class="line">        printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">        //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">        UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">        //输出PeEnd</span><br><span class="line">        printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">        //判断rva是否位于PE文件头中</span><br><span class="line">        if (rva &lt; PeEnd) &#123;</span><br><span class="line">                //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">                printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">                return rva;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                //如果rva在PE文件头外</span><br><span class="line">                //判断rva属于哪个节</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">                        //计算内存对齐后节的大小</span><br><span class="line">                        UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">                        if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                                //找到所属的节</span><br><span class="line">                                //输出内存对齐后的节的大小</span><br><span class="line">                                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //未找到</span><br><span class="line">                        printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">                        UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">                        //FOA = 节.PointerToRawData + 差值</span><br><span class="line">                        UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">                        printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">                        return foa;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Documents and Settings\\Administrator\\桌面\\user32.dll&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x1CF47C,dos,nt,sectionArr);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键代码:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x1CF47C,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><p>因为先前写的函数是VA转FOA，这里得到的是RVA，于是要先用RVA+ImageBase得到VA</p><p>运行代码得到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408122153869.png" alt="image-20210408122153869"></p><p>获得了FOA为0x1CDA7C，也就是导入表的位置了，定位完成</p><hr><h2 id="导入表的结构"><a href="#导入表的结构" class="headerlink" title="导入表的结构"></a>导入表的结构</h2><p>定位到了导入表后自然要了解导入表的结构才能解读导入表的内容</p><h3 id="导入表的个数"><a href="#导入表的个数" class="headerlink" title="导入表的个数"></a>导入表的个数</h3><p>与导出表不同，导入表通常要包含多个模块，而不像导出表只需要提供本PE文件需要提供的导出函数即可</p><p>因此，导出表只有一个，但<strong>导入表则可能有多个</strong></p><p>当程序<strong>运行时</strong>，需要依赖几个模块，就对应有几张导入表</p><hr><h3 id="导入表的结构体"><a href="#导入表的结构体" class="headerlink" title="导入表的结构体"></a>导入表的结构体</h3><p>给出导入表在C语言中的结构体（在winnt.h中可以找到）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408124452121.png" alt="image-20210408124452121"></p><hr><p>即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;            // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;                  // 0 if not bound,</span><br><span class="line">                                            // -1 if bound, and real date\time stamp</span><br><span class="line">                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span><br><span class="line">                                            // O.W. date/time stamp of DLL bound to (Old BIND)</span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 // -1 if no forwarders</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><hr><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Characteristics</td><td align="left">DWORD(4字节)</td><td align="left">标志 为0表示结束 没有导入描述符了</td></tr><tr><td align="left">OriginalFirstThunk</td><td align="left">DWORD(4字节)</td><td align="left">RVA指向IMAGE_THUNK_DATA结构数组（桥1）</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">DWORD(4字节)</td><td align="left">时间戳</td></tr><tr><td align="left">ForwarderChain</td><td align="left">DWORD(4字节)</td><td align="left">链表的前一个结构</td></tr><tr><td align="left">Name</td><td align="left">DWORD(4字节)</td><td align="left">RVA，指向DLL名字，该名字以’’\0’’结尾</td></tr><tr><td align="left">FirstThunk</td><td align="left">DWORD(4字节)</td><td align="left">RVA指向IMAGE_THUNK_DATA结构数组（桥2）</td></tr></tbody></table><hr><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>标志 为0表示结束 没有导入描述符了</p><hr><h4 id="IMAGE-THUNK-DATA"><a href="#IMAGE-THUNK-DATA" class="headerlink" title="IMAGE_THUNK_DATA"></a>IMAGE_THUNK_DATA</h4><p>在介绍OriginalFirstThunk之前，要先了解一下OriginalFirstThunk和FirstThunk所指向的<strong>结构数组</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408141537209.png" alt="image-20210408141537209"></p><hr><p>指向的数组中每一项为一个结构，此结构名称是<strong>IMAGE_THUNK_DATA</strong></p><p>数组<strong>最后以一个内容全为0的IMAGE_THUNK_DATA作为结束</strong></p><p>IMAGE_THUNK_DATA实际上只是一个DWORD，但在不同的时刻却拥有不同的解释</p><p>IMAGE_THUNK_DATA有<strong>两种解释</strong>：</p><ul><li>DWORD最高位为0，那么该数值是一个RVA，指向_IMAGE_IMPORT_BY_NAME结构，表明函数是<strong>以字符串类型的函数名导入</strong>的</li><li>DWORD最高位为1，那么该数值的低31位就是函数的<strong>导出函数的序号</strong></li></ul><hr><p>_IMAGE_IMPORT_BY_NAME结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_IMPORT_BY_NAME &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    BYTE    Name[1];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>该结构即为：”编号—名称”（Hint/Name）描述部分</p><ul><li>Hint：导出函数地址表的<strong>索引编号</strong>，可能为空且<strong>不一定准确</strong>，由编译器决定，一般不使用该值</li><li>Name：这个是一个以”\0”结尾的字符串，表示函数名</li></ul><hr><p>这里不难发现，IMAGE_THUNK_DATA最终提供的数据也只有2个：</p><ul><li>DWORD最高位为0时：需要导入函数的名称（Hint不一定准确，所以不使用）</li><li>DWORD最高位为1时：需要导入的函数在导出表中的序号</li></ul><p>正好对应了在上一个笔记：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1412395&page=1#37915237_%E7%94%B1%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%8E%B7%E5%BE%97%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0">PE文件笔记十四 导出表</a>中由导出表获得导出函数所需的两种方法</p><p>即：</p><ol><li>根据函数名称获取导出函数地址</li><li>根据函数序号获取导出函数地址</li></ol><hr><h4 id="OriginalFirstThunk"><a href="#OriginalFirstThunk" class="headerlink" title="OriginalFirstThunk"></a>OriginalFirstThunk</h4><p>因为它是指向另外数据结构的通路，因此简称为桥1。该字段指向一个包含了一系列结构的数组：IMAGE_THUNK_DATA</p><p>桥1所指向的地址列表被定义为：<strong>INT</strong>（Import Name Table） 导入名称表</p><hr><h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>时间戳，一般不用，大多情况下都为0。如果该导入表项被绑定，那么绑定后的这个时间戳就被设置为对应DLL文件的时间戳。操作系统在加载时，可以通过这个时间戳来判断绑定的信息是否过时</p><hr><h4 id="ForwarderChain"><a href="#ForwarderChain" class="headerlink" title="ForwarderChain"></a>ForwarderChain</h4><p>链表的前一个结构</p><hr><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>这里的Name是一个RVA，它指向该结构对应的DLL文件的名称，而这个名称是以”\0”结尾的ANSI字符串</p><p>ANSI编码是一种对ASCII码的拓展</p><hr><h4 id="FirstThunk"><a href="#FirstThunk" class="headerlink" title="FirstThunk"></a>FirstThunk</h4><p>与OriginalFirstThunk相同，它指向的链表定义了针对Name这个动态链接库引入的所有导入函数，简称桥2</p><p>桥2所指向的地址列表被定义为：<strong>IAT</strong>（Import Adress Table） 导入地址表</p><hr><h2 id="导入表的双桥结构"><a href="#导入表的双桥结构" class="headerlink" title="导入表的双桥结构"></a>导入表的双桥结构</h2><p>桥1和桥2最终的目的地是一致的，都指向了引入函数的”编号—名称”（Hint/Name）描述部分</p><p>桥1到目的地的过程中，经过了：<strong>INT</strong>（Import Name Table）导入名称表</p><p>而桥2到目的地的过程中，经过了：<strong>IAT</strong>(Import Address Table)导入地址表</p><hr><h3 id="PE文件加载前"><a href="#PE文件加载前" class="headerlink" title="PE文件加载前"></a>PE文件加载前</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/%E5%8F%8C%E6%A1%A5.png" alt="双桥"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162001903.png" alt="image-20210408162001903"></p><h3 id="PE文件加载后"><a href="#PE文件加载后" class="headerlink" title="PE文件加载后"></a>PE文件加载后</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162839413.png" alt="image-20210408162839413"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408162937094.png" alt="image-20210408162937094"></p><hr><h3 id="加载前后对比"><a href="#加载前后对比" class="headerlink" title="加载前后对比"></a>加载前后对比</h3><ul><li>在PE文件加载前：桥1指向的INT和桥2指向的IAT的数据值是<strong>相同</strong>的，但是其<strong>存储位置是不同的</strong></li><li>在PE文件加载后：桥1指向的INT<strong>不变</strong>，但桥2指向的IAT的数据值<strong>变为了函数相应的RVA地址</strong></li></ul><p>PS：函数相应的RVA地址是根据IAT中的函数名称或者导出表中的序号获得的</p><hr><h2 id="按结构分析导入表"><a href="#按结构分析导入表" class="headerlink" title="按结构分析导入表"></a>按结构分析导入表</h2><p>回到先前得到的导入表的FOA，在WinHex中找到FOA：0x1CDA7C</p><p>这里取第一个_IMAGE_IMPORT_DESCRIPTOR进行分析</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408182130674.png" alt="image-20210408182130674"></p><hr><p>将对应的数据填入结构体成员中得到：</p><table><thead><tr><th align="left">成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Characteristics</td><td align="left">0x001CF790</td><td align="left">标志 为0表示结束 没有导入描述符了</td></tr><tr><td align="left">OriginalFirstThunk</td><td align="left">0x001CF790</td><td align="left">RVA指向IMAGE_THUNK_DATA结构数组（桥1）</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">0x00000000</td><td align="left">时间戳</td></tr><tr><td align="left">ForwarderChain</td><td align="left">0x00000000</td><td align="left">链表的前一个结构</td></tr><tr><td align="left">Name</td><td align="left">0x001D0788</td><td align="left">RVA，指向DLL名字，该名字以’’\0’’结尾</td></tr><tr><td align="left">FirstThunk</td><td align="left">0x0019B1D4</td><td align="left">RVA指向IMAGE_THUNK_DATA结构数组（桥2）</td></tr></tbody></table><hr><h3 id="Characteristics-1"><a href="#Characteristics-1" class="headerlink" title="Characteristics"></a>Characteristics</h3><p>不为0，表示还有导入描述符</p><hr><h3 id="OriginalFirstThunk-1"><a href="#OriginalFirstThunk-1" class="headerlink" title="OriginalFirstThunk"></a>OriginalFirstThunk</h3><p>指向IMAGE_THUNK_DATA结构数组，先将RVA：0x001CF790转换为FOA：0x1CDD90</p><p>转换代码为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x001CF790,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>用WinHex找到0x1CDD90的位置：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408144944386.png" alt="image-20210408144944386"></p><hr><p>得到结构体数组 INT为：</p><table><thead><tr><th align="left">数组下标</th><th align="left">IMAGE_THUNK_DATA(RVA)</th><th align="left">对应FOA</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x001D0774</td><td align="left">0x1CED74</td></tr><tr><td align="left">1</td><td align="left">0x001D2620</td><td align="left">0x1D0C20</td></tr><tr><td align="left">2</td><td align="left">0x001D2606</td><td align="left">0x1D0C06</td></tr><tr><td align="left">3</td><td align="left">0x001D25F4</td><td align="left">0x1D0BF4</td></tr><tr><td align="left">4</td><td align="left">0x001D25E0</td><td align="left">0x1D0BE0</td></tr><tr><td align="left">…………..</td><td align="left">……………………………….</td><td align="left">…………</td></tr><tr><td align="left">n</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>因为这里前面的几个IMAGE_THUNK_DATA的最高位都为0，于是其表示的为内容表示指向_IMAGE_IMPORT_BY_NAME的RVA</p><p>PS：若最高位为1，则其表示的内容去掉最高位后为：导出函数的序号</p><hr><p>先查看下标为0 对应的FOA：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408150058936.png" alt="image-20210408150058936"></p><hr><p>将得到的数据填入_IMAGE_IMPORT_BY_NAME</p><table><thead><tr><th align="left">_IMAGE_IMPORT_BY_NAME成员</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">Hint</td><td align="left">0x018F</td></tr><tr><td align="left">Name</td><td align="left">ANSI码为”GetComputerNameW”</td></tr></tbody></table><p>这里就获得了需要导入的函数的名称和Hint，这个Hint不一定准确，不使用</p><hr><h3 id="TimeDateStamp-1"><a href="#TimeDateStamp-1" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h3><p>值为0，编译器并未填写时间戳</p><hr><h3 id="ForwarderChain-1"><a href="#ForwarderChain-1" class="headerlink" title="ForwarderChain"></a>ForwarderChain</h3><p>值为0，没有链表的前一个结构</p><hr><h3 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h3><p>值为0x001D0788，是个RVA地址，先将其转换成FOA：0x1CED88</p><p>转换代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x001D0788,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>用WinHex找到0x1CED88的位置：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408150719798.png" alt="image-20210408150719798"></p><p>得到第一个导入描述符 描述的导入模块名为：”KERNEL32.dll”</p><hr><h3 id="FirstThunk-1"><a href="#FirstThunk-1" class="headerlink" title="FirstThunk"></a>FirstThunk</h3><p>值为0x0019B1D4，是个RVA地址，先将其转换成FOA：0x1997D4</p><p>转换代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x0019B1D4,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>用WinHex找到0x1997D4的位置：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408152225017.png" alt="image-20210408152225017"></p><hr><p>得到结构体数组 IAT为：</p><table><thead><tr><th align="left">数组下标</th><th align="left">IMAGE_THUNK_DATA(RVA)</th><th align="left">对应FOA</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0x001D0774</td><td align="left">0x1CED74</td></tr><tr><td align="left">1</td><td align="left">0x001D2620</td><td align="left">0x1D0C20</td></tr><tr><td align="left">2</td><td align="left">0x001D2606</td><td align="left">0x1D0C06</td></tr><tr><td align="left">3</td><td align="left">0x001D25F4</td><td align="left">0x1D0BF4</td></tr><tr><td align="left">4</td><td align="left">0x001D25E0</td><td align="left">0x1D0BE0</td></tr><tr><td align="left">…………..</td><td align="left">……………………………….</td><td align="left">…………</td></tr><tr><td align="left">n</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><hr><p>这里会发现IAT和INT中的内容是一致的，但是它们存储在不同的地址上（FOA不同，前面INT的FOA为：0x1CDD90，这里IAT的FOA为：0x1997D4）</p><p>验证了：在PE文件加载前，桥1指向的INT和桥2指向的IAT的数据值是相同的，但是其存储位置是不同的</p><hr><h2 id="验证PE文件加载后的IAT变化"><a href="#验证PE文件加载后的IAT变化" class="headerlink" title="验证PE文件加载后的IAT变化"></a>验证PE文件加载后的IAT变化</h2><p>上面只分析了PE文件加载前的IAT，其内容和INT一致；当程序运行后，再用OD来查看其对应的IAT的变化：</p><p>先前获得的IAT地址为：0x0019B1D4（RVA），用OD打开EverEdit.exe</p><p>选中数据窗口</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408164539480.png" alt="image-20210408164539480"></p><hr><p>然后按快捷键：Ctrl+G，弹出窗口</p><p>在弹出的窗口中填写要跳转的RVA地址</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408165048250.png" alt="image-20210408165048250"></p><hr><p>然后会发现内存窗口中的内容发生了改变，但显示方式并不是很友好</p><p>于是修改一下显示方式，在内存窗口中 右键→长型→ASCII数据地址</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408165318175.png" alt="image-20210408165318175"></p><hr><p>可以看到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408165346670.png" alt="image-20210408165346670"></p><p>可以看到这里的kerner32.GetComputerNameW正是前面分析出来的名称</p><p>验证了IAT表在PE文件加载后发生了变化</p><hr><h1 id="代码实现分析导入表"><a href="#代码实现分析导入表" class="headerlink" title="代码实现分析导入表"></a>代码实现分析导入表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">        UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        //输出rva</span><br><span class="line">        //printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">        //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">        UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">        //输出PeEnd</span><br><span class="line">        //printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">        //判断rva是否位于PE文件头中</span><br><span class="line">        if (rva &lt; PeEnd) &#123;</span><br><span class="line">                //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">                //printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">                return rva;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                //如果rva在PE文件头外</span><br><span class="line">                //判断rva属于哪个节</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">                        //计算内存对齐后节的大小</span><br><span class="line">                        UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">                        if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                                //找到所属的节</span><br><span class="line">                                //输出内存对齐后的节的大小</span><br><span class="line">                                //printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //未找到</span><br><span class="line">                        printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">                        UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">                        //FOA = 节.PointerToRawData + 差值</span><br><span class="line">                        UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">                        //printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">                        return foa;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getImportTable(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        _IMAGE_DATA_DIRECTORY importDataDirectory = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];</span><br><span class="line"></span><br><span class="line">        //计数，用来记录导入了多少个模块</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">                UINT importAddress = VaToFoa32(importDataDirectory.VirtualAddress + nt-&gt;OptionalHeader.ImageBase, dos, nt, sectionArr);</span><br><span class="line">                _IMAGE_IMPORT_DESCRIPTOR* importDirectory = (_IMAGE_IMPORT_DESCRIPTOR*)((UINT)dos + importAddress + sizeof(_IMAGE_IMPORT_DESCRIPTOR) * cnt) ;</span><br><span class="line">                if (importDirectory-&gt;OriginalFirstThunk != 0) &#123;</span><br><span class="line">                        UINT nameOffset = VaToFoa32(importDirectory-&gt;Name + nt-&gt;OptionalHeader.ImageBase, dos, nt, sectionArr);</span><br><span class="line">                        char* name = (char*)((UINT)dos + nameOffset);</span><br><span class="line">                        cnt++;</span><br><span class="line">                        UINT offset=VaToFoa32(nt-&gt;OptionalHeader.ImageBase+importDirectory-&gt;OriginalFirstThunk, dos, nt, sectionArr);</span><br><span class="line">                        if (offset == -1)return;</span><br><span class="line">                        IMAGE_THUNK_DATA* INTTableBegin=(IMAGE_THUNK_DATA*)((UINT)dos + offset);</span><br><span class="line">                        //计数，用来记录导入了该模块多少个函数</span><br><span class="line">                        int cnt2 = 0;</span><br><span class="line">                        while (true) &#123;</span><br><span class="line"></span><br><span class="line">                                IMAGE_THUNK_DATA* address = INTTableBegin + cnt2;</span><br><span class="line">                                if (address-&gt;u1.AddressOfData == 0) &#123;</span><br><span class="line">                                        break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                else &#123;</span><br><span class="line">                                        //判断最高位</span><br><span class="line">                                        if ((UINT)address-&gt;u1.AddressOfData &gt;= 0x80000000) &#123;</span><br><span class="line">                                                //最高位为1</span><br><span class="line">                                                printf(&quot;模块名:%s\t函数序号:%X\n&quot;, name, address-&gt;u1.Ordinal-0x80000000);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        else &#123;</span><br><span class="line">                                                //最高位为0</span><br><span class="line">                                                UINT functionNameOffset= VaToFoa32(nt-&gt;OptionalHeader.ImageBase + (UINT)address-&gt;u1.AddressOfData, dos, nt, sectionArr);</span><br><span class="line">                                                _IMAGE_IMPORT_BY_NAME* functionName=(_IMAGE_IMPORT_BY_NAME*)((UINT)dos + functionNameOffset);</span><br><span class="line">                                                printf(&quot;模块名:%s\t函数名:%s\n&quot;, name,functionName-&gt;Name);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                cnt2++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        printf(&quot;模块%s\t函数数量%d\n&quot;, name,cnt2);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;引用模块数:%d\n&quot;, cnt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getImportTable(dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408203544390.png" alt="image-20210408203544390"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408203623096.png" alt="image-20210408203623096"></p><p>可以看到运行结果和前面手动分析的一致，并且既能解析出函数名也能解析出函数序号</p><hr><p>再用PE工具：DIE验证一下</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408204013688.png" alt="image-20210408204013688"></p><p>结果是一致的，代码部分完成q(≧▽≦q)</p><hr><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>这次的代码部分其实和先前的解析导出表难度差不多</p><p>要注意的就是解析IMAGE_THUNK_DATA时，要先判断其最高位；根据最高位是否为1来进行类型转换和解读</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>导出表<strong>最多</strong>只有一张，而导入表<strong>通常不只一张</strong></li><li>导入表具有<strong>双桥结构</strong>，双桥结构中的<strong>IAT</strong>在PE文件运行前和PE文件运行后<strong>内容不同</strong></li><li>无论是INT还是IAT在PE文件运行前其<strong>内容是一致</strong>的，结构都为IMAGE_THUNK_DATA</li><li>无论是INT还是IAT在PE文件运行前，其存储的内容归根结底要么是<strong>导出函数序号</strong>，要么就是<strong>导出函数名称</strong></li><li>通过导出函数序号和导出函数名称再加上模块名就可以根据导出表获取到对应的<strong>函数地址</strong></li></ul><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1413220-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十四 导出表</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9314/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9314/</url>
      
        <content type="html"><![CDATA[<p>前面在学习了关于节的各种操作，但更之前的扩展PE头的DataDirectory中各表项的含义还没具体介绍</p><p>这次来学习DataDirectory[0]也就是导出表的具体内容</p><hr><h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><h2 id="导出表作用"><a href="#导出表作用" class="headerlink" title="导出表作用"></a>导出表作用</h2><p>一个可执行程序是由<strong>多个PE文件组成</strong>的</p><p>依旧拿先前的EverEdit.exe为例，查看运行它所需的所有模块</p><p>使用OD载入EverEdit.exe，然后点击上方的<code>e</code>来查看所有模块</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406212544713.png" alt="image-20210406212544713"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406212652608.png" alt="image-20210406212652608"></p><p>可以看到，该程序除了包含EverEdit.exe这个模块外还包含不少其它的dll（动态链接库），这些dll为程序提供一些函数</p><p>就比如MessageBoxA这个弹窗的函数就是由user32.dll这个模块提供的</p><p>以上这些模块都发挥着其作用，使得程序得以正常运行</p><p>一个程序引用哪些模块是由<strong>其导入表</strong>决定的</p><p>与导入表相对的便是<strong>导出表</strong>，导出表则是决定当前的PE文件能够<strong>给其它PE文件提供的函数</strong></p><p>拿前面提到的user32.dll为例，其导出表一定是包含MessageBoxA这个函数的</p><hr><p>归纳一下导入表和导出表</p><ul><li>导入表：该PE文件还使用哪些PE文件</li><li>导出表：该PE文件提供了哪些函数给其它PE文件</li></ul><hr><h2 id="什么是导出表"><a href="#什么是导出表" class="headerlink" title="什么是导出表"></a>什么是导出表</h2><p>导出表就是记录该PE文件提供给其它PE文件的函数的一种结构</p><hr><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><h3 id="定位导出表原理"><a href="#定位导出表原理" class="headerlink" title="定位导出表原理"></a>定位导出表原理</h3><p>在前面的笔记：<a href="https://www.52pojie.cn/thread-1405930-1-1.html#37759493_datadirectory">PE文件笔记五 PE文件头之扩展PE头</a>中还剩下一个DataDirectory的结构没有具体说明</p><p>DataDirectory是一个数组，<strong>每个数组成员对应一个表</strong>，如导入表、导出表、重定位表等等</p><p>回顾先前的笔记，能得到导出表对应的下标为0</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td><td align="left">0</td><td align="left">导出表</td></tr></tbody></table><p>即DataDirectory[0]表示导出表</p><hr><p>接下来来具体研究一下DataDirectory数组成员的结构</p><p>先给出C语言中 该成员在扩展PE头里的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br></pre></td></tr></table></figure><hr><p>可以看到数组成员的结构为IMAGE_DATA_DIRECTORY</p><h4 id="IMAGE-DATA-DIRECTORY"><a href="#IMAGE-DATA-DIRECTORY" class="headerlink" title="IMAGE_DATA_DIRECTORY"></a>IMAGE_DATA_DIRECTORY</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">DWORD(4字节)</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">DWORD(4字节)</td><td align="left">表的大小</td></tr></tbody></table><h5 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h5><p>表的起始位置，是一个相对虚拟地址（RVA），不了解RVA的可以回顾先前的：<a href="https://www.52pojie.cn/thread-1408576-1-1.html">PE文件笔记七 VA与FOA转换</a></p><hr><h5 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h5><p>表的大小</p><hr><p>根据前面的分析可以得出：</p><p>IMAGE_DATA_DIRECTORY这个结构<strong>只记录 表的位置和大小</strong>，并<strong>没有涉及表的具体结构</strong></p><hr><h3 id="定位导出表流程"><a href="#定位导出表流程" class="headerlink" title="定位导出表流程"></a>定位导出表流程</h3><ol><li>找到扩展PE头的最后一个成员DataDirectory</li><li>获取DataDirectory[0]</li><li>通过DataDirectory[0].VirtualAddress得到导出表的RVA</li><li>将导出表的RVA转换为FOA，在文件中定位到导出表</li></ol><h2 id="按流程定位导出表"><a href="#按流程定位导出表" class="headerlink" title="按流程定位导出表"></a>按流程定位导出表</h2><h3 id="要分析的实例"><a href="#要分析的实例" class="headerlink" title="要分析的实例"></a>要分析的实例</h3><p>这次分析的程序以MyDll.dll为例（自己编写的dll，只提供了加减乘除的导出函数）</p><p>给出导出函数的定义声明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码EXPORTS</span><br><span class="line">Add @12 </span><br><span class="line">Sub @15 NONAME</span><br><span class="line">Multiply @17</span><br><span class="line">Divide @10</span><br></pre></td></tr></table></figure><p>再给出具体的导出函数内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码int _stdcall Add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">        return x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _stdcall Sub(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">        return x-y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _stdcall Multiply(int x, int y) &#123;</span><br><span class="line">        return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _stdcall Divide(int x, int y) &#123;</span><br><span class="line">        return x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完整的DLL源代码和DLL程序在后面的附件中，有需要可以自行取用</p><h3 id="找到DataDirectory"><a href="#找到DataDirectory" class="headerlink" title="找到DataDirectory"></a>找到DataDirectory</h3><p>使用WinHex打开MyDll.dll，先找到PE文件头的起始地址：0xF8</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407143723020.png" alt="image-20210407143723020"></p><hr><p>再数24个字节（PE文件头标志大小+标准PE头大小），到达扩展PE头：0xF8+24=248+24=272=0x110</p><p>然后在数224-128=96个字节（扩展PE头大小减去DataDirectory大小）DataDirectory大小= _IMAGE_DATA_DIRECTORY大小×16=8*16</p><p>DataDirectory首地址 = 扩展PE头地址+96=0x110+96=272+96=368=0x170</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407145603036.png" alt="image-20210407145603036"></p><h3 id="获取DataDirectory-0"><a href="#获取DataDirectory-0" class="headerlink" title="获取DataDirectory[0]"></a>获取DataDirectory[0]</h3><p>而导出表为DataDirectory[0]，也就是从首地址开始的8个字节就是描述导出表的IMAGE_DATA_DIRECTORY</p><table><thead><tr><th align="left">IMAGE_DATA_DIRECTORY成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">0x00018FB0</td><td align="left">表的起始位置（RVA）</td></tr><tr><td align="left">Size</td><td align="left">0x00000190</td><td align="left">表的大小</td></tr></tbody></table><hr><h3 id="得到导出表的RVA"><a href="#得到导出表的RVA" class="headerlink" title="得到导出表的RVA"></a>得到导出表的RVA</h3><p>于是得到导出表对应的RVA为：0x18FB0</p><hr><h3 id="RVA转换FOA"><a href="#RVA转换FOA" class="headerlink" title="RVA转换FOA"></a>RVA转换FOA</h3><p>但是IMAGE_DATA_DIRECTORY中的VirtualAddress是RVA，需要将其转换成FOA</p><p>关于RVA转FOA的内容在<a href="https://www.52pojie.cn/thread-1408576-1-1.html"> PE文件笔记七 VA与FOA转换</a>中已经详细说明了，这里不再赘述</p><p>直接使用在笔记七中写的转换代码计算出对应的FOA：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">        UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        //输出rva</span><br><span class="line">        printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">        //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">        UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">        //输出PeEnd</span><br><span class="line">        printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">        //判断rva是否位于PE文件头中</span><br><span class="line">        if (rva &lt; PeEnd) &#123;</span><br><span class="line">                //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">                printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">                return rva;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                //如果rva在PE文件头外</span><br><span class="line">                //判断rva属于哪个节</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">                        //计算内存对齐后节的大小</span><br><span class="line">                        UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">                        if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                                //找到所属的节</span><br><span class="line">                                //输出内存对齐后的节的大小</span><br><span class="line">                                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //未找到</span><br><span class="line">                        printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">                        UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">                        //FOA = 节.PointerToRawData + 差值</span><br><span class="line">                        UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">                        printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">                        return foa;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Documents and Settings\\Administrator\\桌面\\user32.dll&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x18FB0,dos,nt,sectionArr);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>关键代码:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase +0x18FB0,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>因为先前写的函数是VA转FOA，这里得到的是RVA，于是要先用RVA+ImageBase得到VA</p><p>运行代码得到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407144705123.png" alt="image-20210407144705123"></p><hr><p>获得了FOA为0x79B0，也就是导出表的位置了，定位完成</p><hr><h2 id="导出表的结构"><a href="#导出表的结构" class="headerlink" title="导出表的结构"></a>导出表的结构</h2><p>定位到了导出表后自然要了解导出表的结构才能解读导出表的内容</p><p>给出导出表在C语言中的结构体（在winnt.h中可以找到）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407124035639.png" alt="image-20210407124035639"></p><hr><p>即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNames;         // RVA from base of image</span><br><span class="line">    DWORD   AddressOfNameOrdinals;  // RVA from base of image</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><hr><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Characteristics</td><td align="left">DWORD(4字节)</td><td align="left">标志，未用</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">DWORD(4字节)</td><td align="left">时间戳</td></tr><tr><td align="left">MajorVersion</td><td align="left">WORD(2字节)</td><td align="left">未用</td></tr><tr><td align="left">MinorVersion</td><td align="left">WORD(2字节)</td><td align="left">未用</td></tr><tr><td align="left">Name</td><td align="left">DWORD(4字节)</td><td align="left">指向该导出表的文件名字符串</td></tr><tr><td align="left">Base</td><td align="left">DWORD(4字节)</td><td align="left">导出函数起始序号</td></tr><tr><td align="left">NumberOfFunctions</td><td align="left">DWORD(4字节)</td><td align="left">所有导出函数的个数</td></tr><tr><td align="left">NumberOfNames</td><td align="left">DWORD(4字节)</td><td align="left">以函数名字导出的函数个数</td></tr><tr><td align="left">AddressOfFunctions</td><td align="left">DWORD(4字节)</td><td align="left">导出函数地址表RVA</td></tr><tr><td align="left">AddressOfNames</td><td align="left">DWORD(4字节)</td><td align="left">导出函数名称表RVA</td></tr><tr><td align="left">AddressOfNameOrdinals</td><td align="left">DWORD(4字节)</td><td align="left">导出函数序号表RVA</td></tr></tbody></table><hr><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>未使用，固定填充0</p><hr><h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>Image时间戳的低32位。这表示<strong>链接器</strong>创建Image的日期和时间。根据系统时钟，该值以自1970年1月1日午夜（00:00:00）后经过的秒数表示</p><p>与标准PE头中的TimeDateStamp一致</p><hr><h4 id="MajorVersion"><a href="#MajorVersion" class="headerlink" title="MajorVersion"></a>MajorVersion</h4><p>未使用，固定填充0</p><hr><h4 id="MinorVersion"><a href="#MinorVersion" class="headerlink" title="MinorVersion"></a>MinorVersion</h4><p>MinorVersion</p><hr><h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>该字段指示的地址指向了一个以”\0”结尾的字符串，字符串记录了导出表所在的文件的最初文件名</p><hr><h4 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h4><p>导出函数序号的起始值。DLL中第一个导出函数并不是从0开始的，某导出函数的编号等于从AddressOfFunctions开始的顺序号加上这个值。大致示意图：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407131635788.png" alt="image-20210407131635788"></p><p>如图所示，Fun1的函数编号为nBase+0=200h,Fun2的函数编号为nBase+1=201h，以此类推</p><hr><h4 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h4><p>该字段定义了文件中导出函数的总个数</p><hr><h4 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h4><p>在导出表中，有些函数是定义名字的，有些是没有定义名字的。该字段记录了所有定义名字函数的个数。如果这个值是0，则表示所有的函数都没有定义名字。NumbersOfNames一定小于等于NumbersOfFuctions</p><hr><h4 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h4><p>该指针指向了全部导出函数的入口地址的起始。从入口地址开始为DWORD数组，数组的个数由NumbersOfFuctions决定</p><p>导出函数的每一个地址<strong>按函数的编号顺序</strong>依次往后排开。在内存中，可以通过<strong>函数编号</strong>来定位某个函数的地址</p><hr><h4 id="AddressOfNames"><a href="#AddressOfNames" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h4><p>该值为一个指针。该指针指向的位置是一连串的DWORD值，这些值均指向了对应的定义了函数名的函数的字符串地址。这一连串的DWORD值的个数为NumberOfNames</p><hr><h4 id="AddressOfNameOrdinals"><a href="#AddressOfNameOrdinals" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h4><p>该值也是一个指针，与AddressOfNames是<strong>一一对应</strong>关系</p><p>不同的是，AddressOfNames指向的是字符串的指针数组，而AddressOfNameOrdinals则指向了该函数在AddressOfFunctions中的<strong>索引值</strong></p><hr><p>注意：<strong>索引值数据类型为WORD，而非DWORD</strong>。该值与函数编号是两个不同的概念，两者的关系为：</p><p>索引值 = 编号 - Base</p><hr><h3 id="字段间关系图示"><a href="#字段间关系图示" class="headerlink" title="字段间关系图示"></a>字段间关系图示</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407132858847.png" alt="image-20210407132858847"></p><hr><h2 id="按结构分析导出表"><a href="#按结构分析导出表" class="headerlink" title="按结构分析导出表"></a>按结构分析导出表</h2><p>回到先前得到的导出表的FOA，在WinHex中找到FOA：0x79B0</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407145702135.png" alt="image-20210407145702135"></p><hr><p>将对应的数据填入结构体成员中得到：</p><table><thead><tr><th align="left">成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Characteristics</td><td align="left">0X00000000</td><td align="left">标志，未用，固定为0</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">0xFFFFFFFF</td><td align="left">时间戳</td></tr><tr><td align="left">MajorVersion</td><td align="left">0X0000</td><td align="left">未用，固定为0</td></tr><tr><td align="left">MinorVersion</td><td align="left">0X0000</td><td align="left">未用，固定为0</td></tr><tr><td align="left">Name</td><td align="left">0x0001900A</td><td align="left">指向该导出表的文件名字符串</td></tr><tr><td align="left">Base</td><td align="left">0x0000000A</td><td align="left">导出函数起始序号</td></tr><tr><td align="left">NumberOfFunctions</td><td align="left">0x00000008</td><td align="left">所有导出函数的个数</td></tr><tr><td align="left">NumberOfNames</td><td align="left">0x00000003</td><td align="left">以函数名字导出的函数个数</td></tr><tr><td align="left">AddressOfFunctions</td><td align="left">0x00018FD8</td><td align="left">导出函数地址表RVA</td></tr><tr><td align="left">AddressOfNames</td><td align="left">0x00018FF8</td><td align="left">导出函数名称表RVA</td></tr><tr><td align="left">AddressOfNameOrdinals</td><td align="left">0x00019004</td><td align="left">导出函数序号表RVA</td></tr></tbody></table><hr><h3 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h3><p>存储的值为指针，该指针为RVA，同样需要转成FOA</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x1900A,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>运行程序得到结果:</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407145928618.png" alt="image-20210407145928618"></p><hr><p>用WinHex找到0x7A0A的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407150048888.png" alt="image-20210407150048888"></p><p>得到该导出表的文件名字 字符串为：MyDll.dll</p><hr><h3 id="Base-1"><a href="#Base-1" class="headerlink" title="Base"></a>Base</h3><p>导出函数起始序号为0xA，对应十进制10</p><p>回顾一下前面导出函数的定义声明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码EXPORTS</span><br><span class="line">Add @12 </span><br><span class="line">Sub @15 NONAME</span><br><span class="line">Multiply @17</span><br><span class="line">Divide @10</span><br></pre></td></tr></table></figure><p>不难发现，这里的base=最小的序号=min{12,15,17,10}=10</p><hr><h3 id="NumberOfFunctions-1"><a href="#NumberOfFunctions-1" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h3><p>所有导出函数的个数为8</p><p>明明前面声明的导出函数只有4个，为什么这里显示的导出函数个数为8？</p><p>这里的NumberOfFunctions = 最大的序号减去最小的序号+1=17-10+1=8</p><hr><h3 id="NumberOfNames-1"><a href="#NumberOfNames-1" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h3><p>以函数名字导出的函数个数为3，和定义声明中有名称的导出函数 数量一致</p><hr><h3 id="AddressOfFunctions-1"><a href="#AddressOfFunctions-1" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h3><p>存储的值为指针，该指针为RVA，同样需要转成FOA</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x18FD8,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>运行程序得到结果:</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407150355678.png" alt="image-20210407150355678"></p><hr><p>用WinHex找到0x79D8的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407150517575.png" alt="image-20210407150517575"></p><p>记录下所有导出函数的地址并转化RVA为FOA得到：</p><table><thead><tr><th align="left">Oridinals</th><th align="left">序号(Oridinals+Base)</th><th align="left">导出函数地址(RVA)</th><th align="left">导出函数地址(FOA)</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">10</td><td align="left">0x00011320</td><td align="left">0x720</td></tr><tr><td align="left">1</td><td align="left">11</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">12</td><td align="left">0x00011302</td><td align="left">0x702</td></tr><tr><td align="left">3</td><td align="left">13</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">14</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">15</td><td align="left">0x000111EF</td><td align="left">0x5EF</td></tr><tr><td align="left">6</td><td align="left">16</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">17</td><td align="left">0x000111A4</td><td align="left">0x5A4</td></tr></tbody></table><p>可以看到只有4个导出函数是有效的，和前面DLL导出声明定义一致</p><hr><h3 id="AddressOfNames-1"><a href="#AddressOfNames-1" class="headerlink" title="AddressOfNames"></a>AddressOfNames</h3><p>存储的值为指针，该指针为RVA，同样需要转成FOA</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x18FF8,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>运行程序得到结果:</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407150839193.png" alt="image-20210407150839193"></p><hr><p>用WinHex找到0x79F8的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407150925784.png" alt="image-20210407150925784"></p><p>记录下所有导出函数名称的地址为</p><p>0x00019014</p><p>0x00019018</p><p>0x0001901F</p><p>将RVA转化为FOA：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x19014,dos,nt,sectionArr);</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x19018,dos,nt,sectionArr);</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x1901F,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><hr><p>运行程序得到结果:</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407151149110.png" alt="image-20210407151149110"></p><hr><p>即得到有名称函数的名称地址为：</p><table><thead><tr><th align="left">顺序索引</th><th align="left">RVA</th><th align="left">FOA</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x19014</td><td align="left">0x7A14</td></tr><tr><td align="left">2</td><td align="left">0x19018</td><td align="left">0x7A18</td></tr><tr><td align="left">3</td><td align="left">0x1901F</td><td align="left">0x7A1F</td></tr></tbody></table><hr><p>用WinHex找到对应的FOA位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407151409695.png" alt="image-20210407151409695"></p><hr><p>得到了各导出函数的名称为</p><table><thead><tr><th align="left">顺序索引</th><th align="left">RVA</th><th align="left">FOA</th><th align="left">导出函数名称</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x19014</td><td align="left">0x7A14</td><td align="left">Add</td></tr><tr><td align="left">2</td><td align="left">0x19018</td><td align="left">0x7A18</td><td align="left">Divide</td></tr><tr><td align="left">3</td><td align="left">0x1901F</td><td align="left">0x7A1F</td><td align="left">Multiply</td></tr></tbody></table><hr><h3 id="AddressOfNameOrdinals-1"><a href="#AddressOfNameOrdinals-1" class="headerlink" title="AddressOfNameOrdinals"></a>AddressOfNameOrdinals</h3><p>存储的值为指针，该指针为RVA，同样需要转成FOA</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">VaToFoa32(nt-&gt;OptionalHeader.ImageBase+0x19004,dos,nt,sectionArr);</span><br></pre></td></tr></table></figure><p>运行程序得到结果:</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407151553911.png" alt="image-20210407151553911"></p><hr><p>用WinHex找到0x7A04的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407152925004.png" alt="image-20210407152925004"></p><hr><p>得到<strong>有名称函数</strong>的Ordinals</p><p>注意Oridinals的数据宽度为2个字节(WORD)</p><table><thead><tr><th align="left">顺序索引</th><th align="left">Oridinals</th><th align="left">序号(Oridinals+Base)</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x0002</td><td align="left">12</td></tr><tr><td align="left">2</td><td align="left">0x0000</td><td align="left">10</td></tr><tr><td align="left">3</td><td align="left">0x0007</td><td align="left">17</td></tr></tbody></table><p>根据有名称函数的Oridinals结合前面得到的AddressOfFunctions和AdressOfNames，就可以得到函数的名称、函数的地址的关系</p><table><thead><tr><th align="left">顺序索引</th><th align="left">Oridinals</th><th align="left">导出函数地址(RVA)</th><th align="left">导出函数地址(FOA)</th><th align="left">函数名称</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x0002</td><td align="left">0x00011302</td><td align="left">0x702</td><td align="left">Add</td></tr><tr><td align="left">2</td><td align="left">0x0000</td><td align="left">0x00011320</td><td align="left">0x720</td><td align="left">Divide</td></tr><tr><td align="left">3</td><td align="left">0x0007</td><td align="left">0x000111A4</td><td align="left">0x5A4</td><td align="left">Multiply</td></tr></tbody></table><hr><p>导出表分析完毕</p><h2 id="由导出表获得导出函数"><a href="#由导出表获得导出函数" class="headerlink" title="由导出表获得导出函数"></a>由导出表获得导出函数</h2><p>从前面的分析中可以得知查询导出表有两种方法：</p><ol><li>根据导出表函数名称获取导出函数地址</li><li>根据导出表函数序号获取导出函数地址</li></ol><hr><h3 id="函数名称获取导出函数"><a href="#函数名称获取导出函数" class="headerlink" title="函数名称获取导出函数"></a>函数名称获取导出函数</h3><ol><li>根据导出表的函数名称去AddressOfNames指向的每个名称字串查询是否有匹配的字符串</li><li>找到匹配的字符串后，根据找到的顺序索引去AddressOfNameOrdinals中找到对应的Ordinals</li><li>根据前面找到的Ordinals到AddressOfFunctions中获得函数地址</li></ol><hr><p>图解为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407225659644.png" alt="image-20210407225659644"></p><hr><h3 id="函数序号获取导出函数"><a href="#函数序号获取导出函数" class="headerlink" title="函数序号获取导出函数"></a>函数序号获取导出函数</h3><ol><li>根据函数序号-导出表.Base获得导出函数的Ordinal</li><li>根据前面找到的Ordinals到AddressOfFunctions中获得函数地址</li></ol><hr><p>图解为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407225716859.png" alt="image-20210407225716859"></p><hr><h1 id="代码实现分析导出表"><a href="#代码实现分析导出表" class="headerlink" title="代码实现分析导出表"></a>代码实现分析导出表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">        UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        //输出rva</span><br><span class="line">        //printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">        //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">        UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">        //输出PeEnd</span><br><span class="line">        //printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">        //判断rva是否位于PE文件头中</span><br><span class="line">        if (rva &lt; PeEnd) &#123;</span><br><span class="line">                //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">                printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">                return rva;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                //如果rva在PE文件头外</span><br><span class="line">                //判断rva属于哪个节</span><br><span class="line">                int i;</span><br><span class="line">                for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">                        //计算内存对齐后节的大小</span><br><span class="line">                        UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize, (UINT)sectionArr[i]-&gt;SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">                        if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                                //找到所属的节</span><br><span class="line">                                //输出内存对齐后的节的大小</span><br><span class="line">                                //printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //未找到</span><br><span class="line">                        printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">                        return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">                        UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">                        //FOA = 节.PointerToRawData + 差值</span><br><span class="line">                        UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">                        //printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">                        return foa;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//获取导出表</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">void getExportTable(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">        _IMAGE_DATA_DIRECTORY exportDataDirectory = nt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</span><br><span class="line">        UINT exportAddress = VaToFoa32(exportDataDirectory.VirtualAddress+nt-&gt;OptionalHeader.ImageBase, dos, nt, sectionArr);</span><br><span class="line">        _IMAGE_EXPORT_DIRECTORY* exportDirectory = (_IMAGE_EXPORT_DIRECTORY*) ((UINT)dos+ exportAddress);</span><br><span class="line">        printf(&quot;导出函数总数:%X\n&quot;, exportDirectory-&gt;NumberOfFunctions);</span><br><span class="line">        printf(&quot;导出有名称的函数总数:%X\n&quot;, exportDirectory-&gt;NumberOfNames);</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; exportDirectory-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">                printf(&quot;顺序序号:%d\t&quot;, i);</span><br><span class="line">                //获取指向导出函数文件名称的地址</span><br><span class="line">                UINT namePointerAddress = VaToFoa32(exportDirectory-&gt;AddressOfNames + nt-&gt;OptionalHeader.ImageBase + 4 * i, dos, nt, sectionArr);</span><br><span class="line">                if (namePointerAddress == -1)return;</span><br><span class="line">                printf(&quot;namePointerAddress:%X\t&quot;, namePointerAddress);</span><br><span class="line">                //获取指向名字的指针</span><br><span class="line">                UINT* nameAddr =(UINT*) ((UINT)dos + namePointerAddress);</span><br><span class="line">                printf(&quot;nameAddr(RVA):%X\t&quot;, *nameAddr);</span><br><span class="line">                //获取存储名字的地址</span><br><span class="line">                UINT nameOffset = VaToFoa32(*nameAddr + nt-&gt;OptionalHeader.ImageBase, dos, nt, sectionArr);</span><br><span class="line">                if (nameOffset == -1)return;</span><br><span class="line">                printf(&quot;nameOffset:%X\t&quot;, nameOffset);</span><br><span class="line">                //根据名字指针输出名字</span><br><span class="line">                CHAR* name = (CHAR*) ((UINT)dos+ nameOffset);</span><br><span class="line">                printf(&quot;name:%s\t&quot;,name);</span><br><span class="line">                //因为AddressOfNames与AddressOfNameOrdinals一一对应，于是可以获得对应的NameOrdinals</span><br><span class="line"></span><br><span class="line">                //获取存储Ordinals的地址</span><br><span class="line">                UINT OrdinalsOffset = VaToFoa32(exportDirectory-&gt;AddressOfNameOrdinals + nt-&gt;OptionalHeader.ImageBase + 2 * i, dos, nt, sectionArr);</span><br><span class="line">                printf(&quot;OrdinalsOffset:%X\t&quot;, OrdinalsOffset);</span><br><span class="line">                if (OrdinalsOffset == -1)return;</span><br><span class="line">                WORD* Ordinals =(WORD*)((UINT)dos + OrdinalsOffset);</span><br><span class="line">                printf(&quot;Ordinals:%d\t&quot;, *Ordinals);</span><br><span class="line"></span><br><span class="line">                //获得Ordinals后可以根据Ordinals到AddressOfFunctions中找到对应的导出函数的地址</span><br><span class="line">                UINT* functionAddress=(UINT*)((UINT)dos + VaToFoa32(exportDirectory-&gt;AddressOfFunctions + nt-&gt;OptionalHeader.ImageBase + 4* *Ordinals, dos, nt, sectionArr));</span><br><span class="line">                printf(&quot;functionAddress(RVA):%X\n&quot;, *functionAddress);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\MyDll.dll&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                getExportTable(dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210408163706808.png" alt="image-20210407221926491"></p><p>可以看到，得到的结果和先前的手动分析的结果是一致的</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407222732346.png" alt="image-20210407222732346"></p><p>使用PE工具：DIE查看导出表，可以看到结果也是一致的</p><hr><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>这次的代码部分主要是getExportTable这个函数</p><p>该函数并不长，代码中用到了较多的类型转换 和 指针相关的内容</p><p>要注意的地方是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//获取指向导出函数文件名称的地址</span><br><span class="line">UINT namePointerAddress = VaToFoa32(exportDirectory-&gt;AddressOfNames + nt-&gt;OptionalHeader.ImageBase + 4 * i, dos, nt, sectionArr);</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//获取存储Ordinals的地址</span><br><span class="line">UINT OrdinalsOffset = VaToFoa32(exportDirectory-&gt;AddressOfNameOrdinals + nt-&gt;OptionalHeader.ImageBase + 2 * i, dos, nt, sectionArr);</span><br></pre></td></tr></table></figure><hr><p>这里一个是加上4×i；一个是加上2×i</p><p>4和2都是偏移量，偏移量取决于要获取的数据的<strong>数据宽度</strong></p><p>Names的数据宽度为4字节（DWORD），所以每次要加4</p><p>而Ordinals的数据宽度为2字节（WORD），所以每次要加2</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>导出表中还包含了三张小表：导出函数地址表、导出函数名称表、导出函数序号表</li><li>导出表中存储了指向这三张表地址的指针，而不是直接存储表的内容</li><li>无论是根据函数名称还是根据函数序号获取导出函数都需要用到Ordinals，用Ordinals到导出函数地址表中获取地址</li><li>导出表的Base取决于编写DLL时导出定义的最小序号</li><li>导出表的NumberOfFuctions取决于编写DLL时导出定义的序号最大差值+1</li><li>导出名称表和导出函数序号表只对有名称的导出函数有效</li></ul><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>这次提供的附件为本笔记中用到的例子：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210407225538454.png" alt="image-20210407225538454"></p><hr><p>包含1个文件夹和1个dll文件</p><p>dll文件为本笔记中分析的dll文件，MyDll文件夹则是dll的源代码</p><p>有需要者可以自行取用：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/MyDll.zip?versionId=CAEQHhiBgMD28qSzxRciIGY2MTg4Yjc0MjZjMzQ3NzFhNGFhYWUyZTU4M2ZkOWZj">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1412395-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十三 合并节</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9313/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9313/</url>
      
        <content type="html"><![CDATA[<p>前面在<a href="https://www.52pojie.cn/thread-1410348-1-1.html">PE文件笔记十一 新增节</a>学习了关于节的操作之新增节，接下来继续学习节的操作之合并节</p><h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="为什么要合并节"><a href="#为什么要合并节" class="headerlink" title="为什么要合并节"></a>为什么要合并节</h2><p>在前面新增节中，要判断最后一个节表后面是否有空间用于新增节表，只有当最后一个节表后40个字节全为0时，才能进行新增节的操作；但当条件不满足时又想要新增节，该如何操作？</p><p>答案便是：合并节，合并节就是用一个节表描述多个节，这样省下来的节表空间就可以用于新增节了</p><p>于是合并节的目的便是：节省节表空间，这样就能实现新增节</p><hr><h2 id="合并节涉及的结构体成员"><a href="#合并节涉及的结构体成员" class="headerlink" title="合并节涉及的结构体成员"></a>合并节涉及的结构体成员</h2><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Name</td><td align="left">节名称</td></tr><tr><td align="left">VirtualAddress</td><td align="left">节在内存中的偏移 （RVA）</td></tr><tr><td align="left">Misc</td><td align="left">节的实际大小</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left">PointerToRawData</td><td align="left">节区在文件中的偏移</td></tr><tr><td align="left">Characteristics</td><td align="left">节的属性</td></tr></tbody></table><table><thead><tr><th align="left">涉及的标准PE头成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">NumberOfSections</td><td align="left">节的个数</td></tr></tbody></table><h2 id="合并节的流程"><a href="#合并节的流程" class="headerlink" title="合并节的流程"></a>合并节的流程</h2><ol><li>修正内存对齐</li><li>修改第一个节的大小</li><li>修改第一个节的权限</li><li>修改节数量为1</li><li>清空后面的节（可选）</li></ol><hr><h2 id="按流程合并节"><a href="#按流程合并节" class="headerlink" title="按流程合并节"></a>按流程合并节</h2><h3 id="修正内存对齐"><a href="#修正内存对齐" class="headerlink" title="修正内存对齐"></a>修正内存对齐</h3><p>关于修正内存对齐的内容在上一篇笔记 <a href="https://www.52pojie.cn/thread-1410996-1-1.html">PE文件笔记十二 修正内存对齐</a>中已经详细说明了</p><p>这次就以上一篇修正过内存对齐的结果：EverEdit_修正.exe直接进行合并节，在这里省略修正内存对齐的步骤；不了解如何修正内存对齐的可以回顾上一篇笔记</p><p>给出修正完内存对齐后 节的信息</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406135858359.png" alt="image-20210406135858359"></p><hr><table><thead><tr><th align="left">Name</th><th align="left">Misc</th><th align="left">SizeOfRawData</th><th align="left">PointerToRawData</th><th align="left">Characteristics</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">0x19a000</td><td align="left">0x19a000</td><td align="left">0x400</td><td align="left">0x60000020</td></tr><tr><td align="left">.rdata</td><td align="left">0x38000</td><td align="left">0x38000</td><td align="left">0x19a400</td><td align="left">0x40000040</td></tr><tr><td align="left">.data</td><td align="left">0x4b000</td><td align="left">0x4b000</td><td align="left">0x1d2400</td><td align="left">0xc0000040</td></tr><tr><td align="left">.rsrc</td><td align="left">0x63000</td><td align="left">0x63000</td><td align="left">0x21d400</td><td align="left">0x40000040</td></tr><tr><td align="left">.reloc</td><td align="left">0x17000</td><td align="left">0x17000</td><td align="left">0x280400</td><td align="left">0x42000040</td></tr></tbody></table><h3 id="修改第一个节的大小"><a href="#修改第一个节的大小" class="headerlink" title="修改第一个节的大小"></a>修改第一个节的大小</h3><p>修改第一个节的大小为后面 为所有节内存对齐后的大小的和</p><p>即修改第一个节的大小为 0x19a000+0x38000+0x4b000+0x63000+0x17000=0x297000</p><p>仍然使用PE工具：DIE进行修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406191646661.png" alt="image-20210406191646661"></p><hr><p>修改后</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406191729130.png" alt="image-20210406191729130"></p><hr><h3 id="修改第一个节的权限"><a href="#修改第一个节的权限" class="headerlink" title="修改第一个节的权限"></a>修改第一个节的权限</h3><p>既然要用一个节表概括所有的节，那么该节表就必须具备先前所有节表的权限</p><p>也就是第一个节的权限 = 所有节的权限 <strong>相或</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406192516941.png" alt="image-20210406192516941"></p><hr><p>得到新的权限为0xE2000060</p><p>使用PE工具：DIE修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406192958994.png" alt="image-20210406192958994"></p><hr><p>修改后</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193139515.png" alt="image-20210406193139515"></p><hr><h3 id="修改节数量为1"><a href="#修改节数量为1" class="headerlink" title="修改节数量为1"></a>修改节数量为1</h3><p>找到标准PE头中的NumberOfSections成员，将其修改为1</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193233571.png" alt="image-20210406193233571"></p><hr><p>修改后</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193332082.png" alt="image-20210406193332082"></p><hr><h3 id="清空后面的节（可选）"><a href="#清空后面的节（可选）" class="headerlink" title="清空后面的节（可选）"></a>清空后面的节（可选）</h3><p>其实做完上面一步就已经完成了合并节，但合并节是为了腾出节表空间，于是这里再将后面无用的节表清空掉</p><p>使用WinHex找到节表处</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193717767.png" alt="image-20210406193717767"></p><hr><p>选中要清空的部分，编辑→填充选块（快捷键 Ctrl+L）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193921600.png" alt="image-20210406193921600"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406193818020.png" alt="image-20210406193818020"></p><hr><p>清空后保存即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406194003256.png" alt="image-20210406194003256"></p><hr><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p>程序仍然可以正常运行</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406194149811.png" alt="image-20210406194149811"></p><hr><p>并且此时再用PE工具：DIE查看节的信息，也只有一个节了</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406194230742.png" alt="image-20210406194230742"></p><hr><h1 id="代码实现合并节"><a href="#代码实现合并节" class="headerlink" title="代码实现合并节"></a>代码实现合并节</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//向文件中指定位置追加数据</span><br><span class="line">//第一个参数为文件路径</span><br><span class="line">//第二个参数为要追加的数据指针</span><br><span class="line">//第三个参数为要追加的数据大小</span><br><span class="line">//第四个参数为位置偏移</span><br><span class="line">//第五个参数为hMap的指针</span><br><span class="line">//第六个参数为pFile的指针</span><br><span class="line">BOOL appendFile(LPCSTR filePath, PVOID writeData, DWORD sizeOfWriteData, DWORD offset, HANDLE* phMap, PVOID* ppFile) &#123;</span><br><span class="line">    HANDLE hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    char newPath[100];</span><br><span class="line">    strcpy(newPath, filePath);</span><br><span class="line"></span><br><span class="line">    strcat(newPath, &quot;.exe&quot;);</span><br><span class="line">    HANDLE hFile2 = CreateFileA(newPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line"></span><br><span class="line">    //WriteFile用于接收实际写入的大小的参数</span><br><span class="line">    DWORD dwWritenSize = 0;</span><br><span class="line"></span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">    BYTE* content = (BYTE*)pFile;</span><br><span class="line">    content += offset;</span><br><span class="line"></span><br><span class="line">    //写入要插入数据前的数据</span><br><span class="line">    DWORD size = SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    bRet = WriteFile(hFile2, pFile, offset, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //写入要插入的数据</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    bRet = WriteFile(hFile2, writeData, sizeOfWriteData, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //写入要插入数据后的数据</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    bRet = WriteFile(hFile2, content, size - offset, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hMap);</span><br><span class="line">    CloseHandle(*phMap);</span><br><span class="line">    UnmapViewOfFile(pFile);</span><br><span class="line">    UnmapViewOfFile(*ppFile);</span><br><span class="line">    bRet = DeleteFileA(filePath);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    hMap = CreateFileMappingA(hFile2, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_BEGIN);</span><br><span class="line">    bRet = WriteFile(hFile, pFile, sizeOfWriteData + size, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hFile2);</span><br><span class="line">    CloseHandle(hMap);</span><br><span class="line">    UnmapViewOfFile(pFile);</span><br><span class="line">    bRet = DeleteFileA(newPath);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    *ppFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    *phMap = hMap;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//根据pFile获取PE文件结构</span><br><span class="line">void GetPeStruct32(LPVOID pFile, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line"></span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line"></span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">    nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">    //创建指向块表的指针</span><br><span class="line">    _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    //让块表的指针指向其对应的地址</span><br><span class="line">    sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">    //计数，用来计算块表地址</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">    while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">        //将得到的块表指针存入数组</span><br><span class="line">        sectionArr[cnt++] = section;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修正节表的Misc和SizeOfRawData</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">//第四个参数为文件路径</span><br><span class="line">//第五个参数为文件映射</span><br><span class="line">//第六个参数为文件映射内容指针</span><br><span class="line">//第七个参数为要修正的节表在数组中的下标</span><br><span class="line">void sectionAlignment(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr, LPCSTR filePath, HANDLE* phMap,LPVOID* ppFile, int n) &#123;</span><br><span class="line"></span><br><span class="line">    //获得最后一个节的实际大小</span><br><span class="line">    DWORD VirtualSize = sectionArr[n]-&gt;Misc.VirtualSize;</span><br><span class="line">    //获得最后一个节的文件对齐后的大小</span><br><span class="line">    DWORD SizeOfRawData = sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    //计算上一个节内存对齐后的大小</span><br><span class="line">    UINT SizeInMemory = (UINT)ceil((double)max(VirtualSize, SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    printf(&quot;%X\n&quot;, SizeInMemory);</span><br><span class="line">    //计算差值= 内存对齐后大小 - 文件对齐后大小</span><br><span class="line">    UINT offset = SizeInMemory - sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;%X\n&quot;, offset);</span><br><span class="line">    //根据节在文件中的偏移 + 文件对齐后的大小 得到节的末尾</span><br><span class="line">    UINT end = sectionArr[n]-&gt;PointerToRawData + sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;end:%X\n&quot;, end);</span><br><span class="line"></span><br><span class="line">    //申请要填充的空间</span><br><span class="line">    INT* content = (INT*)malloc(offset);</span><br><span class="line">    //初始化为0</span><br><span class="line">    ZeroMemory(content, offset);</span><br><span class="line">    //WriteFile用于接收实际写入的大小的参数</span><br><span class="line">    DWORD dwWritenSize = 0;</span><br><span class="line"></span><br><span class="line">    BOOL bRet=appendFile(filePath, (PVOID)content, offset, end,phMap,ppFile);</span><br><span class="line">    GetPeStruct32(*ppFile, dos, nt, sectionArr);</span><br><span class="line">    if (bRet) &#123;</span><br><span class="line">        //开始修正Misc和SizeOfRawData</span><br><span class="line">        sectionArr[n]-&gt;Misc.VirtualSize = SizeInMemory;</span><br><span class="line">        sectionArr[n]-&gt;SizeOfRawData = SizeInMemory;</span><br><span class="line">        //修正后面受到影响的节的PointerOfRawData和VirtualAddress</span><br><span class="line">        int i;</span><br><span class="line">        while (n + 1 &lt;= nt-&gt;FileHeader.NumberOfSections - 1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            sectionArr[n]-&gt;PointerToRawData += offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//合并节</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">void combineSection(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //所有节内存对齐后的大小的和，这里要求已经修正过内存对齐，只有这样文件对齐大小才会等于内存对齐大小</span><br><span class="line">    DWORD allSectionSize = 0;</span><br><span class="line">    //所有节的权限，初始为第一个节的权限，和后面的每个节的权限进行或操作</span><br><span class="line">    DWORD allSectionCharacteristics = sectionArr[0]-&gt;Characteristics;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections;i++) &#123;</span><br><span class="line">        allSectionSize += sectionArr[i]-&gt;SizeOfRawData;</span><br><span class="line">        allSectionCharacteristics = allSectionCharacteristics | sectionArr[i]-&gt;Characteristics;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;allSectionSize:%X\n&quot;, allSectionSize);</span><br><span class="line">    printf(&quot;allSectionCharacteristics:%X\n&quot;, allSectionCharacteristics);</span><br><span class="line"></span><br><span class="line">    sectionArr[0]-&gt;Misc.VirtualSize = allSectionSize;</span><br><span class="line">    sectionArr[0]-&gt;SizeOfRawData = allSectionSize;</span><br><span class="line">    sectionArr[0]-&gt;Characteristics = allSectionCharacteristics;</span><br><span class="line"></span><br><span class="line">    //清零后面的节</span><br><span class="line">    for (i = 1; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        ZeroMemory(sectionArr[i], sizeof(_IMAGE_SECTION_HEADER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节个数设置为1</span><br><span class="line">    nt-&gt;FileHeader.NumberOfSections = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit_修正.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">        int i;</span><br><span class="line">        //sectionAlignment(dos, nt, sectionArr, &quot;C:\\Users\\sixonezero\\Desktop\\EverEdit\\EverEdit.exe&quot;,hMap, pFile,2);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            sectionAlignment(dos, nt, sectionArr, &quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit_修正.exe&quot;, &amp;hMap, &amp;pFile,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        combineSection(dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="合并节代码"><a href="#合并节代码" class="headerlink" title="合并节代码"></a>合并节代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//合并节</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">void combineSection(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //所有节内存对齐后的大小的和，这里要求已经修正过内存对齐，只有这样文件对齐大小才会等于内存对齐大小</span><br><span class="line">    DWORD allSectionSize = 0;</span><br><span class="line">    //所有节的权限，初始为第一个节的权限，和后面的每个节的权限进行或操作</span><br><span class="line">    DWORD allSectionCharacteristics = sectionArr[0]-&gt;Characteristics;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections;i++) &#123;</span><br><span class="line">        allSectionSize += sectionArr[i]-&gt;SizeOfRawData;</span><br><span class="line">        allSectionCharacteristics = allSectionCharacteristics | sectionArr[i]-&gt;Characteristics;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;allSectionSize:%X\n&quot;, allSectionSize);</span><br><span class="line">    printf(&quot;allSectionCharacteristics:%X\n&quot;, allSectionCharacteristics);</span><br><span class="line"></span><br><span class="line">    sectionArr[0]-&gt;Misc.VirtualSize = allSectionSize;</span><br><span class="line">    sectionArr[0]-&gt;SizeOfRawData = allSectionSize;</span><br><span class="line">    sectionArr[0]-&gt;Characteristics = allSectionCharacteristics;</span><br><span class="line"></span><br><span class="line">    //清零后面的节</span><br><span class="line">    for (i = 1; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        ZeroMemory(sectionArr[i], sizeof(_IMAGE_SECTION_HEADER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节个数设置为1</span><br><span class="line">    nt-&gt;FileHeader.NumberOfSections = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406200009298.png" alt="image-20210406200009298"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406194149811.png" alt="image-20210406194149811"></p><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>合并节就是用一个节表来包括多个节表的信息</li><li>可以看到合并节除了修正内存对齐，其余部分都十分简单</li><li>合并节之后多出了的节表空间可以用来新增节</li></ul><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit%E5%90%88%E5%B9%B6%E8%8A%82.zip?versionId=CAEQHhiBgMCwzMycxRciIDhmMmI2ZTY4MTExMDRiMWE5MjZjYTA2YjFjZWE0ZTUz">点我下载</a></p><p>此次附件中添加了合并完节后的exe</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406202251712.png" alt="image-20210406202251712"></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1411345-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十二 修正内存对齐</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9312/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9312/</url>
      
        <content type="html"><![CDATA[<p>在前面<a href="https://www.52pojie.cn/thread-1409844-1-1.html">PE文件笔记十 扩大节</a>中，需要修正节表成员；修正节表成员时要把Misc（实际大小）和 SizeOfRawData（文件对齐后的大小）修正为内存对齐后的大小</p><p>但在扩大节中，只针对最后一个节进行修正，没有影响到其它的成员，接下来学习将所有节表都修正为内存对齐</p><p>此篇笔记为学习节操作之修正内存对齐</p><h1 id="修正内存对齐"><a href="#修正内存对齐" class="headerlink" title="修正内存对齐"></a>修正内存对齐</h1><h2 id="为什么要修正内存对齐"><a href="#为什么要修正内存对齐" class="headerlink" title="为什么要修正内存对齐"></a>为什么要修正内存对齐</h2><p>修正内存对齐 使得 节文件对齐后的大小和内存对齐后的大小一致，方便后续合并节</p><hr><h2 id="修正内存对齐涉及的结构体成员"><a href="#修正内存对齐涉及的结构体成员" class="headerlink" title="修正内存对齐涉及的结构体成员"></a>修正内存对齐涉及的结构体成员</h2><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Misc</td><td align="left">节的实际大小</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left">PointerToRawData</td><td align="left">节区在文件中的偏移</td></tr></tbody></table><hr><h2 id="修正内存对齐的流程"><a href="#修正内存对齐的流程" class="headerlink" title="修正内存对齐的流程"></a>修正内存对齐的流程</h2><ol><li>计算节内存对齐后的大小</li><li>计算差值 = 节内存对齐后的大小 - 节文件对齐后的大小</li><li>计算节在文件中的末尾位置 = 节在文件中的偏移 + 节文件对齐后的大小</li><li>在节的文件中的末尾位置后填充新空间，新空间的大小为 前面计算的差值</li><li>修正Misc和SizeOfRawData为节内存对齐后的大小</li><li>在该节后面的节在文件中的偏移增加差值</li></ol><hr><h2 id="按流程修正内存对齐"><a href="#按流程修正内存对齐" class="headerlink" title="按流程修正内存对齐"></a>按流程修正内存对齐</h2><p>此次依旧以先前的EverEdit.exe为例进行修正内存对齐的演示，这次选择修正倒数第二个节</p><hr><h3 id="节信息"><a href="#节信息" class="headerlink" title="节信息"></a>节信息</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406130733632.png" alt="image-20210406130733632"></p><hr><p>这里只关注最后两个节：</p><table><thead><tr><th align="left">节名称</th><th align="left">Misc</th><th align="left">SizeOfRawData</th><th align="left">PointerToRawData</th></tr></thead><tbody><tr><td align="left">.rsrc</td><td align="left">0x62008</td><td align="left">0x62200</td><td align="left">0x1dfa00</td></tr><tr><td align="left">.reloc</td><td align="left">0x1643a</td><td align="left">0x16600</td><td align="left">0x241c00</td></tr></tbody></table><hr><h3 id="计算节内存对齐后的大小"><a href="#计算节内存对齐后的大小" class="headerlink" title="计算节内存对齐后的大小"></a>计算节内存对齐后的大小</h3><p>计算节内存对齐后的大小在先前的笔记<a href="https://www.52pojie.cn/thread-1409844-1-1.html#37855398_%E4%BF%AE%E6%AD%A3%E8%8A%82%E8%A1%A8%E6%88%90%E5%91%98">PE文件笔记十 扩大节</a>中已经说明过，这里不再赘述，直接计算</p><p>节内存对齐后的大小 = ( max{Misc,SizeOfRawData} ÷ SectionAlignment)向上取整 × SectionAlignment</p><p>即节内存对齐后的大小 = ( max{0x62008,0x62200}÷0x1000)向上取整 × 0x1000</p><p>即节内存对齐后的大小 = (0x62200 ÷ 0x1000)向上取整 × 0x1000 = 0x63000</p><hr><h3 id="计算差值"><a href="#计算差值" class="headerlink" title="计算差值"></a>计算差值</h3><p>差值 = 节内存对齐后的大小 - 节文件对齐后的大小 = 节内存对齐后的大小 - SizeOfRawData</p><p>即 差值 = 0x63000 - 0x62200 = 0xE00</p><hr><h3 id="计算节在文件中的末尾位置"><a href="#计算节在文件中的末尾位置" class="headerlink" title="计算节在文件中的末尾位置"></a>计算节在文件中的末尾位置</h3><p>节在文件中的末尾位置 = 节在文件中的偏移 + 节文件对齐后的大小</p><p>即节在文件中的末尾位置 = PointerToRawData + SizeOfRawData</p><p>即节在文件中的末尾位置 = 0x1dfa00 + 0x62200 = 0x241C00</p><hr><h3 id="填充新空间"><a href="#填充新空间" class="headerlink" title="填充新空间"></a>填充新空间</h3><p>用WinHex打开EverEdit.exe，找到前面计算出来的节在文件中的末尾位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133220273.png" alt="image-20210406133220273"></p><hr><p>选中末尾后 编辑→粘贴0字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133338744.png" alt="image-20210406133338744"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133302893.png" alt="image-20210406133302893"></p><p>选择插入的大小为：0xE00(对应十进制为3584)，即插入前面计算出来的差值</p><hr><p>插入后，保存</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133416207.png" alt="image-20210406133416207"></p><hr><h3 id="修正节成员"><a href="#修正节成员" class="headerlink" title="修正节成员"></a>修正节成员</h3><p>修正Misc和SizeOfRawData为节内存对齐后的大小：0x63000</p><p>这里为了省事，直接使用PE工具：DIE进行修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133728686.png" alt="image-20210406133728686"></p><hr><p>修正后：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406133806124.png" alt="image-20210406133806124"></p><hr><h3 id="修正后面的节"><a href="#修正后面的节" class="headerlink" title="修正后面的节"></a>修正后面的节</h3><p>在该节后面的节在文件中的偏移增加差值</p><p>该节后面只有一个</p><table><thead><tr><th align="left">节名称</th><th align="left">Misc</th><th align="left">SizeOfRawData</th><th align="left">PointerToRawData</th></tr></thead><tbody><tr><td align="left">.reloc</td><td align="left">0x1643a</td><td align="left">0x16600</td><td align="left">0x241c00</td></tr></tbody></table><p>修改其PointerToRawData = PointerToRawData + 差值</p><p>即 PointerToRawData = 0x241c00 + 0xe00 = 242A00</p><p>同样使用PE工具：DIE进行修正</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406134420140.png" alt="image-20210406134420140"></p><hr><p>修改后</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406134456131.png" alt="image-20210406134456131"></p><hr><h3 id="修正前后对比"><a href="#修正前后对比" class="headerlink" title="修正前后对比"></a>修正前后对比</h3><p>执行完上一步，倒数第二个节就已经修正完了</p><p>对比一下修改前后节的信息</p><h4 id="修改前"><a href="#修改前" class="headerlink" title="修改前"></a>修改前</h4><table><thead><tr><th align="left">节名称</th><th align="left">Misc</th><th align="left">SizeOfRawData</th><th align="left">PointerToRawData</th></tr></thead><tbody><tr><td align="left">.rsrc</td><td align="left">0x62008</td><td align="left">0x62200</td><td align="left">0x1dfa00</td></tr><tr><td align="left">.reloc</td><td align="left">0x1643a</td><td align="left">0x16600</td><td align="left">0x241c00</td></tr></tbody></table><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406134727702.png" alt="image-20210406134727702"></p><h4 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h4><table><thead><tr><th align="left">节名称</th><th align="left">Misc</th><th align="left">SizeOfRawData</th><th align="left">PointerToRawData</th></tr></thead><tbody><tr><td align="left">.rsrc</td><td align="left">0x63000</td><td align="left">0x63000</td><td align="left">0x1dfa00</td></tr><tr><td align="left">.reloc</td><td align="left">0x1643a</td><td align="left">0x16600</td><td align="left">0x242a00</td></tr></tbody></table><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406134712043.png" alt="image-20210406134712043"></p><hr><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p>发现仍然能够正常运行</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404165912116.png" alt="image-20210404165912116"></p><hr><h1 id="代码实现修正内存对齐"><a href="#代码实现修正内存对齐" class="headerlink" title="代码实现修正内存对齐"></a>代码实现修正内存对齐</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//向文件中指定位置追加数据</span><br><span class="line">//第一个参数为文件路径</span><br><span class="line">//第二个参数为要追加的数据指针</span><br><span class="line">//第三个参数为要追加的数据大小</span><br><span class="line">//第四个参数为位置偏移</span><br><span class="line">//第五个参数为hMap的指针</span><br><span class="line">//第六个参数为pFile的指针</span><br><span class="line">BOOL appendFile(LPCSTR filePath, PVOID writeData, DWORD sizeOfWriteData, DWORD offset, HANDLE* phMap, PVOID* ppFile) &#123;</span><br><span class="line">    HANDLE hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    char newPath[100];</span><br><span class="line">    strcpy(newPath, filePath);</span><br><span class="line"></span><br><span class="line">    strcat(newPath, &quot;.exe&quot;);</span><br><span class="line">    HANDLE hFile2 = CreateFileA(newPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line"></span><br><span class="line">    //WriteFile用于接收实际写入的大小的参数</span><br><span class="line">    DWORD dwWritenSize = 0;</span><br><span class="line"></span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">    BYTE* content = (BYTE*)pFile;</span><br><span class="line">    content += offset;</span><br><span class="line"></span><br><span class="line">    //写入要插入数据前的数据</span><br><span class="line">    DWORD size = SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    bRet = WriteFile(hFile2, pFile, offset, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //写入要插入的数据</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    bRet = WriteFile(hFile2, writeData, sizeOfWriteData, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //写入要插入数据后的数据</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_END);</span><br><span class="line">    bRet = WriteFile(hFile2, content, size - offset, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //在删除文件前要先关闭句柄和映射</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hMap);</span><br><span class="line">    CloseHandle(*phMap);</span><br><span class="line">    UnmapViewOfFile(pFile);</span><br><span class="line">    UnmapViewOfFile(*ppFile);</span><br><span class="line">    bRet = DeleteFileA(filePath);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    hMap = CreateFileMappingA(hFile2, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    SetFilePointer(hFile, NULL, NULL, FILE_BEGIN);</span><br><span class="line">    bRet = WriteFile(hFile, pFile, sizeOfWriteData + size, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    //在删除文件前要先关闭句柄和映射</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hFile2);</span><br><span class="line">    CloseHandle(hMap);</span><br><span class="line">    UnmapViewOfFile(pFile);</span><br><span class="line">    bRet = DeleteFileA(newPath);</span><br><span class="line">    if (!bRet)return false;</span><br><span class="line">    hFile = CreateFileA(filePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    *ppFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    *phMap = hMap;</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//根据pFile获取PE文件结构</span><br><span class="line">void GetPeStruct32(LPVOID pFile, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line"></span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line"></span><br><span class="line">    //让PE文件头指针指向其对应的地址</span><br><span class="line">    nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line"></span><br><span class="line">    //创建指向块表的指针</span><br><span class="line">    _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    //让块表的指针指向其对应的地址</span><br><span class="line">    sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">    //计数，用来计算块表地址</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">    while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">        //将得到的块表指针存入数组</span><br><span class="line">        sectionArr[cnt++] = section;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修正节表的Misc和SizeOfRawData</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">//第四个参数为文件路径</span><br><span class="line">//第五个参数为文件映射</span><br><span class="line">//第六个参数为文件映射内容指针</span><br><span class="line">//第七个参数为要修正的节表在数组中的下标</span><br><span class="line">void sectionAlignment(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr, LPCSTR filePath, HANDLE* phMap,LPVOID* ppFile, int n) &#123;</span><br><span class="line"></span><br><span class="line">    //获得最后一个节的实际大小</span><br><span class="line">    DWORD VirtualSize = sectionArr[n]-&gt;Misc.VirtualSize;</span><br><span class="line">    //获得最后一个节的文件对齐后的大小</span><br><span class="line">    DWORD SizeOfRawData = sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    //计算上一个节内存对齐后的大小</span><br><span class="line">    UINT SizeInMemory = (UINT)ceil((double)max(VirtualSize, SizeOfRawData) / (double)nt-&gt;OptionalHeader.SectionAlignment) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    printf(&quot;%X\n&quot;, SizeInMemory);</span><br><span class="line">    //计算差值= 内存对齐后大小 - 文件对齐后大小</span><br><span class="line">    UINT offset = SizeInMemory - sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;%X\n&quot;, offset);</span><br><span class="line">    //根据节在文件中的偏移 + 文件对齐后的大小 得到节的末尾</span><br><span class="line">    UINT end = sectionArr[n]-&gt;PointerToRawData + sectionArr[n]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;end:%X\n&quot;, end);</span><br><span class="line"></span><br><span class="line">    //申请要填充的空间</span><br><span class="line">    INT* content = (INT*)malloc(offset);</span><br><span class="line">    //初始化为0</span><br><span class="line">    ZeroMemory(content, offset);</span><br><span class="line">    //WriteFile用于接收实际写入的大小的参数</span><br><span class="line">    DWORD dwWritenSize = 0;</span><br><span class="line"></span><br><span class="line">    BOOL bRet=appendFile(filePath, (PVOID)content, offset, end,phMap,ppFile);</span><br><span class="line">    GetPeStruct32(*ppFile, dos, nt, sectionArr);</span><br><span class="line">    if (bRet) &#123;</span><br><span class="line">        //开始修正Misc和SizeOfRawData</span><br><span class="line">        sectionArr[n]-&gt;Misc.VirtualSize = SizeInMemory;</span><br><span class="line">        sectionArr[n]-&gt;SizeOfRawData = SizeInMemory;</span><br><span class="line">        //修正后面受到影响的节的PointerOfRawData和VirtualAddress</span><br><span class="line">        int i;</span><br><span class="line">        while (n + 1 &lt;= nt-&gt;FileHeader.NumberOfSections - 1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            sectionArr[n]-&gt;PointerToRawData += offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">        int i;</span><br><span class="line">        //sectionAlignment(dos, nt, sectionArr, &quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;,hMap, pFile,2);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            sectionAlignment(dos, nt, sectionArr, &quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, &amp;hMap, &amp;pFile,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406135744307.png" alt="image-20210406135744307"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406135858359.png" alt="image-20210406135858359"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406135927238.png" alt="image-20210406135927238"></p><hr><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>这次的代码比较复杂，因为C语言没有提供<strong>对文件指定位置插入数据</strong>的函数；只能自己手动实现了一个appendFile</p><p>其实就是：</p><ol><li>把要插入数据之前的数据写出到新文件</li><li>将要插入数据写入到前面写出到文件末尾</li><li>把要插入数据之后的数据写出到文件末尾</li><li>删除原本的文件</li><li>将新文件复制为原本的文件</li><li>删除旧的文件</li></ol><hr><p>其中要注意，删除文件的时候要将先前获得的句柄和映射，即hFile，hMap，pFile关闭</p><p>关闭hFile，hMap，pFile后，需要重新获得新的PE结构，即更新dos、nt、sectionArr</p><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>修正内存对齐会影响后面的节，要修正后面的节在文件中的偏移</li><li>对文件指定位置插入数据需要自己实现</li><li>删除文件前要关闭相关的句柄和映射</li><li>这次代码实现关于PE部分其实并没有什么难点，主要麻烦在要对文件指定位置插入数据</li></ul><hr><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit%E4%BF%AE%E6%AD%A3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.zip?versionId=CAEQHhiBgIDUiqSXxRciIDljZDVkYTViNzQwMjRhNWE5YzhjMTVkZWI5ZDVhMWUx">点我下载</a></p><p>此次附件中添加了 修正完内存对齐后的exe</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210406141233875.png" alt="image-20210406141233875"></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十一 新增节</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9311/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9311/</url>
      
        <content type="html"><![CDATA[<p>前面在<a href="https://www.52pojie.cn/thread-1409844-1-1.html">PE文件笔记十 扩大节</a>学习了关于节的操作之扩大节，接下来继续学习节的操作之新增节</p><h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="为什么要新增节"><a href="#为什么要新增节" class="headerlink" title="为什么要新增节"></a>为什么要新增节</h2><p>新增节和扩大节一样，<strong>都是用来解决空白区不足的问题</strong></p><p>但既然扩大节已经能够解决问题了，为什么还要新增节呢？或者说<strong>新增节比扩大节好在哪里</strong>？</p><p>在前面的扩大节中，只是扩大了节，并没有关注扩大出来的空白区的<strong>权限问题</strong>；每个节都有其对应的权限，由节.<strong>Characteristics</strong>决定</p><p>有关节的权限问题已经在<a href="https://www.52pojie.cn/thread-1407996-1-1.html#37810231_characteristics-1">PE文件笔记六 节表和节</a>中说过，这里不再赘述</p><p>如果扩大出来的空白区希望能够被用于执行代码，那么被扩大的节就必须具备IMAGE_SCN_CNT_CODE权限(该节包含可执行代码)</p><p>如果被扩大的节不具备这个权限，还得为此将整个节的权限修改</p><p>除此之外，扩大节还会使得原本的数据和我们扩大的空白区混在一起</p><hr><p>相比之下新增节则完全拥有自己的权限，<strong>不依附于</strong>要扩大的节的权限，<strong>可以自己指定想要的权限</strong></p><hr><h3 id="扩大节和新增节的差异"><a href="#扩大节和新增节的差异" class="headerlink" title="扩大节和新增节的差异"></a>扩大节和新增节的差异</h3><p>扩大节：权限取决于要被扩大的节的原本权限，如果不满足权限还需要去修改；原本数据和扩大的空白区混在一起</p><p>新增节：权限由自己来指定；空间独立没有数据混杂</p><hr><h2 id="新增节涉及的结构体成员"><a href="#新增节涉及的结构体成员" class="headerlink" title="新增节涉及的结构体成员"></a>新增节涉及的结构体成员</h2><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Name</td><td align="left">节名称</td></tr><tr><td align="left">VirtualAddress</td><td align="left">节在内存中的偏移 （RVA）</td></tr><tr><td align="left">Misc</td><td align="left">节的实际大小</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left">PointerToRawData</td><td align="left">节区在文件中的偏移</td></tr><tr><td align="left">Characteristics</td><td align="left">节的属性</td></tr></tbody></table><table><thead><tr><th align="left">涉及的标准PE头成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">NumberOfSections</td><td align="left">节的个数</td></tr></tbody></table><table><thead><tr><th align="left">涉及的扩展PE头成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SizeOfImage</td><td align="left">Image（PE文件）大小</td></tr></tbody></table><h2 id="新增节的位置"><a href="#新增节的位置" class="headerlink" title="新增节的位置"></a>新增节的位置</h2><p>和扩大节一个道理，为了避免新增节后影响先前的节，选择在原本的最后一个节后面新增节</p><hr><h2 id="新增节的流程"><a href="#新增节的流程" class="headerlink" title="新增节的流程"></a>新增节的流程</h2><ol><li>判断是否有足够空间用于添加节表</li><li>修改标准PE头中节的数量</li><li>在节表中新增一个成员</li><li>修正SizeOfImage的大小</li><li>分配新空间</li></ol><hr><h2 id="按流程新增节"><a href="#按流程新增节" class="headerlink" title="按流程新增节"></a>按流程新增节</h2><p>此次依旧以先前的EverEdit.exe为例进行新增节的演示</p><hr><h3 id="判断是否有空间能添加节表"><a href="#判断是否有空间能添加节表" class="headerlink" title="判断是否有空间能添加节表"></a>判断是否有空间能添加节表</h3><p>用WinHex打开EverEdit.exe，找到最后一个节表，判断最后一个节表后面的40个字节（节表的大小）是否全为0</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405183220552.png" alt="image-20210405183220552"></p><p>可以看到最后一个节区后40个字节全为0，因此是可以添加节表的</p><hr><h3 id="修改标准PE头中节的数量"><a href="#修改标准PE头中节的数量" class="headerlink" title="修改标准PE头中节的数量"></a>修改标准PE头中节的数量</h3><p>之前都是使用WinHex来进行修改演示的，是为了更好地学习本质；到了现在对PE文件比较熟悉的时候，就可以用PE工具：DIE工具来代替WinHex进行修改了（看起来更直观）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405135448270.png" alt="image-20210405135448270"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405135412956.png" alt="image-20210405135412956"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405135628662.png" alt="image-20210405135628662"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405135736239.png" alt="image-20210405135736239"></p><hr><h3 id="在节表中新增一个成员"><a href="#在节表中新增一个成员" class="headerlink" title="在节表中新增一个成员"></a>在节表中新增一个成员</h3><p>回到先前PE 基本信息的地方，点击节来查看节表信息</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405135909642.png" alt="image-20210405135909642"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405140219293.png" alt="image-20210405140219293"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405140317837.png" alt="image-20210405140317837"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405140624788.png" alt="image-20210405140624788"></p><hr><h4 id="确定要修改的数值"><a href="#确定要修改的数值" class="headerlink" title="确定要修改的数值"></a>确定要修改的数值</h4><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">值</th><th align="left">要求</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Name</td><td align="left">.lyl610</td><td align="left">小于等于8位</td><td align="left">节名称</td></tr><tr><td align="left">Misc.VirtualSize</td><td align="left">0x1000</td><td align="left">要新增的节的大小</td><td align="left">节的实际大小</td></tr><tr><td align="left">VirtualAddress</td><td align="left">0x298000</td><td align="left">上一个节.VirtualAddress+上一个节内存对齐后的大小</td><td align="left">节在内存中的偏移 （RVA）</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">0x1000</td><td align="left">要新增的节的大小</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left">PointerToRawData</td><td align="left">0x258200</td><td align="left">上一个节.PointerToRawData+上一个节.SizeOfRawData</td><td align="left">节区在文件中的偏移</td></tr><tr><td align="left">Characteristics</td><td align="left">0xe0000000</td><td align="left">该节具备的权限，这里指定为节可读、可写、可执行</td><td align="left">节的属性</td></tr></tbody></table><hr><p>这里主要讲一下VirtualAddress和PointerToRawData的计算，其余的都是自己指定的</p><p>VirtualAddress：</p><p>VirtualAddress为该节在内存中的偏移 = 上一个节.VirtualAddress+上一个节内存对齐后的大小 = 0x281000 + 0x17000 = 0x298000</p><p>关于节内存对齐后的大小如何计算在<a href="https://www.52pojie.cn/thread-1409844-1-1.html#37855398_%E4%BF%AE%E6%AD%A3%E8%8A%82%E8%A1%A8%E6%88%90%E5%91%98">PE文件笔记十 扩大节</a>中已经说明，这里也就不再赘述</p><hr><p>PointerToRawData：</p><p>PointerToRawData为该节在文件中的偏移 = 上一个节在文件中的偏移 + 上一个节文件对齐后的大小</p><p>即PointerToRawData = 上一个节.PointerToRawData + 上一个节.SizeOfRawData = 0x241c00+0x16600=0x258200</p><hr><h4 id="填充要修改的数值"><a href="#填充要修改的数值" class="headerlink" title="填充要修改的数值"></a>填充要修改的数值</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405143548960.png" alt="image-20210405143548960"></p><hr><h3 id="修正SizeOfImage的大小"><a href="#修正SizeOfImage的大小" class="headerlink" title="修正SizeOfImage的大小"></a>修正SizeOfImage的大小</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405143951801.png" alt="image-20210405143951801"></p><hr><p>这里将SizeOfImage增加0x1000（与前面新增节中的Misc.VirtualSize和SizeOfRawData对应）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405144125519.png" alt="image-20210405144125519"></p><hr><h3 id="分配新空间"><a href="#分配新空间" class="headerlink" title="分配新空间"></a>分配新空间</h3><p>分配新空间还是得交给WinHex，步骤和扩大节中的分配新空间没什么不同o(<em>￣▽￣</em>)ブ</p><p>使用WinHex打开EverEdit，直接拉到文件的末尾，并<strong>选中</strong>最后一个字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142328069.png" alt="image-20210404142328069"></p><hr><p>然后 编辑→粘贴0字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142524635.png" alt="image-20210404142524635"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142611679.png" alt="image-20210404142611679"></p><p>按”是”</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405144551356.png" alt="image-20210405144551356"></p><p>选择插入的大小为：0x1000（与前面新增节中的Misc.VirtualSize和SizeOfRawData对应），对应十进制为4096</p><hr><p>添加完成</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404143121957.png" alt="image-20210404143121957"></p><h3 id="保存测试"><a href="#保存测试" class="headerlink" title="保存测试"></a>保存测试</h3><p>将文件保存后再打开，发现仍然能够正常运行</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404165912116.png" alt="image-20210404165912116"></p><hr><h1 id="代码实现新增节"><a href="#代码实现新增节" class="headerlink" title="代码实现新增节"></a>代码实现新增节</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//新增一个节</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">//第四个参数为文件句柄</span><br><span class="line">//第五个参数为要新增的节的大小</span><br><span class="line">//第六个参数为新增节的名称</span><br><span class="line">//第七个参数为新增节的权限</span><br><span class="line">void addSection(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr, HANDLE hFile, UINT addSize, BYTE Name[IMAGE_SIZEOF_SHORT_NAME], DWORD Characteristics) &#123;</span><br><span class="line"></span><br><span class="line">    //判断最后一个节表的后40个字节是否全为0</span><br><span class="line"></span><br><span class="line">    //通过最后一个节表+节表大小 到达新节表</span><br><span class="line">    _IMAGE_SECTION_HEADER* newSection = (_IMAGE_SECTION_HEADER*)((UINT)§ionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;Name + sizeof(_IMAGE_SECTION_HEADER));</span><br><span class="line">    //判断新节表是否有被填充</span><br><span class="line">    UINT* tmp = (UINT*)newSection;</span><br><span class="line">    int i;</span><br><span class="line">    //标志 判断新节表是否全为0</span><br><span class="line">    BOOL flag = false;</span><br><span class="line">    for (i = 0; i &lt; sizeof(_IMAGE_SECTION_HEADER) / sizeof(INT); i++) &#123;</span><br><span class="line">        if (*tmp != 0) &#123;</span><br><span class="line">            flag = true;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        printf(&quot;空间不足,无法新增节\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Name赋值</span><br><span class="line">    for (i = 0; i &lt; IMAGE_SIZEOF_SHORT_NAME; i++) &#123;</span><br><span class="line">        newSection-&gt;Name[i] = Name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //大小赋值</span><br><span class="line">    newSection-&gt;Misc.VirtualSize = addSize;</span><br><span class="line">    newSection-&gt;SizeOfRawData = addSize;</span><br><span class="line">    //权限赋值</span><br><span class="line">    newSection-&gt;Characteristics = Characteristics;</span><br><span class="line"></span><br><span class="line">    //获得最后一个节的实际大小</span><br><span class="line">    DWORD VirtualSize = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;Misc.VirtualSize;</span><br><span class="line">    //获得最后一个节的文件对齐后的大小</span><br><span class="line">    DWORD SizeOfRawData = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">    //计算上一个节内存对齐后的大小</span><br><span class="line">    UINT SizeInMemory = (UINT)ceil((double)max(VirtualSize, SizeOfRawData) / double(nt-&gt;OptionalHeader.SectionAlignment)) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    //RVA赋值</span><br><span class="line">    newSection-&gt;VirtualAddress = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;VirtualAddress + SizeInMemory;</span><br><span class="line">    printf(&quot;newSection-&gt;VirtualAddress:%X\n&quot;, newSection-&gt;VirtualAddress);</span><br><span class="line">    //FOA赋值</span><br><span class="line">    newSection-&gt;PointerToRawData = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;PointerToRawData + sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;newSection-&gt;PointerToRawData:%X\n&quot;, newSection-&gt;PointerToRawData);</span><br><span class="line"></span><br><span class="line">    //分配新空间</span><br><span class="line">    //根据节在文件中的偏移 + 文件对齐后的大小 得到节的末尾</span><br><span class="line">    UINT end = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;PointerToRawData + sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">    printf(&quot;end:%X\n&quot;, end);</span><br><span class="line">    //设置要写入的地址为节末尾</span><br><span class="line">    SetFilePointer(hFile, end, NULL, FILE_BEGIN);</span><br><span class="line">    //申请要填充的空间</span><br><span class="line">    INT* content = (INT*)malloc(addSize);</span><br><span class="line">    //初始化为0</span><br><span class="line">    ZeroMemory(content, addSize);</span><br><span class="line">    DWORD dwWritenSize = 0;</span><br><span class="line">    BOOL bRet = WriteFile(hFile, content, addSize, &amp;dwWritenSize, NULL);</span><br><span class="line">    if (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        //修改标准PE头中节的数量</span><br><span class="line">        nt-&gt;FileHeader.NumberOfSections += 1;</span><br><span class="line">        //修正SizeOfImage大小</span><br><span class="line">        nt-&gt;OptionalHeader.SizeOfImage += addSize;</span><br><span class="line">        printf(&quot;add Section success!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;分配新空间失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\sixonezero\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BYTE Name[IMAGE_SIZEOF_SHORT_NAME] = &quot;.lyl610&quot;;</span><br><span class="line">        addSection(dos, nt, sectionArr, hFile, 0x1000, Name, 0xe0000000);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405183729979.png" alt="image-20210405183729979"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405160726667.png" alt="image-20210405160726667"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210405160800314.png" alt="image-20210405160800314"></p><p>可以看到代码执行以后，结果和前面手动操作一致，并且程序仍然能够正常运行( •̀ ω •́ )✧</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>新增节的好处就是可以自己<strong>指定想要的权限</strong>，代码更加具有<strong>独立性</strong></li><li>无论是新增节还是扩大节都要注意文件对齐和内存对齐；分配的新空间大小<strong>最好为内存对齐的整数倍</strong></li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一个<a href="https://www.52pojie.cn/thread-1410348-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记十 扩大节</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%9310/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%9310/</url>
      
        <content type="html"><![CDATA[<p>经过前面的实战<a href="https://www.52pojie.cn/thread-1408866-1-1.html">PE文件笔记八 实战之HOOK程序添加弹窗</a>和<a href="https://www.52pojie.cn/thread-1409183-1-1.html">PE文件笔记九 实战之HOOK程序添加弹窗续</a>，对PE文件结构有了进一步的了解之后继续来学习对节的操作</p><p>此篇笔记为学习节操作之扩大节</p><h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><h2 id="为什么要扩大节"><a href="#为什么要扩大节" class="headerlink" title="为什么要扩大节"></a>为什么要扩大节</h2><p>在先前的实战中，通过在节表和节之间的空白区写入代码并执行来达到了弹窗的效果，但是如果当想要执行的代码量较大时，即空白区的空间不够时，就可以通过扩大节来解决空白区不足的问题</p><hr><h2 id="扩大节涉及的结构体成员"><a href="#扩大节涉及的结构体成员" class="headerlink" title="扩大节涉及的结构体成员"></a>扩大节涉及的结构体成员</h2><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">VirtualAddress</td><td align="left">节在内存中的偏移 （RVA）</td></tr><tr><td align="left">Misc</td><td align="left">节的实际大小</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left">PointerToRawData</td><td align="left">节区在文件中的偏移</td></tr></tbody></table><table><thead><tr><th align="left">涉及的扩展PE头成员</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SizeOfImage</td><td align="left">Image（PE文件）大小</td></tr></tbody></table><h2 id="扩大哪个节"><a href="#扩大哪个节" class="headerlink" title="扩大哪个节"></a>扩大哪个节</h2><p>既然要扩大节，那么选择哪个节进行扩大比较好？</p><p>实际上每个节都可以扩大，但是一般来说是<strong>选取最后一个节</strong>进行扩大，为什么？</p><p>因为节是顺序存储的，如果扩大了前面的节就意味着后面的节全部都要相应地修改偏移，比较麻烦</p><p>选取最后一个节进行扩大就不会影响到后面的节了</p><hr><h2 id="扩大节流程"><a href="#扩大节流程" class="headerlink" title="扩大节流程"></a>扩大节流程</h2><ol><li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li><li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li><li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li></ol><hr><h2 id="按流程扩大节"><a href="#按流程扩大节" class="headerlink" title="按流程扩大节"></a>按流程扩大节</h2><p>此次依旧以先前的EverEdit.exe为例进行扩大节的演示</p><hr><h3 id="修正节表成员"><a href="#修正节表成员" class="headerlink" title="修正节表成员"></a>修正节表成员</h3><p>由于选择的是最后一个节进行扩大，于是不涉及VirtualAddress和PointerToRawData的修改，只需修改Misc和SizeOfRawData即可</p><p>先用PE工具DIE查看一下最后一个节的成员</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404143559979.png" alt="image-20210404143559979"></p><hr><p>得到了</p><table><thead><tr><th align="left">涉及的节表成员</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Misc</td><td align="left">0x1643a</td><td align="left">节的实际大小</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">0x16600</td><td align="left">节在文件中对齐后的尺寸</td></tr></tbody></table><hr><p>于是可以计算出在节内存对齐后的大小：</p><p>节内存对齐后大小 = (max{Misc,SizeOfRawData}÷SectionAlignment)向上取整 × SectionAlignment</p><p>即节内存对齐后大小 (= max{0x1643a,0x16600}÷0x1000)向上取整 × 0x1000 =(0x16600÷0x1000)向上取整 × 0x1000 = 0x17000</p><p>计算 节内存对齐后大小的原理在<a href="https://www.52pojie.cn/thread-1407996-1-1.html#37810231_misc%E5%92%8Csizeofrawdata">PE文件笔记六 节表和节</a>中已经说明，这里不再赘述</p><p>得到的节内存对齐后的大小后再加上<strong>要扩大的大小</strong>：0x1000，即 0x17000+0x1000=0x18000</p><p>于是要将Misc和SizeOfRawData都修改为0x00018000</p><p>此时<strong>节内存对齐增加的大小</strong> = 节内存对齐后大小 - SizeOfRawData(节文件对齐后的大小)</p><p>即<strong>节内存对齐增加的大小</strong> = 0x17000 - 0x16600 = 0x17000 - 0x16600 =0xA00</p><hr><p>用WinHex找到对应的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404145300114.png" alt="image-20210404145300114"></p><hr><p>修改数据，注意小端存储</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404145501154.png" alt="image-20210404145501154"></p><hr><h3 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h3><p>用PE工具：DIE查看一下扩展PE头中SizeOfImage</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404151207557.png" alt="image-20210404151207557"></p><hr><p>得到原本SizeOfImage的大小为0x00298000</p><p>要修改为 原本大小+扩大的大小= 0x00298000 + 0x1000 = 0x00299000</p><p>在WinHex中找到SizeOfImage对应的位置</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404151453133.png" alt="image-20210404151453133"></p><hr><p>修改为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404151523726.png" alt="image-20210404151523726"></p><hr><h3 id="分配新空间"><a href="#分配新空间" class="headerlink" title="分配新空间"></a>分配新空间</h3><p>使用WinHex打开EverEdit，直接拉到文件的末尾，并<strong>选中</strong>最后一个字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142328069.png" alt="image-20210404142328069"></p><hr><p>然后 编辑→粘贴0字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142524635.png" alt="image-20210404142524635"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404142611679.png" alt="image-20210404142611679"></p><p>按”是”</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404165636553.png" alt="image-20210404165636553"></p><p>选择插入的大小为：节内存对齐增加的大小 + 要扩大的大小 = 0xA00 + 0x1000=0x1A00 对应十进制为6656</p><hr><p>添加完成</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404143121957.png" alt="image-20210404143121957"></p><h3 id="保存测试"><a href="#保存测试" class="headerlink" title="保存测试"></a>保存测试</h3><p>将文件保存后再打开，发现仍然能够正常运行</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404165912116.png" alt="image-20210404165912116"></p><hr><h1 id="代码实现扩大节"><a href="#代码实现扩大节" class="headerlink" title="代码实现扩大节"></a>代码实现扩大节</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//扩大最后一个节</span><br><span class="line">//第一个参数为指向dos头的指针</span><br><span class="line">//第二个参数为指向nt头的指针</span><br><span class="line">//第三个参数为存储指向节指针的数组</span><br><span class="line">//第四个参数为文件句柄</span><br><span class="line">//第五个参数为要扩大的节的大小</span><br><span class="line">void expandSection(_IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr, HANDLE hFile, UINT expandSize) &#123;</span><br><span class="line">        //获得最后一个节的实际大小</span><br><span class="line">        DWORD VirtualSize = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;Misc.VirtualSize;</span><br><span class="line">        //获得最后一个节的文件对齐后的大小</span><br><span class="line">        DWORD SizeOfRawData = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">        //算出最后一个节内存对齐后的大小</span><br><span class="line">        UINT SizeInMemory = (UINT)ceil((double)max(VirtualSize, SizeOfRawData) / double(nt-&gt;OptionalHeader.SectionAlignment)) * nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">        printf(&quot;Last Section SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">        //根据内存对齐后大小 - 文件对齐后大小 得到 节内存对齐增加的大小</span><br><span class="line">        UINT offset = SizeInMemory - sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">        printf(&quot;offset:%X\n&quot;, offset);</span><br><span class="line">        //根据节在文件中的偏移 + 文件对齐后的大小 得到节的末尾</span><br><span class="line">        UINT end = sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;PointerToRawData + sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData;</span><br><span class="line">        printf(&quot;end:%X\n&quot;, end);</span><br><span class="line">        //根据要扩大的节的大小 + 节内存对齐增加的大小 得到 要分配的新空间大小</span><br><span class="line">        UINT size = offset + expandSize;</span><br><span class="line">        //设置要写入的地址为节末尾</span><br><span class="line">        SetFilePointer(hFile, end, NULL, FILE_BEGIN);</span><br><span class="line">        //申请要填充的空间</span><br><span class="line">        INT* content = (INT*)malloc(expandSize + offset);</span><br><span class="line">        //初始化为0</span><br><span class="line">        ZeroMemory(content, expandSize + offset);</span><br><span class="line">        //WriteFile用于接收实际写入的大小的参数</span><br><span class="line">        DWORD dwWritenSize = 0;</span><br><span class="line">        BOOL bRet = WriteFile(hFile, content, expandSize + offset, &amp;dwWritenSize, NULL);</span><br><span class="line">        if (bRet)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;expand Section success!\n&quot;);</span><br><span class="line">                //修正节表成员</span><br><span class="line">                sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;Misc.VirtualSize = SizeInMemory + expandSize;</span><br><span class="line">                sectionArr[nt-&gt;FileHeader.NumberOfSections - 1]-&gt;SizeOfRawData = SizeInMemory + expandSize;</span><br><span class="line">                //修正SizeOfImage</span><br><span class="line">                nt-&gt;OptionalHeader.SizeOfImage += expandSize;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;, GetLastError());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                expandSection(dos, nt, sectionArr, hFile, 0x1000);</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">                //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">                //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">                _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">                //创建指向块表的指针</span><br><span class="line">                _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">                //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">                sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">                //计数，用来计算块表地址</span><br><span class="line">                int cnt = 0;</span><br><span class="line">                //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">                while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">                        //创建指向块表的指针</span><br><span class="line">                        _IMAGE_SECTION_HEADER* section;</span><br><span class="line">                        //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">                        section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">                        //将得到的块表指针存入数组</span><br><span class="line">                        sectionArr[cnt++] = section;</span><br><span class="line">                        //输出块表名称</span><br><span class="line">                        printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404230033412.png" alt="image-20210404230033412"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404230108320.png" alt="image-20210404230108320"></p><hr><p>可以看到代码执行以后，达到了和前面手动操作一样的效果，并且程序仍然能够正常运行( •̀ ω •́ )✧</p><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>代码中修改了先前打开文件的权限，修改其拥有写权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码 隐藏代码//读取文件，返回文件句柄</span><br><span class="line">       HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\EverEdit\\EverEdit.exe&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">       //根据文件句柄创建映射</span><br><span class="line">       HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, 0, 0);</span><br><span class="line">       //映射内容</span><br><span class="line">       LPVOID pFile = MapViewOfFile(hMap, FILE_SHARE_WRITE, 0, 0, 0);</span><br></pre></td></tr></table></figure><hr><p>在扩大节的相关代码中用到了WriteFile和SetFilePointer；其它的就是单纯的PE内容了，代码中都有注释，这里也就不再赘述了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>扩大节一般选取最后一个节进行扩大</li><li>扩大最后一个节需要修正的节表成员：Misc和SizeOfRawData 以及修正扩展PE头中的SizeOfImage</li><li>扩大节后要分配的空间除了要扩大的大小外还要加上<strong>节内存对齐增加的大小</strong>(内存对齐后的大小-文件对齐后的大小)</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1409844-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记九 实战之HOOK程序添加弹窗续</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%939/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%939/</url>
      
        <content type="html"><![CDATA[<p>在前面的<a href="https://www.52pojie.cn/thread-1408866-1-1.html">PE文件笔记八 实战之HOOK程序添加弹窗</a>中能够使用OD达到在运行态时添加弹窗的功能，接下来则要对先前的反汇编的硬编码稍作修改然后插入到PE文件中，最后再修改入口点即可；具体流程在上个笔记已经说明了，这里不再赘述</p><h1 id="PE实战之给程序添加弹窗续"><a href="#PE实战之给程序添加弹窗续" class="headerlink" title="PE实战之给程序添加弹窗续"></a>PE实战之给程序添加弹窗续</h1><h2 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h2><p>先看一下最终的效果图</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/%E5%BC%B9%E7%AA%97.gif" alt="弹窗"></p><hr><h2 id="反汇编和硬编码的对应关系"><a href="#反汇编和硬编码的对应关系" class="headerlink" title="反汇编和硬编码的对应关系"></a>反汇编和硬编码的对应关系</h2><p>因为后面要将反汇编代码转换为硬编码，于是这里就要研究一下两者的对应关系</p><p>先贴上先前得到的反汇编代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码00401130 &gt;    6A 00         push 0x0</span><br><span class="line">00401132      68 52114000   push MessageB.00401152</span><br><span class="line">00401137      68 48114000   push MessageB.00401148</span><br><span class="line">0040113C      6A 00         push 0x0</span><br><span class="line">0040113E      E8 A7F69477   call user32.MessageBoxA</span><br><span class="line">00401143    - E9 8801C4FF   jmp 000412D0</span><br><span class="line">00401148      6c            db 6c</span><br><span class="line">........</span><br></pre></td></tr></table></figure><hr><h3 id="push对应硬编码"><a href="#push对应硬编码" class="headerlink" title="push对应硬编码"></a>push对应硬编码</h3><p>压入的第一个和第四个参数是一个<strong>立即数</strong>0，于是它对应的硬编码固定为6A 00</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码00401130 &gt;    6A 00         push 0x0</span><br><span class="line">0040113C      6A 00         push 0x0</span><br></pre></td></tr></table></figure><p>前面的6A是固定的，表示压入一个立即数，</p><p>后面的字节码表示压入的立即数，该立即数 的范围是0～0x7F即0~127</p><p>当立即数大于0x7F后硬编码和其含义就都改变了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码6A 7F         push 0x7F</span><br><span class="line">68 80000000   push 0x80</span><br></pre></td></tr></table></figure><p>于是得到了<strong>push 立即数 对应的硬编码为6A 立即数</strong></p><hr><p>压入的第二个和第三个参数是<strong>内存地址</strong>0x00401152中存储的数据和0x00401148中存储的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码00401132      68 52114000   push MessageB.00401152</span><br><span class="line">00401137      68 48114000   push MessageB.00401148</span><br></pre></td></tr></table></figure><p>观察硬编码和压入的地址的关系</p><p>前面的68是固定的，表示push 一个内存地址</p><p>后面的则是要push的内存地址的小端存储，倒过来看就是压入的内存地址了</p><p>举个例子，如果push 的内存地址为0x12345678</p><p>则其对应的硬编码为 68 78 56 34 12</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">68 78563412   push 0x12345678</span><br></pre></td></tr></table></figure><p>于是得到了<strong>push 内存地址 对应的硬编码为 68 内存地址的小端存储</strong></p><hr><h3 id="call对应硬编码"><a href="#call对应硬编码" class="headerlink" title="call对应硬编码"></a>call对应硬编码</h3><p>接下来就是调用MessageBoxA了，其形式为：call MessageBoxA对应的<strong>内存地址</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码0040113E      E8 A7F69477   call user32.MessageBoxA</span><br><span class="line">上面为OD的反汇编引擎为方便我们观看，而显示的内容，下面才是实际的反汇编代码</span><br><span class="line">0040113E      E8 A7F69477   call 77D507EA</span><br></pre></td></tr></table></figure><p>分析call 内存地址 和 硬编码的关系</p><p>前面的E8是固定的，表示<strong>直接</strong>调用一个内存地址</p><p>后面的则是偏移，该偏移为小端存储，此时值为：0x7794F6A7</p><p>不难发现这个<strong>偏移 = call的内存地址 - 当前的内存地址 - 当前指令的总长度</strong></p><p>即 0x7794F6A7 = 0x77D507EA - 0x0040113E - 5</p><p>再举个例子，如果当前要跳转的内存地址为0x12345678</p><p>则其对应的 偏移 = 0x12345678 - 0040113E - 5 = 11F44535</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">0040113E      E8 3545F411   call 12345678</span><br></pre></td></tr></table></figure><p>于是得到了<strong>call 内存地址 对应的硬编码为 E8 偏移的小端存储，其中偏移 = 要调用的内存地址 - 当前的内存地址 - 当前指令的总长度</strong></p><hr><h3 id="jmp对应硬编码"><a href="#jmp对应硬编码" class="headerlink" title="jmp对应硬编码"></a>jmp对应硬编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">00401143    - E9 8801C4FF   jmp 000412D0</span><br></pre></td></tr></table></figure><p>前面的E9是固定的，表示跳转到一个内存地址</p><p>后面的也是偏移，该偏移为小端存储，此时值为：0xFFC40188</p><p>偏移 = jmp的内存地址 - 当前的内存地址 - 当前指令总长度</p><p>即 0xFFC40188 = 0x000412D0 - 0x00401143 - 5</p><p>于是得到了<strong>jmp 内存地址 对应的硬编码为 E9 偏移的小端存储，其中偏移 = 要跳转的内存地址 - 当前的内存地址 - 当前指令总长度</strong></p><h2 id="寻找空白区"><a href="#寻找空白区" class="headerlink" title="寻找空白区"></a>寻找空白区</h2><p>知道了硬编码如何构造以后，就要在PE文件中找一块空白区，向里面写入要执行的硬编码</p><p>有了先前<a href="https://www.52pojie.cn/thread-1393291-1-1.html">PE文件笔记二 PE文件的两种状态</a>的知识，可以知道由于文件对齐，在块表和块之间是存在空隙(空白区)的，于是可以向这块区域写入硬编码</p><p>这次用来演示的软件是前面经常出场的EverEdit.exe，直接找到其对应的空白区：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403135440893.png" alt="image-20210403135440893"></p><hr><h2 id="构造硬编码"><a href="#构造硬编码" class="headerlink" title="构造硬编码"></a>构造硬编码</h2><p>找到空白区的地址为0x2B0，注意此时的地址为文件中的状态</p><p>在内存中其对应的地址为ImageBase+0x2B0 = 0x00400000+0x2B0 = 0x004002B0</p><p>PS：如果选取的空白区为块中的空白区，则需要进行FOA到VA的转换，相关内容在<a href="https://www.52pojie.cn/thread-1408576-1-1.html">PE文件笔记七 RVA与FOA转换</a>已说明，这里不再赘述</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403141604370.png" alt="image-20210403141604370"></p><hr><p>于是从这里开始构造硬编码</p><p>根据前面反汇编一行一行来构造硬编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码00401130 &gt;    6A 00         push 0x0</span><br><span class="line">00401132      68 52114000   push MessageB.00401152</span><br><span class="line">00401137      68 48114000   push MessageB.00401148</span><br><span class="line">0040113C      6A 00         push 0x0</span><br><span class="line">0040113E      E8 A7F69477   call user32.MessageBoxA</span><br><span class="line">00401143    - E9 8801C4FF   jmp 000412D0</span><br><span class="line">00401148      6c            db 6c</span><br></pre></td></tr></table></figure><hr><h3 id="push-参数"><a href="#push-参数" class="headerlink" title="push 参数"></a>push 参数</h3><p>1.push 0 直接用6A 00填充，无需修改</p><p>2.push 内存地址，该内存地址存储第二个参数”tips”，因为内存地址尚未填充，先用00代替，为 68 00 00 00 00</p><p>3.push 内存地址，该内存地址存储第三个参数”lyl610abc”，同样先用00代替，为 68 00 00 00 00</p><p>4.push 0 直接用6A 00填充，无需修改</p><p>于是得到的硬编码为：6A 00 68 00 00 00 00 68 00 00 00 00 6A 00，将其写入文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">6A00680000000068000000006A00</span><br></pre></td></tr></table></figure><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403142658934.png" alt="image-20210403142658934"></p><hr><h3 id="call-MessageBoxA"><a href="#call-MessageBoxA" class="headerlink" title="call MessageBoxA"></a>call MessageBoxA</h3><p>call 内存地址，要call的内存地址为MessageBoxA对应的地址，在本机中为0x77D507EA</p><p>此时的内存地址为ImageBase+0x2BE= 0x004002BE</p><p>于是可以算出 偏移 = 要跳转的地址 - 内存地址 - 当前指令总长度 = 0x77D507EA - 0x004002BE -5 = 0x77950527</p><p>于是得到的硬编码为 E8 27 05 95 77，将其写入文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">E827059577</span><br></pre></td></tr></table></figure><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403143107638.png" alt="image-20210403143107638"></p><hr><h3 id="jmp-程序入口点"><a href="#jmp-程序入口点" class="headerlink" title="jmp 程序入口点"></a>jmp 程序入口点</h3><p>所谓的程序入口点就是 扩展PE头中的AddressOfEntryPoint + ImageBase得到的内存地址</p><p>在先前的<a href="https://www.52pojie.cn/thread-1405930-1-1.html#37759493_addressofentrypoint">PE文件笔记五 PE文件头之扩展PE头</a>中其实已经看过了，这里再用PE工具：Detect It Easy查看一下：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403143747806.png" alt="image-20210403143747806"></p><hr><p>可以得到AddressOfEntryPoint 为0x16AF12，加上ImageBase得到0x56AF12</p><p>于是要跳转的地址就是0x56AF12，对应汇编为 jmp 0x56AF12</p><p>此时的内存地址为ImageBase+0x2C3 = 0x004002C3</p><p>偏移 = 要跳转的地址 - 此时的内存地址 - 当前指令的总长度 = 0x56AF12 - 0x004002C3 - 5 = 0x0016AC4A</p><p>于是得到对应的硬编码为 E9 4A AC 16 00，将其写入文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">E94AAC1600</span><br></pre></td></tr></table></figure><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403144457310.png" alt="image-20210403144457310"></p><hr><p>填充字符串ASCII码</p><table><thead><tr><th align="left">参数</th><th align="left">含义</th><th align="left">字符串</th><th align="left">ASCII</th><th align="left">文件中起始地址</th><th align="left">内存中起始地址</th></tr></thead><tbody><tr><td align="left">第三个参数</td><td align="left">窗口内容</td><td align="left">lyl610abc</td><td align="left">6C796C36313061626300</td><td align="left">2C8</td><td align="left">004002C8</td></tr><tr><td align="left">第二个参数</td><td align="left">窗口标题</td><td align="left">tips</td><td align="left">7469707300</td><td align="left">2D2</td><td align="left">004002D2</td></tr></tbody></table><p>填充完如下：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403150527290.png" alt="image-20210403150527290"></p><hr><h3 id="修正参数"><a href="#修正参数" class="headerlink" title="修正参数"></a>修正参数</h3><p>填充完字符串就可以修正参数了</p><p>第二个参数 为 push 0x004002D2，对应”tips”，对应硬编码为68 D2 02 40 00</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">68D2024000</span><br></pre></td></tr></table></figure><p>第三个参数为 push 0x004002C8，对应”lyl610abc”，对应硬编码为68 C8 02 40 00</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">68C8024000</span><br></pre></td></tr></table></figure><p>修正完的结果为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403150921982.png" alt="image-20210403150921982"></p><hr><h3 id="所有的硬编码"><a href="#所有的硬编码" class="headerlink" title="所有的硬编码"></a>所有的硬编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">6A0068D202400068C80240006A00E827059577E94AAC16006C796C363130616263007469707300</span><br></pre></td></tr></table></figure><hr><h2 id="修改程序入口点"><a href="#修改程序入口点" class="headerlink" title="修改程序入口点"></a>修改程序入口点</h2><p>构造完硬编码后，只要将程序入口点改为硬编码的首地址：0x2B0即可</p><h3 id="找到原本的程序入口点"><a href="#找到原本的程序入口点" class="headerlink" title="找到原本的程序入口点"></a>找到原本的程序入口点</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403151245859.png" alt="image-20210403151245859"></p><hr><h3 id="修改程序入口点-1"><a href="#修改程序入口点-1" class="headerlink" title="修改程序入口点"></a>修改程序入口点</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403151407916.png" alt="image-20210403151407916"></p><hr><h2 id="保存程序并测试运行"><a href="#保存程序并测试运行" class="headerlink" title="保存程序并测试运行"></a>保存程序并测试运行</h2><p>最后便是将程序保存，然后打开</p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>我这里另存为了EverEdit2.exe</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403151545013.png" alt="image-20210403151545013"></p><hr><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/%E5%BC%B9%E7%AA%97.gif" alt="弹窗"></p><p>可以看到能够成功地为程序添加弹窗，完毕(～￣▽￣)～</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>测试的系统<strong>务必为32位的XP系统</strong>，在高版本的系统有<strong>DEP和ASLR</strong>等<strong>保护机制</strong>，使用以上方法修改后<strong>无法运行</strong></p><p>上面的MessageBoxA的地址是<strong>用OD获取的</strong>，具体方法见上一篇笔记，如果想要复现为程序添加弹窗，则<strong>要修改对应的MessageBoxA的地址</strong></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中要修改的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记八 实战之HOOK程序添加弹窗</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%938/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%938/</url>
      
        <content type="html"><![CDATA[<p>前面学习了PE的结构后，尝试结合先前所学，修改PE文件来实现给程序添加弹窗的功能</p><p>PS：这篇笔记并<strong>没有怎么涉及PE的知识点</strong>，重点放在了<strong>HOOK、反汇编和硬编码</strong>上，对PE不是很了解也可以看看，涉及PE知识点的内容放在了后面的笔记：<a href="https://www.52pojie.cn/thread-1409183-1-1.html">PE文件笔记九 实战之HOOK程序添加弹窗续</a>，可以放心食用（￣︶￣）↗　</p><h1 id="PE实战之给程序添加弹窗"><a href="#PE实战之给程序添加弹窗" class="headerlink" title="PE实战之给程序添加弹窗"></a>PE实战之给程序添加弹窗</h1><h2 id="修改流程"><a href="#修改流程" class="headerlink" title="修改流程"></a>修改流程</h2><p>要给程序添加弹窗，首先就是要了解其修改的流程</p><p>首先要修改的便是程序原本的入口地址，将其修改为弹窗代码所在的地址</p><p>弹窗代码所在的地址，要在PE文件中找到一片区域，该区域需要 满足 可执行、可读、可写的权限，然后在这片区域写入弹窗代码，弹窗代码的最后要<strong>跳转回</strong>原本的入口地址</p><hr><p>该修改流程是一种十分经典的HOOK思想，即程序按照原本的流程执行着，你把它原本执行的代码修改了，修改去干我们想要做的事情，做完我们想要的事情后再把它放回去继续执行原本的代码</p><hr><h2 id="图解HOOK修改流程"><a href="#图解HOOK修改流程" class="headerlink" title="图解HOOK修改流程"></a>图解HOOK修改流程</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403010059279.png" alt="image-20210403010059279"></p><p>被HOOK的地方为B</p><p>正常流程 A→B→C</p><p>HOOK流程 A→被HOOK的B→自己的代码→复原B中被修改的部分→跳转回B原本要接着执行的地方→C</p><hr><h2 id="图解给程序添加弹窗"><a href="#图解给程序添加弹窗" class="headerlink" title="图解给程序添加弹窗"></a>图解给程序添加弹窗</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403010119501.png" alt="image-20210403010119501"></p><hr><h2 id="弹窗代码"><a href="#弹窗代码" class="headerlink" title="弹窗代码"></a>弹窗代码</h2><p>既然要给程序添加弹窗，自然需要知道如何通过代码显示一个简单的弹窗</p><p>下面给出一个简单的弹窗代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;Windows.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //调用MessageBoxA函数</span><br><span class="line">    //显示一个 没有所有者窗口的、内容为lyl610abc的、标题为tips的、只包含一个按钮:OK的 窗口</span><br><span class="line">    MessageBoxA(0, &quot;lyl610abc&quot;, &quot;tips&quot;, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402190334225.png" alt="image-20210402190334225"></p><hr><h2 id="MessageBoxA"><a href="#MessageBoxA" class="headerlink" title="MessageBoxA"></a>MessageBoxA</h2><p>下面为介绍MessageBoxA的使用文档，<strong>熟悉MessageBoxA的可以跳过</strong>，直接跳到后面的<strong>查看反汇编</strong>即可</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码int MessageBoxA(</span><br><span class="line">  HWND   hWnd,</span><br><span class="line">  LPCSTR lpText,</span><br><span class="line">  LPCSTR lpCaption,</span><br><span class="line">  UINT   uType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th align="left">参数</th><th align="left">参数类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">hWnd</td><td align="left">HWND(int)</td><td align="left">要创建的消息框的所有者窗口的句柄。如果该参数为空，则消息框没有所有者窗口</td></tr><tr><td align="left">lpText</td><td align="left">LPCSTR(CONST CHAR *)</td><td align="left">要显示的消息。如果字符串包含多行，可以在每行之间使用回车符和/或换行符来分隔行</td></tr><tr><td align="left">lpCaption</td><td align="left">LPCSTR(CONST CHAR *)</td><td align="left">对话框的标题。如果该参数为空，则默认标题为Error</td></tr><tr><td align="left">uType</td><td align="left">UINT(unsigned int)</td><td align="left">对话框的内容和行为</td></tr></tbody></table><h4 id="uType"><a href="#uType" class="headerlink" title="uType"></a>uType</h4><p>对话框的内容和行为。该参数可以是下列标志组中的标志的<strong>组合</strong></p><p>要指示消息框中显示的按钮，请指定以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MB_ABORTRETRYIGNORE</td><td align="left">0x00000002L</td><td align="left">消息框包含三个按钮:中止、重试和忽略</td></tr><tr><td align="left">MB_CANCELTRYCONTINUE</td><td align="left">0x00000006L</td><td align="left">消息框包含三个按钮:取消、重试、继续。使用此消息框类型而不是MB_ABORTRETRYIGNORE</td></tr><tr><td align="left">MB_HELP</td><td align="left">0x00004000L</td><td align="left">将“帮助”按钮添加到消息框。当用户单击帮助按钮或按下F1时，系统将向所有者发送一条WM_HELP消息</td></tr><tr><td align="left">MB_OK</td><td align="left">0x00000000L</td><td align="left">消息框包含一个按钮:OK。这是默认值</td></tr><tr><td align="left">MB_OKCANCEL</td><td align="left">0x00000001L</td><td align="left">消息框包含两个按钮:OK和Cancel</td></tr><tr><td align="left">MB_RETRYCANCEL</td><td align="left">0x00000005L</td><td align="left">消息框包含两个按钮:重试和取消</td></tr><tr><td align="left">MB_YESNO</td><td align="left">0x00000004L</td><td align="left">消息框包含两个按钮:Yes和No</td></tr><tr><td align="left">MB_YESNOCANCEL</td><td align="left">0x00000003L</td><td align="left">T消息框包含三个按钮:Yes、No和Cancel</td></tr></tbody></table><hr><p>要在消息框中显示图标，请指定以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MB_ICONEXCLAMATION</td><td align="left">0x00000030L</td><td align="left">消息框中会出现一个感叹号图标</td></tr><tr><td align="left">MB_ICONWARNING</td><td align="left">0x00000030L</td><td align="left">消息框中会出现一个感叹号图标</td></tr><tr><td align="left">MB_ICONINFORMATION</td><td align="left">0x00000040L</td><td align="left">消息框中会出现一个由小写字母i组成的圆圈图标</td></tr><tr><td align="left">MB_ICONASTERISK</td><td align="left">0x00000040L</td><td align="left">消息框中会出现一个由小写字母i组成的圆圈图标</td></tr><tr><td align="left">MB_ICONQUESTION</td><td align="left">0x00000020L</td><td align="left">一个问号图标出现在消息框中。不再推荐使用问号消息图标，因为它不能清楚地表示特定类型的消息，而且将消息表述为问题可以应用于任何类型的消息。此外，用户可能会将消息符号问号与帮助信息混淆。因此，不要在您的消息框中使用这个问号消息符号。系统继续支持它，只是为了向旧版本兼容</td></tr><tr><td align="left">MB_ICONSTOP</td><td align="left">0x00000010L</td><td align="left">消息框中出现停止标志图标</td></tr><tr><td align="left">MB_ICONERROR</td><td align="left">0x00000010L</td><td align="left">消息框中出现停止标志图标</td></tr><tr><td align="left">MB_ICONHAND</td><td align="left">0x00000010L</td><td align="left">消息框中出现停止标志图标</td></tr></tbody></table><hr><p>要指定默认按钮，请指定以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MB_DEFBUTTON1</td><td align="left">0x00000000L</td><td align="left">第一个按钮是默认按钮。 除非指定了MB_DEFBUTTON2、MB_DEFBUTTON3或MB_DEFBUTTON4，否则MB_DEFBUTTON1是默认值</td></tr><tr><td align="left">MB_DEFBUTTON2</td><td align="left">0x00000100L</td><td align="left">第二个按钮是默认按钮</td></tr><tr><td align="left">MB_DEFBUTTON3</td><td align="left">0x00000200L</td><td align="left">第三个按钮是默认按钮.</td></tr><tr><td align="left">MB_DEFBUTTON4</td><td align="left">0x00000300L</td><td align="left">第四个按钮是默认按钮</td></tr></tbody></table><hr><p>若要指示对话框的模式，请指定以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MB_APPLMODAL</td><td align="left">0x00000000L</td><td align="left">用户必须响应消息框，然后才能在hWnd参数标识的窗口中继续工作。然而，用户可以移动到其他线程的窗口并在这些窗口中工作。 根据应用程序中窗口的层次结构，用户可以移动到线程中的其他窗口。消息框父窗口的所有子窗口都会被自动禁用，但弹出窗口不会。 如果没有指定MB_SYSTEMMODAL或MB_TASKMODAL，则MB_APPLMODAL是默认值</td></tr><tr><td align="left">MB_SYSTEMMODAL</td><td align="left">0x00001000L</td><td align="left">与MB_APPLMODAL相同，只是消息框具有WS_EX_TOPMOST样式。使用系统模式消息框来通知用户需要立即注意的严重的、潜在的破坏性错误(例如，内存耗尽)。这个标志对用户与windows交互的能力没有影响，除了那些与hWnd相关的</td></tr><tr><td align="left">MB_TASKMODAL</td><td align="left">0x00002000L</td><td align="left">与MB_APPLMODAL相同，只是当hWnd参数为NULL时，属于当前线程的所有顶级窗口都被禁用。当调用应用程序或库没有可用的窗口句柄，但仍然需要防止输入到调用线程中的其他窗口而不挂起其他线程时，使用此标志</td></tr></tbody></table><hr><p>要指定其他选项，请使用下列一个或多个值：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MB_DEFAULT_DESKTOP_ONLY</td><td align="left">0x00020000L</td><td align="left">与交互式窗口站的桌面相同。有关更多信息，请参见<a href="https://docs.microsoft.com/en-us/windows/desktop/winstation/window-stations">Window Stations</a>. 如果当前输入的桌面不是默认桌面，MessageBox直到用户切换到默认桌面才会返回。</td></tr><tr><td align="left">MB_RIGHT</td><td align="left">0x00080000L</td><td align="left">文本是右对齐的</td></tr><tr><td align="left">MB_RTLREADING</td><td align="left">0x00100000L</td><td align="left">在希伯来语和阿拉伯语系统上使用从右到左的阅读顺序显示消息和标题文本</td></tr><tr><td align="left">MB_SETFOREGROUND</td><td align="left">0x00010000L</td><td align="left">消息框成为前台窗口。在内部，系统为消息框调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a>函数</td></tr><tr><td align="left">MB_TOPMOST</td><td align="left">0x00040000L</td><td align="left">消息框使用WS_EX_TOPMOST窗口样式创建</td></tr><tr><td align="left">MB_SERVICE_NOTIFICATION</td><td align="left">0x00200000L</td><td align="left">调用者是一个通知用户事件的服务。即使没有用户登录到计算机，该功能也会在当前活动桌面上显示一个消息框。 终端服务:如果调用线程有一个模拟令牌，该函数将消息框定向到模拟令牌中指定的会话。 如果设置此标志，则hWnd参数必须为空。这样可以在hWnd对应的其他桌面上显示该消息框。 有关使用此标志的安全注意事项的信息，请参见<a href="https://docs.microsoft.com/en-us/windows/desktop/Services/interactive-services">Interactive Services</a>。特别要注意的是，这个标志可以在锁定的桌面上生成交互式内容，因此应该只用于非常有限的场景，比如资源耗尽。</td></tr></tbody></table><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回值类型：int</p><ul><li><p>如果消息框有一个取消按钮，如果ESC键被按下或取消按钮被选中，该函数将返回IDCANCEL值。如果消息框没有取消按钮，按ESC将没有效果-除非MB_OK按钮存在。如果出现MB_OK按钮，按“ESC”键，返回值为“IDOK”。</p></li><li><p>如果函数失败，返回值为0。要获取扩展的错误信息，请调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a></p></li><li><p>如果函数成功，返回值是下面的菜单项值之一:</p><table><thead><tr><th align="left">返回码</th><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">IDABORT</td><td align="left">3</td><td align="left">Abort按钮被选中</td></tr><tr><td align="left">IDCANCEL</td><td align="left">2</td><td align="left">Cancel按钮被选中</td></tr><tr><td align="left">IDCONTINUE</td><td align="left">11</td><td align="left">Continue按钮被选中</td></tr><tr><td align="left">IDIGNORE</td><td align="left">5</td><td align="left">Ignore按钮被选中</td></tr><tr><td align="left">IDNO</td><td align="left">7</td><td align="left">No按钮被选中</td></tr><tr><td align="left">IDOK</td><td align="left">1</td><td align="left">OK按钮被选中</td></tr><tr><td align="left">IDRETRY</td><td align="left">4</td><td align="left">Retry按钮被选中</td></tr><tr><td align="left">IDTRYAGAIN</td><td align="left">10</td><td align="left">Try Again按钮被选中</td></tr><tr><td align="left">IDYES</td><td align="left">6</td><td align="left">Yes按钮被选中</td></tr></tbody></table></li></ul><hr><p>通过将uType参数设置为对应的标志值，可以在消息框中使用以下系统图标</p><table><thead><tr><th align="left">图标</th><th align="left">Flag 值</th></tr></thead><tbody><tr><td align="left"><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconhand.png" alt="Icon for MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR"></td><td align="left"><strong>MB_ICONHAND</strong>, <strong>MB_ICONSTOP</strong>, 或 <strong>MB_ICONERROR</strong></td></tr><tr><td align="left"><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconquestion.png" alt="Icon for MB_ICONQUESTION"></td><td align="left"><strong>MB_ICONQUESTION</strong></td></tr><tr><td align="left"><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconexclamation.png" alt="Icon for MB_ICONEXCLAMATION and MB_ICONWARNING"></td><td align="left"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong></td></tr><tr><td align="left"><img src="https://docs.microsoft.com/en-us/windows/win32/api/winuser/images/mb_iconasterisk.png" alt="Icon for MB_ICONASTERISK and MB_ICONINFORMATION"></td><td align="left"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong></td></tr></tbody></table><hr><h2 id="查看反汇编"><a href="#查看反汇编" class="headerlink" title="查看反汇编"></a>查看反汇编</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码9:        MessageBoxA(0,&quot;lyl610abc&quot;,&quot;tips&quot;,0);</span><br><span class="line">00401028 8B F4                mov         esi,esp</span><br><span class="line">0040102A 6A 00                push        0</span><br><span class="line">0040102C 68 28 20 42 00       push        offset string &quot;tips&quot; (00422028)</span><br><span class="line">00401031 68 1C 20 42 00       push        offset string &quot;lyl610abc&quot; (0042201c)</span><br><span class="line">00401036 6A 00                push        0</span><br><span class="line">00401038 FF 15 AC A2 42 00    call        dword ptr [__imp__MessageBoxA@16 (0042a2ac)]</span><br><span class="line">0040103E 3B F4                cmp         esi,esp</span><br><span class="line">00401040 E8 2B 00 00 00       call        __chkesp (00401070)</span><br></pre></td></tr></table></figure><hr><p>这里截取出关键的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码0040102A 6A 00                push        0</span><br><span class="line">0040102C 68 28 20 42 00       push        offset string &quot;tips&quot; (00422028)</span><br><span class="line">00401031 68 1C 20 42 00       push        offset string &quot;lyl610abc&quot; (0042201c)</span><br><span class="line">00401036 6A 00                push        0</span><br><span class="line">00401038 FF 15 AC A2 42 00    call        dword ptr [__imp__MessageBoxA@16 (0042a2ac)]</span><br></pre></td></tr></table></figure><hr><p>其余代码说明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码00401028 8B F4                mov         esi,esp                //保存执行前的esp(栈顶)到esi</span><br><span class="line">0040103E 3B F4                cmp         esi,esp                //比较esi和执行完call后的esp(栈顶)</span><br><span class="line">00401040 E8 2B 00 00 00       call        __chkesp (00401070)        //调用检测esp的函数</span><br></pre></td></tr></table></figure><p>用来检测，调用完函数后堆栈是否保持平衡，是C语言自动生成的，这里无需关注</p><hr><h2 id="解析反汇编"><a href="#解析反汇编" class="headerlink" title="解析反汇编"></a>解析反汇编</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码0040102A 6A 00                push        0</span><br><span class="line">0040102C 68 28 20 42 00       push        offset string &quot;tips&quot; (00422028)</span><br><span class="line">00401031 68 1C 20 42 00       push        offset string &quot;lyl610abc&quot; (0042201c)</span><br><span class="line">00401036 6A 00                push        0</span><br></pre></td></tr></table></figure><p>前四行代码是依次压入四个参数（从右到左压入），这和调用协定相关，在<a href="https://www.52pojie.cn/thread-1380788-1-1.html">逆向基础笔记九 C语言内联汇编和调用协定</a>已说过，这里不再赘述</p><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">00401038 FF 15 AC A2 42 00    call        dword ptr [__imp__MessageBoxA@16 (0042a2ac)]</span><br></pre></td></tr></table></figure><p>调用call这里，可以看到这是一个间接调用，形式为call [地址]，所以这里要查看一下其实际地址里存储的内容是什么，也就是其实际call的地址</p><p>通过内存窗口可以得到，其实际call的地址为77D507EA</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402192114225.png" alt="image-20210402192114225"></p><hr><p>所以此时的代码相当于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">00401038        call        77D507EA</span><br></pre></td></tr></table></figure><hr><p>这里为什么是一个间接call，77D507EA代表什么？</p><p>这里<strong>采用间接call的原因是引用了导入表</strong>，关于导入表和导出表的内容之后的笔记会再做说明</p><p>这里的77D507EA<strong>代表的是MessageBoxA函数的地址</strong></p><p>每个电脑的MessageBoxA函数的地址<strong>不一定相同</strong>，它取决于系统的user32.dll中导出表中给出的地址（这里调用的MessageBoxA是由user32.dll提供的）</p><p>可以用IDA来验证这一点：</p><p>找到系统中的user32.dll（在32位的xp中在C:\WINDOWS\system32下，在64位系统中则有2个，一个在C:\Windows\SysWOW64下(32位的dll)，一个也在C:\WINDOWS\system32下(64位的dll)，<strong>具体使用哪个取决于程序是32位还是64位</strong>）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402193359108.png" alt="image-20210402193359108"></p><hr><p>将其用IDA打开，找到导出表，然后在导出表中搜索得到MessageBoxA</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402193459557.png" alt="image-20210402193459557"></p><p>可以看到它的地址和前面得到的一致，为77D507EA，验证来源完毕</p><p><strong>注意此时的系统是XP32位</strong>，在其它高版本的系统中这里的Address<strong>并不一定能和前面的一致</strong>，这里主要是为了说明<strong>函数的来源与导入表和导出表有关</strong>，也说明了<strong>为何不同系统的MessageBoxA的地址不一定相同</strong>，为后面的学习作个铺垫</p><hr><p><strong>准确得到函数地址的方法为</strong>：</p><p>如果想要得到MessageBoxA函数的（其它函数同理）地址，首先要找到一个有调用这个函数所属的模块的程序（MessageBoxA所属的模块为user32.dll），使用OD附加来查找：</p><p>一般来说只要是图形化的程序都会调用user32.dll这个模块，于是这里就随便拿一个exe程序就行，这里以dbgview.exe为例</p><p>使用OD打开dbgview.exe，然后单击图中所指的e，或者使用快捷键Alt+E</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202400705.png" alt="image-20210402202400705"></p><hr><p>在弹出来的窗口中找到user32.dll，双击</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202544557.png" alt="image-20210402202544557"></p><hr><p>在弹出来的反汇编界面按快捷键 Ctrl+N</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202741746.png" alt="image-20210402202741746"></p><hr><p>然后在新窗口找到MessageBoxA对应的地址即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402202903145.png" alt="image-20210402202903145"></p><p>此时得到的地址就是准确的MessageBoxA地址了</p><hr><h2 id="自写反汇编测试"><a href="#自写反汇编测试" class="headerlink" title="自写反汇编测试"></a>自写反汇编测试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>既然得到了MessageBoxA的函数地址，就无需间接调用了，可以直接调用它，于是自写代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">int MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) &#123;</span><br><span class="line">        int ret;</span><br><span class="line">    //这里的地址填前面通过OD得到的MessageBoxA地址,每个系统不一定相同</span><br><span class="line">    //先前是在xp系统中测试的，那时的MessageBoxA为77D507EA</span><br><span class="line">    //此时换到WIN10 X64 测试，修改MessageBoxA的值</span><br><span class="line">        int addr = 0x76a3ee90;</span><br><span class="line">        __asm &#123;</span><br><span class="line">                push hWnd                </span><br><span class="line">                push lpCaption</span><br><span class="line">        push lpText</span><br><span class="line">                push uType</span><br><span class="line">                call addr</span><br><span class="line">                mov ret, eax</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        MyMessageBoxA(0, &quot;lyl610abc&quot;, &quot;tips&quot;, 0);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><h3 id><a href="#" class="headerlink" title></a><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402203720618.png" alt="image-20210402203720618"></h3><p>依然能够正常弹窗，测试成功</p><hr><h2 id="反汇编转为硬编码-字节码"><a href="#反汇编转为硬编码-字节码" class="headerlink" title="反汇编转为硬编码(字节码)"></a>反汇编转为硬编码(字节码)</h2><p>通过先前的学习可以知道在计算机中，无论是执行的代码还是数据都是以二进制来存储的，为了方便查看，进制查看工具将内容以十六进制的方式展示</p><p>所以为了给程序添加弹窗，显然就不是直接将反汇编写入PE文件中，而是<strong>要将反汇编对应的硬编码(字节码)写入到PE文件中</strong></p><p>如何将反汇编转化为硬编码？这个是<strong>反汇编引擎</strong>所做的事，在OD或VC中的反汇编引擎已经将反汇编对应的硬编码(字节码)给出了</p><p>有关反汇编引擎的内容也属于硬编码相关的知识，<strong>看以后要不要开这个坑</strong></p><p>将前面写的反汇编再稍作修改，将参数写死，并且去掉返回值的接收</p><h3 id="修改反汇编代码"><a href="#修改反汇编代码" class="headerlink" title="修改反汇编代码"></a>修改反汇编代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void MyMessageBoxA() &#123;</span><br><span class="line">    //获取MessageBoxA的地址</span><br><span class="line">        int addr = (int)&amp;MessageBoxA;</span><br><span class="line">        printf(&quot;addr:%X\n&quot;, addr);</span><br><span class="line">    //&quot;lyl610abc&quot;对应的ASCII编码 6c 79 6c 36 31 30 61 62 63</span><br><span class="line">        unsigned char bytes[] = &#123; 0x6c,0x79,0x6c,0x36,0x31,0x30,0x61,0x62,0x63,0x00 &#125;;</span><br><span class="line">    //&quot;tips&quot;对应的ASCII编码</span><br><span class="line">        unsigned char bytes2[] = &#123; 0x74,0x69,0x70,0x73 &#125;;</span><br><span class="line">        //申请内存，该内存的属性为可执行 可读可写</span><br><span class="line">        LPVOID _lpText = VirtualAlloc(NULL, sizeof(byte), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        //申请内存，该内存的属性为可执行 可读可写</span><br><span class="line">        LPVOID _lpCaption = VirtualAlloc(NULL, sizeof(byte), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        //将硬编码写入申请的有权限的内存中</span><br><span class="line">        WriteProcessMemory(INVALID_HANDLE_VALUE, (LPVOID)_lpText, (BYTE*)bytes, sizeof(bytes), 0);</span><br><span class="line">        //将硬编码写入申请的有权限的内存中</span><br><span class="line">        WriteProcessMemory(INVALID_HANDLE_VALUE, (LPVOID)_lpCaption, (BYTE*)bytes2, sizeof(bytes2), 0);</span><br><span class="line">        __asm &#123;</span><br><span class="line">                push 0</span><br><span class="line">                push _lpCaption</span><br><span class="line">                push _lpText</span><br><span class="line">                push 0</span><br><span class="line">                call addr</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        MyMessageBoxA();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="OD模拟代码操作"><a href="#OD模拟代码操作" class="headerlink" title="OD模拟代码操作"></a>OD模拟代码操作</h3><p><strong>先总结一下上面修改后的反汇编代码做了什么</strong></p><ol><li>获得MessageBoxA的函数地址</li><li>将字符串对应的ASCII码写入到<strong>可读可写</strong>的一片内存中</li><li>压入参数</li><li>调用MessageBoxA函数</li><li>调用完后跳转回原本要执行的代码</li></ol><hr><p><strong>然后在OD中复现操作</strong></p><p>用OD随便载入一个<strong>包含user32.dll模块</strong>的程序，我这里直接拿前面的代码编译后的程序来作演示</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402232452491.png" alt="image-20210402232452491"></p><hr><p>按照前面总结的步骤来</p><p><strong>1.MessageBoxA在OD中的地址是已知的无需获取</strong></p><hr><p><strong>2.将字符串对应的ASCII码写入到可读可写的一片内存中</strong></p><p>首先是选取一块可读可写的内存，很显然，接下来要执行的代码一定是可读可写可执行的，于是这里就无须申请内存了，直接将下面的代码覆盖即可</p><p>解决了选取内存的问题，接下来就是将字符串对应的ASCII码写入内存即可，但这要放在压入参数之后，原因后面会说明，现在先看压入参数</p><hr><p><strong>3.压入参数</strong></p><p>第一个参数为0，直接将其对应的反汇编修改为push 0即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402233328019.png" alt="image-20210402233328019"></p><hr><p>第二个参数为_lpCaption，要写入的字符串为”tips”，但此时字符串还没写入内存，也就是并不确定字符串的内存地址，但可以确定一个大致的范围，要存放字符串的地方就在下方不远处，于是这里可以暂时先填写离这里不远的随便一个内存地址<strong>用来占位，等之后确定了字符串的内存地址后再回来修改</strong></p><p>这里就随便选取下面的地址00401156</p><p>于是将反汇编修改为push 0x00401156</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402233751226.png" alt="image-20210402233751226"></p><hr><p>第三个参数为_lpText，要写入的字符串为”lyl610abc”，和前面的_lpCaption一样，先填入push xxxx占位，之后再回来修改</p><p>于是依旧将其反汇编修改为push 0x00401156</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234015934.png" alt="image-20210402234015934"></p><hr><p>第四个参数为0，直接将其对应的反汇编修改为push 0即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234129978.png" alt="image-20210402234129978"></p><hr><p><strong>4.调用MessageBoxA函数</strong></p><p>直接修改反汇编为call MessageBoxA即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234323243.png" alt="image-20210402234323243"></p><hr><p><strong>5.调用完后跳转回原本要执行的代码</strong></p><p>这里是为了<strong>模拟之后执行完弹窗代码后再跳回程序入口</strong></p><p>这里随便模拟一个<strong>长跳转</strong>即可，修改反汇编代码为jmp 000412D0</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402234825725.png" alt="image-20210402234825725"></p><hr><p>6.填充字符串到内存中</p><p>下面的代码因为前面的绝对跳转是不会执行的，因此可以用来充当数据区，这也是<strong>要将字符串的填充放在后面的原因</strong></p><p>先填充_lpText，也就是”lyl610abc”</p><p>选中跳转下的那一行，右键→二进制→编辑</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402235240410.png" alt="image-20210402235240410"></p><hr><p>选中ASCII，并将要写入内存的字符串 “lyl610abc”填入</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402235524407.png" alt="image-20210402235524407"></p><hr><p>填入后再选中Hex那一行，在后面添加00（字符串以’\0’结尾）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000305968.png" alt="image-20210403000305968"></p><hr><p>添加完00后得到</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000401936.png" alt="image-20210403000401936"></p><p>然后确定即可</p><hr><p>修改完得到</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000507711.png" alt="image-20210403000507711"></p><hr><p>这是第三个参数_lpText就可以修正了，将前面的压入第三个参数的反汇编修改为 push 0x00401148</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403000803899.png" alt="image-20210403000803899"></p><hr><p>同样的方法填充第二个参数_lpCaption，也就是”tips”</p><p>这里先记录一下其地址为0x00401152，然后开始修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001042513.png" alt="image-20210403001042513"></p><hr><p>修改完后得到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001221815.png" alt="image-20210403001221815"></p><hr><p>最后再修正先前push的用来占位的地址即可</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001315492.png" alt="image-20210403001315492"></p><hr><p>修改完成，这里记录一下修改的十六进制代码为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码6A 00 68 52 11 40 00 68 48 11 40 00 6A 00 E8 A7 F6 94 77 E9 88 01 C4 FF 6C 79 6C 36 31 30 61 62</span><br><span class="line">63 00 74 69 70 73 00</span><br></pre></td></tr></table></figure><hr><p>修改完成后不断按F8单步步过，直call user32.MessageBoxA这</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001554670.png" alt="image-20210403001554670"></p><p>可以看到，对应的参数是没有问题的</p><hr><p>最后再按F8单步步过即可看到结果：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403001651536.png" alt="image-20210403001651536"></p><p>能够按照代码弹框，完成( •̀ ω •́ )✧</p><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>限于篇幅原因，这次的笔记主要讲解了<strong>弹窗代码的编写流程</strong>，之后的笔记则是将上面的硬编码稍作修改然后写入PE文件中再修改PE入口点来实现最终目的</p><p>终于来到<strong>实战环节</strong>了，前面关于知识点介绍的笔记看的人数一言难尽，希望通过实战能够勾起大家的兴趣，一起学习共同进步O(∩_∩)O</p><p>最后再附上 上面OD修改的程序，有兴趣的可以跟着做一做</p><p><a href="https://www.52pojie.cn/forum.php?mod=attachment&aid=MjI1NDQyMHw4N2RlZThiOHwxNjIzNzQyMzE4fDB8MTQwODg2Ng==">MessageBoxA.zip</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1408866-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记七 RVA与FOA转换</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%937/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%937/</url>
      
        <content type="html"><![CDATA[<p>前面学习了在块表中提到了VA和FOA，这次来学习它们之间的转换</p><h1 id="VA转FOA"><a href="#VA转FOA" class="headerlink" title="VA转FOA"></a>VA转FOA</h1><p>在先前的笔记<a href="https://www.52pojie.cn/thread-1407996-1-1.html">PE文件笔记六 节表和节</a>中，已经有提到关于VA、RVA和FOA的概念</p><table><thead><tr><th align="left"></th><th align="left">对应结构体成员</th><th align="left">英文全称</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">VA</td><td align="left">_IMAGE_SECTION_HEADER.VirtualAddress</td><td align="left">Virtual Address</td><td align="left">在内存中的虚拟地址</td></tr><tr><td align="left">RVA</td><td align="left">_IMAGE_SECTION_HEADER.VirtualAddress</td><td align="left">Relative Virtual Address</td><td align="left">相对虚拟地址</td></tr><tr><td align="left">FOA</td><td align="left">_IMAGE_SECTION_HEADER.PointerToRawData</td><td align="left">File Offset Address</td><td align="left">文件偏移地址</td></tr></tbody></table><hr><p>接下来继续学习VA和FOA的转换</p><p>在学习转换之前，先探寻一下为什么要学习它们之间的转换？</p><h2 id="为什么学习VA与FOA转换"><a href="#为什么学习VA与FOA转换" class="headerlink" title="为什么学习VA与FOA转换"></a>为什么学习VA与FOA转换</h2><p>在这里要引入一个问题：如何改变一个<strong>全局变量</strong>的初始值</p><p>在<a href="https://www.52pojie.cn/thread-1381699-1-1.html">逆向基础笔记十二 汇编 全局和局部 变量</a>中已经说过了全局变量和局部变量的区别</p><ul><li>如果一个全局变量<strong>有初始值</strong>，那么它的初始值<strong>一定是存储在PE文件中</strong>的</li><li>如果一个全局变量<strong>没有初始值</strong>，那么在PE文件中就没有存储它的位置，只有当PE文件加载到内存中时，才会给它分配空间</li></ul><p>学习RVA与FOA的转换后，就可以修改程序中的数据后一劳永逸，无需每次都用CE等内存工具搜索修改等等</p><hr><h2 id="全局变量初始值demo"><a href="#全局变量初始值demo" class="headerlink" title="全局变量初始值demo"></a>全局变量初始值demo</h2><p>为了学习，写一个小的程序，该程序输出全局变量的值和全局变量地址</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line">int global = 0x610;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //输出全局变量地址</span><br><span class="line">    printf(&quot;address:%X\n&quot;, &amp;global);</span><br><span class="line">    //输出全局变量的值</span><br><span class="line">    printf(&quot;value:0x%X\n&quot;, global);</span><br><span class="line">    //暂停一下，防止窗口运行完自动关闭</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402151017936.png" alt="image-20210402151017936"></p><hr><h2 id="修改全局变量初始值"><a href="#修改全局变量初始值" class="headerlink" title="修改全局变量初始值"></a>修改全局变量初始值</h2><p>可以看到全局变量对应的地址为4198B0</p><p>那么是不是直接去PE文件中找到这个地址就行呢？当然不是</p><p>首先要明确，此时得到的全局变量地址是<strong>运行态</strong>时的地址，也就是VA（在内存中的虚拟地址）</p><p>VA = ImageBase + RVA</p><p>即：在内存中的虚拟地址 = 镜像基地址 + 相对虚拟地址</p><p>而 镜像基地址为扩展PE头中的ImageBase成员，是已知的</p><p>于是可以得到RVA = VA - ImageBase</p><p>而其在PE文件中的地址为FOA（文件偏移地址）</p><p>最终问题就也就变成了 RVA与FOA的转换</p><hr><h3 id="VA到FOA转换流程"><a href="#VA到FOA转换流程" class="headerlink" title="VA到FOA转换流程"></a>VA到FOA转换流程</h3><p>1.得到RVA的值：RVA = VA - ImageBase</p><p>2.判断RVA是否位于PE文件头中</p><p>2.1如果是：FOA=RVA</p><p>2.2如果不是：判断RVA位于哪个节，差值 = RVA - 节.VirtualAddress(RVA)，FOA = 节.PointerToRawData + 差值</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404135433847.png" alt="image-20210404135433847"></p><hr><h3 id="按照流程转换"><a href="#按照流程转换" class="headerlink" title="按照流程转换"></a>按照流程转换</h3><p><strong>1.得到RVA的值：RVA = VA - ImageBase</strong></p><p>首先用查看该PE文件的ImageBase</p><p>这里采用的PE工具为Detect It Easy，简称DIE</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402151418941.png" alt="image-20210402151418941"></p><hr><p>得到ImageBase为0x400000</p><p>于是可以得到RVA = VA - ImageBase = 0x4198B0 - 0x400000 = 0x198B0</p><hr><p><strong>2.判断RVA是否位于PE文件头中</strong></p><p>可以用WinHex 找到PE文件头的部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402151652326.png" alt="image-20210402151652326"></p><hr><p>可以看到PE文件头的最后一位地址为：1F7</p><p>RVA = 0x198B0 显然超出了PE文件头的大小</p><hr><p><strong>3.判断RVA属于哪个节</strong></p><p>RVA&gt;=节.VirtualAddress</p><p>RVA&lt;节.VirtualAddress + 当前节<strong>内存对齐</strong>后的大小=节.VirtualAddress +[(Max{节.Misc,节.SizeOfRawData})÷SectionAlignment]<strong>向上取整</strong>×SectionAlignment</p><ul><li>节.SizeOfRawData是节文件对齐后的大小</li><li>节.Misc是节的实际大小</li></ul><p>关于节内存对齐大小为什么如此计算可以回顾<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1407996&page=1&extra=#37810231_misc%E5%92%8Csizeofrawdata">PE文件笔记六 节表和节</a></p><p><strong>内存对齐后的大小 = [Max{实际的大小,文件对齐后的大小}÷内存对齐]向上取整×内存对齐</strong></p><p>向上取整的意思就是 如果除后的结果为整数就直接为结果，如果除后的结果带小数则取整然后加一</p><p>例子：[5÷2]向上取整= 2.5取整+1=2+1=3，[4÷2]向上取整=2</p><hr><p>使用PE工具 DIE，查看各个节的信息：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402152412226.png" alt="image-20210402152412226"></p><hr><p>根据比较，可以发现RVA=0x198B0 属于第三个节 .data中</p><p>因为第三个节的VirtualAddress=0x19000，文件对齐后的大小=节.SizeOfRawData在DIE中显示为R.Size = 0xa00</p><p>实际大小=节.Misc再DIE显示为V.Size=0x12e0</p><p>Max{节.Misc,节.SizeOfRawData}=Max{0x12e0,0xa00}=0x12e0</p><p>内存对齐后的大小 = (0x12e0÷内存对齐)向上取整×内存对齐 = (0x12e0÷0x1000)向上取整 × 0x1000=2 × 0x1000=0x2000</p><p>RVA&gt;=0x19000</p><p>RVA&lt;0x19000+ 内存对齐后的大小=0x19000+0x2000=0x1B000</p><hr><p>差值 = RVA - 节.VirtualAddress = 0x198B0 - 0x19000 = 0x8B0</p><p>PointerToRawData 在DIE工具中显示为Offset，为0x16E00</p><p>FOA = 节.PointerToRawData + 差值 = 0x16E00 + 0x8B0 = 0x176B0</p><hr><p><strong>用WinHex查看相应位置的数值</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402153045465.png" alt="image-20210402153045465"></p><hr><h3 id="修改数值查看结果"><a href="#修改数值查看结果" class="headerlink" title="修改数值查看结果"></a>修改数值查看结果</h3><p>找到了FOA的地址后，修改对应地址的数据，并保存</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402153316707.png" alt="image-20210402153316707"></p><hr><p>再运行程序得到</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402153533987.png" alt="image-20210402153533987"></p><p>可以看到原本程序中的数据已经被修改了</p><h2 id="代码实现VA转FOA"><a href="#代码实现VA转FOA" class="headerlink" title="代码实现VA转FOA"></a>代码实现VA转FOA</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    //输出rva</span><br><span class="line">    printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">    //输出PeEnd</span><br><span class="line">    printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">    //判断rva是否位于PE文件头中</span><br><span class="line">    if (rva &lt; PeEnd) &#123;</span><br><span class="line">        //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">        printf(&quot;foa:%X\n&quot;, rva);        </span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果rva在PE文件头外</span><br><span class="line">        //判断rva属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            //计算内存对齐后节的大小</span><br><span class="line">            UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (double)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                //找到所属的节</span><br><span class="line">                //输出内存对齐后的节的大小</span><br><span class="line">                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">            int offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            //FOA = 节.PointerToRawData + 差值</span><br><span class="line">            int foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">            return foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VA转FOA 64位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa64(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    //输出rva</span><br><span class="line">    printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS64);</span><br><span class="line">    //输出PeEnd</span><br><span class="line">    printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">    //判断rva是否位于PE文件头中</span><br><span class="line">    if (rva &lt; PeEnd) &#123;</span><br><span class="line">        //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">        printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果rva在PE文件头外</span><br><span class="line">        //判断rva属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            //计算内存对齐后节的大小</span><br><span class="line">            UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (double)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                //找到所属的节</span><br><span class="line">                //输出内存对齐后的节的大小</span><br><span class="line">                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">            int offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            //FOA = 节.PointerToRawData + 差值</span><br><span class="line">            int foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">            return foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\GlobalVariety.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VaToFoa32(0x4198B0,dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404134754827.png" alt="image-20210404134754827"></p><p>可以看到计算出来的结果和前面手动计算的一致</p><hr><h1 id="FOA转VA"><a href="#FOA转VA" class="headerlink" title="FOA转VA"></a>FOA转VA</h1><p>理解了前面的VA转FOA后，再来学习一下它的逆过程：FOA转VA</p><p>现在将前面转换的结果：0x000176B0拿来：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210402153045465.png" alt="image-20210402153045465"></p><p>尝试逆推出地址</p><hr><h2 id="FOA转VA转换流程"><a href="#FOA转VA转换流程" class="headerlink" title="FOA转VA转换流程"></a>FOA转VA转换流程</h2><p>1.判断FOA是否位于PE文件头中</p><p>1.1如果是：FOA=RVA</p><p>1.2如果不是：判断FOA位于哪个节，差值 = FOA - 节.PointerToRawData ，RVA = 差值 + 节.VirtualAddress(RVA)</p><p>2.VA = ImageBase + RVA</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404135449806.png" alt="image-20210404135449806"></p><hr><h2 id="按照流程转换-1"><a href="#按照流程转换-1" class="headerlink" title="按照流程转换"></a>按照流程转换</h2><p><strong>1.判断FOA是否位于PE文件头中</strong></p><p>显然FOA在PE文件头之外</p><p><strong>1.2.判断FOA位于哪个节</strong></p><p>FOA&gt;=节.PointerToRawData</p><p>FOA&lt;节.PointerToRawData + 当前节<strong>文件对齐</strong>后的大小=节.PointerToRawData+节.SizeOfRawData</p><hr><p>再次用PE工具 DIE查看节的信息：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403202147543.png" alt="image-20210403202147543"></p><hr><p>根据比较，可以发现FOA=0x176B0属于第三个节 .data中</p><p>因为第三个节的PointerToRawData=0x16e00（在DIE中显示为Offset），文件对齐后的大小=节.SizeOfRawData在DIE中显示为R.Size = 0xa00</p><p>FOA&gt;=0x16e00</p><p>FOA&lt;节.PointerToRawData + 当前节<strong>文件对齐</strong>后的大小=节.PointerToRawData+节.SizeOfRawData=0x16e00+0xa00=0x17800</p><hr><p>差值 = FOA - 节.PointerToRawData = 0x176B0 - 0x16e00 = 0x8B0</p><p>RVA = 差值 + 节.VirtualAddress(RVA) = 0x8B0 + 0x19000 = 0x198B0</p><hr><p><strong>2.VA = ImageBase + RVA</strong></p><p>VA = ImageBase + RVA = 0x400000+0x198B0 = 0x4198B0</p><p>得到的VA和先前的值一致，转换完毕</p><hr><h2 id="代码实现FOA转VA"><a href="#代码实现FOA转VA" class="headerlink" title="代码实现FOA转VA"></a>代码实现FOA转VA</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line"></span><br><span class="line">//VA转FOA 32位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa32(UINT va, _IMAGE_DOS_HEADER *dos,_IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    //输出rva</span><br><span class="line">    printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew+sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">    //输出PeEnd</span><br><span class="line">    printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">    //判断rva是否位于PE文件头中</span><br><span class="line">    if (rva &lt; PeEnd) &#123;</span><br><span class="line">        //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">        printf(&quot;foa:%X\n&quot;, rva);        </span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果rva在PE文件头外</span><br><span class="line">        //判断rva属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            //计算内存对齐后节的大小</span><br><span class="line">            UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (double)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line"></span><br><span class="line">            if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                //找到所属的节</span><br><span class="line">                //输出内存对齐后的节的大小</span><br><span class="line">                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            //FOA = 节.PointerToRawData + 差值</span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">            return foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VA转FOA 64位</span><br><span class="line">//第一个参数为要转换的在内存中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT VaToFoa64(UINT va, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //得到RVA的值：RVA = VA - ImageBase</span><br><span class="line">    UINT rva = va - nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    //输出rva</span><br><span class="line">    printf(&quot;rva:%X\n&quot;, rva);</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS64);</span><br><span class="line">    //输出PeEnd</span><br><span class="line">    printf(&quot;PeEnd:%X\n&quot;, PeEnd);</span><br><span class="line">    //判断rva是否位于PE文件头中</span><br><span class="line">    if (rva &lt; PeEnd) &#123;</span><br><span class="line">        //如果rva位于PE文件头中，则foa==rva，直接返回rva即可</span><br><span class="line">        printf(&quot;foa:%X\n&quot;, rva);</span><br><span class="line">        return rva;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果rva在PE文件头外</span><br><span class="line">        //判断rva属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">            //计算内存对齐后节的大小</span><br><span class="line">            UINT SizeInMemory = ceil((double)max((UINT)sectionArr[i]-&gt;Misc.VirtualSize ,(UINT)sectionArr[i]-&gt;SizeOfRawData ) / (double)nt-&gt;OptionalHeader.SectionAlignment)* nt-&gt;OptionalHeader.SectionAlignment;           </span><br><span class="line">            if (rva &gt;= sectionArr[i]-&gt;VirtualAddress &amp;&amp; rva &lt; (sectionArr[i]-&gt;VirtualAddress + SizeInMemory)) &#123;</span><br><span class="line">                //找到所属的节</span><br><span class="line">                //输出内存对齐后的节的大小</span><br><span class="line">                printf(&quot;SizeInMemory:%X\n&quot;, SizeInMemory);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= RVA - 节.VirtualAddress</span><br><span class="line">            UINT offset = rva - sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            //FOA = 节.PointerToRawData + 差值</span><br><span class="line">            UINT foa = sectionArr[i]-&gt;PointerToRawData + offset;</span><br><span class="line">            printf(&quot;foa:%X\n&quot;, foa);</span><br><span class="line">            return foa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//FOA转VA 32位</span><br><span class="line">//第一个参数为要转换的在文件中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT FoaToVa32(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS);</span><br><span class="line">    //判断FOA是否位于PE文件头中</span><br><span class="line">    if (foa &lt; PeEnd) &#123;</span><br><span class="line">        //如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span><br><span class="line">        printf(&quot;va:%X\n&quot;, foa+nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        return foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果foa在PE文件头外</span><br><span class="line">        //判断foa属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line"></span><br><span class="line">            if (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData)) &#123;</span><br><span class="line">                //找到所属的节                </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= FOA - 节.PointerToRawData </span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            //RVA = 差值 + 节.VirtualAddress(RVA)</span><br><span class="line">            UINT rva =  offset+ sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            printf(&quot;va:%X\n&quot;, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            return rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//FOA转VA 64位</span><br><span class="line">//第一个参数为要转换的在文件中的地址：VA</span><br><span class="line">//第二个参数为指向dos头的指针</span><br><span class="line">//第三个参数为指向nt头的指针</span><br><span class="line">//第四个参数为存储指向节指针的数组</span><br><span class="line">UINT FoaToVa64(UINT foa, _IMAGE_DOS_HEADER* dos, _IMAGE_NT_HEADERS64* nt, _IMAGE_SECTION_HEADER** sectionArr) &#123;</span><br><span class="line">    //找到PE文件头后的地址 = PE文件头首地址+PE文件头大小</span><br><span class="line">    UINT PeEnd = (UINT)dos-&gt;e_lfanew + sizeof(_IMAGE_NT_HEADERS64);</span><br><span class="line">    //判断FOA是否位于PE文件头中</span><br><span class="line">    if (foa &lt; PeEnd) &#123;</span><br><span class="line">        //如果foa位于PE文件头中，则foa==rva，直接返回foa+ImageBase即可</span><br><span class="line">        printf(&quot;va:%X\n&quot;, foa + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">        return foa + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //如果foa在PE文件头外</span><br><span class="line">        //判断foa属于哪个节</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nt-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line"></span><br><span class="line">            if (foa &gt;= sectionArr[i]-&gt;PointerToRawData &amp;&amp; foa &lt; (sectionArr[i]-&gt;PointerToRawData + sectionArr[i]-&gt;SizeOfRawData)) &#123;</span><br><span class="line">                //找到所属的节                </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;= nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //未找到</span><br><span class="line">            printf(&quot;没有找到匹配的节\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //计算差值= FOA - 节.PointerToRawData </span><br><span class="line">            UINT offset = foa - sectionArr[i]-&gt;PointerToRawData;</span><br><span class="line">            //RVA = 差值 + 节.VirtualAddress(RVA)</span><br><span class="line">            UINT rva = offset + sectionArr[i]-&gt;VirtualAddress;</span><br><span class="line">            printf(&quot;va:%X\n&quot;, rva + nt-&gt;OptionalHeader.ImageBase);</span><br><span class="line">            return rva + nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\sixonezero\\Desktop\\GlobalVariety.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VaToFoa32(0x4198B0,dos, nt, sectionArr);</span><br><span class="line">        FoaToVa32(0x176B0, dos, nt, sectionArr);</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        VaToFoa32(0x4198B0,dos, nt, sectionArr);</span><br><span class="line">        FoaToVa32(0x176B0, dos, nt, sectionArr);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404135218584.png" alt="image-20210404135218584"></p><p>可以看到计算出来的结果和前面手动计算的一致</p><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>学会了VA与FOA的转换后，后面就可以开始对程序做一些坏坏的事了(❁′◡`❁)</p><p>刚开始使用VC6环境编译，发现编译出来的程序，文件对齐和内存对齐数值是一致的，没法起到较好的学习作用，于是改用VS2015编译出兼容XP的且文件对齐和内存对齐不同的程序，方便学习</p><p>PS：在文件对齐等于内存对齐的情况下，RVA就直接等于FOA了</p><p><strong>RVA和FOA之间的差异归根结底就是在于文件对齐和内存对齐的差异上</strong></p><p>下面附上编译出来的程序和修改过的程序，对应为GlobalVariety.exe和GlobalVariety2.exe，有兴趣的可以去修改试试（建议在虚拟机XP环境下测试，否则printf出来的地址可能不准确）</p><p><a href="https://www.52pojie.cn/forum.php?mod=attachment&aid=MjI1NDA4NHw3ZGM4YjVlY3wxNjIzNzMzMzY1fDB8MTQwODU3Ng==">GlobalVariety.zip</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记六 节表和节</title>
      <link href="2021/06/15/PE%E6%80%BB%E7%BB%936/"/>
      <url>2021/06/15/PE%E6%80%BB%E7%BB%936/</url>
      
        <content type="html"><![CDATA[<p>前面学习了PE的DOS部首和PE文件头，这次学习的结构为PE节表</p><p>PS：关于PE文件头中扩展PE头的<strong>数据目录项</strong>，其中包含了导入表、导出表、重定位表等等，暂且留作之后</p><hr><h1 id="PE节表"><a href="#PE节表" class="headerlink" title="PE节表"></a>PE节表</h1><h2 id="PE节表作用"><a href="#PE节表作用" class="headerlink" title="PE节表作用"></a>PE节表作用</h2><p>表示Image的section头格式</p><h2 id="PE节表结构"><a href="#PE节表结构" class="headerlink" title="PE节表结构"></a>PE节表结构</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330204244302.png" alt="image-20210330204244302"></p><hr><table><thead><tr><th align="left">PE节表结构</th><th align="left">对应C中的结构体</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>多个</strong>IMAGE_SECTION_HEADER</td><td align="left"><strong>多个</strong>_IMAGE_SECTION_HEADER</td><td align="left">每个_IMAGE_SECTION_HEADER描述后面的一个节</td></tr></tbody></table><hr><h2 id="结构体截图"><a href="#结构体截图" class="headerlink" title="结构体截图"></a>结构体截图</h2><p>在winnt.h中找到_IMAGE_SECTION_HEADER，得到以下截图（具体查找对应C结构体方法在<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1391994&page=1&extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">PE文件笔记一 PE介绍</a>中已经说明了，这里不再赘述）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330204852909.png" alt="image-20210330204852909"></p><hr><h2 id="结构体代码"><a href="#结构体代码" class="headerlink" title="结构体代码"></a>结构体代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#define IMAGE_SIZEOF_SHORT_NAME              8</span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br><span class="line">#define IMAGE_SIZEOF_SECTION_HEADER          40</span><br></pre></td></tr></table></figure><hr><h2 id="结构体成员分析"><a href="#结构体成员分析" class="headerlink" title="结构体成员分析"></a>结构体成员分析</h2><p>相比于扩展PE头，节表的成员并不算太多，但有部分成员仅针对.obj文件</p><p>下表为结构成员对应数据宽度和说明，加黑的成员为重点</p><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Name</strong></td><td align="left">BYTE[8]=8字节</td><td align="left">节名称</td></tr><tr><td align="left">Misc.PhysicalAddress</td><td align="left">DWORD（4字节）</td><td align="left">节的文件地址</td></tr><tr><td align="left"><strong>Misc.VirtualSize</strong></td><td align="left">DWORD（4字节）</td><td align="left">节的虚拟大小</td></tr><tr><td align="left"><strong>VirtualAddress</strong></td><td align="left">DWORD（4字节）</td><td align="left">节在内存中的偏移地址</td></tr><tr><td align="left"><strong>SizeOfRawData</strong></td><td align="left">DWORD（4字节）</td><td align="left">节在文件中对齐后的尺寸</td></tr><tr><td align="left"><strong>PointerToRawData</strong></td><td align="left">DWORD（4字节）</td><td align="left">节区在文件中的偏移</td></tr><tr><td align="left">PointerToRelocations</td><td align="left">DWORD（4字节）</td><td align="left">.obj文件有效</td></tr><tr><td align="left">PointerToLinenumbers</td><td align="left">DWORD（4字节）</td><td align="left">调试相关</td></tr><tr><td align="left">NumberOfRelocations</td><td align="left">WORD（2字节）</td><td align="left">.obj文件有效</td></tr><tr><td align="left">NumberOfLinenumbers</td><td align="left">WORD（2字节）</td><td align="left">行号表中行号的数量</td></tr><tr><td align="left"><strong>Characteristics</strong></td><td align="left">DWORD（4字节）</td><td align="left">节的属性</td></tr></tbody></table><hr><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><h4 id="官方翻译"><a href="#官方翻译" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>一个8字节、用空填充的UTF-8字符串。如果字符串长度正好是8个字符，则没有结束空字符。对于较长的名称，该成员包含一个正斜杠(/)，后面是十进制数字的ASCII表示形式，<strong>该数字是字符串表中的偏移量</strong>。可执行映像<strong>不使用</strong>字符串表，也<strong>不支持超过8个字符的节名</strong></p><h4 id="通俗版"><a href="#通俗版" class="headerlink" title="通俗版"></a>通俗版</h4><p>ASCII字符串 可自定义 只截取8个 可以8个字节都是名字</p><hr><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="官方翻译-1"><a href="#官方翻译-1" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>Misc 双字，该字段是一个union型的数据，这是该节在<strong>没有对齐前的真实尺寸</strong>,该值<strong>可以不准确</strong></p><hr><h4 id="通俗版-1"><a href="#通俗版-1" class="headerlink" title="通俗版"></a>通俗版</h4><p>这是一个联合结构，可以使用下面两个值其中的任何一个，<strong>一般是取Misc.VirtualSize</strong></p><h4 id="Misc-PhysicalAddress"><a href="#Misc-PhysicalAddress" class="headerlink" title="Misc.PhysicalAddress"></a>Misc.PhysicalAddress</h4><p>文件地址</p><hr><h4 id="Misc-VirtualSize"><a href="#Misc-VirtualSize" class="headerlink" title="Misc.VirtualSize"></a>Misc.VirtualSize</h4><p>节加载到内存时的总大小，以字节为单位。如果该值大于SizeOfRawData成员，则该section将被0填充。此字段仅对可执行Image有效，对于object files应设置为0</p><hr><h3 id="VirtualAddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h3><h4 id="官方翻译-2"><a href="#官方翻译-2" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>section载入内存时的第一个字节的地址，相对于image base。对于object files，这是应用重定位之前的第一个字节的地址</p><h4 id="通俗版-2"><a href="#通俗版-2" class="headerlink" title="通俗版"></a>通俗版</h4><p>在内存中的偏移地址，加上ImageBase才是在内存中的真正地址（VA）</p><p>VA：Full Name Virtual Address（全名虚拟地址）， is the in-memory virtual address（是内存中的虚拟地址）</p><p>VirtualAddress又被称为节区的RVA地址，RVA：Relative Virtual Offset （相对虚拟偏移）</p><p>VA = RVA（VirtualAddress） + ImageBase ，即 内存中的虚拟地址 = 虚拟地址 + 镜像基地址</p><hr><h3 id="SizeOfRawData"><a href="#SizeOfRawData" class="headerlink" title="SizeOfRawData"></a>SizeOfRawData</h3><h4 id="官方翻译-3"><a href="#官方翻译-3" class="headerlink" title="官方翻译"></a>官方翻译</h4><p><strong>磁盘上</strong>初始化数据的大小，以字节为单位。这个值必须是IMAGE_OPTIONAL_HEADER结构文件对齐<strong>FileAlignment</strong>成员的倍数。如果该值小于VirtualSize成员，则节的其余部分将被填充为0。如果该节只包含未初始化的数据，则该成员为零</p><h4 id="通俗版-3"><a href="#通俗版-3" class="headerlink" title="通俗版"></a>通俗版</h4><p>节在文件中对齐后的尺寸</p><hr><h3 id="PointerToRawData"><a href="#PointerToRawData" class="headerlink" title="PointerToRawData"></a>PointerToRawData</h3><h4 id="官方翻译-4"><a href="#官方翻译-4" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>指向COFF文件中的第一页的文件指针。这个值必须是IMAGE_OPTIONAL_HEADER结构文件对齐<strong>FileAlignment</strong>成员的倍数。如果一个section只包含未初始化的数据，则将该成员设为0</p><hr><h4 id="通俗版-4"><a href="#通俗版-4" class="headerlink" title="通俗版"></a>通俗版</h4><p>节区在文件中的偏移，又被称为FOA：File Offset Address 文件偏移地址</p><hr><h3 id="PointerToRelocations"><a href="#PointerToRelocations" class="headerlink" title="PointerToRelocations"></a>PointerToRelocations</h3><h4 id="官方翻译-5"><a href="#官方翻译-5" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>指向该节重定位项开始的文件指针。如果没有重新定位，则此值为零</p><h4 id="通俗版-5"><a href="#通俗版-5" class="headerlink" title="通俗版"></a>通俗版</h4><p>在”.obj”文件中使用，指向重定位表的指针</p><hr><h3 id="PointerToLinenumbers"><a href="#PointerToLinenumbers" class="headerlink" title="PointerToLinenumbers"></a>PointerToLinenumbers</h3><h4 id="官方翻译-6"><a href="#官方翻译-6" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>指向section行号表开头的文件指针。如果没有COFF line numbers，该值为0</p><hr><h4 id="通俗版-6"><a href="#通俗版-6" class="headerlink" title="通俗版"></a>通俗版</h4><p>行号表的位置（供调试用）</p><hr><h3 id="NumberOfRelocations"><a href="#NumberOfRelocations" class="headerlink" title="NumberOfRelocations"></a>NumberOfRelocations</h3><h4 id="官方翻译-7"><a href="#官方翻译-7" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>section重定位表项的数量。对于可执行映像，此值为0</p><hr><h4 id="通俗版-7"><a href="#通俗版-7" class="headerlink" title="通俗版"></a>通俗版</h4><p>重定位表的个数（在OBJ文件中使用）</p><hr><h3 id="NumberOfLinenumbers"><a href="#NumberOfLinenumbers" class="headerlink" title="NumberOfLinenumbers"></a>NumberOfLinenumbers</h3><h4 id="官方翻译-8"><a href="#官方翻译-8" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>section的行号条目的数量</p><hr><h4 id="通俗版-8"><a href="#通俗版-8" class="headerlink" title="通俗版"></a>通俗版</h4><p>行号表中行号的数量</p><hr><h3 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h3><h4 id="官方翻译-9"><a href="#官方翻译-9" class="headerlink" title="官方翻译"></a>官方翻译</h4><p>节的特征。定义了以下值</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">0x00000000</td><td align="left">保留</td></tr><tr><td align="left">无</td><td align="left">0x00000001</td><td align="left">保留</td></tr><tr><td align="left">无</td><td align="left">0x00000002</td><td align="left">保留</td></tr><tr><td align="left">无</td><td align="left">0x00000004</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_TYPE_NO_PAD</td><td align="left">0x00000008</td><td align="left">该节不得填塞至下一边界线。这个标志过时了，被IMAGE_SCN_ALIGN_1BYTES取代</td></tr><tr><td align="left">无</td><td align="left">0x00000010</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_CNT_CODE</td><td align="left">0x00000020</td><td align="left">该节包含可执行代码</td></tr><tr><td align="left">IMAGE_SCN_CNT_INITIALIZED_DATA</td><td align="left">0x00000040</td><td align="left">该节包含初始化的数据</td></tr><tr><td align="left">IMAGE_SCN_CNT_UNINITIALIZED_DATA</td><td align="left">0x00000080</td><td align="left">该节包含未初始化的数据</td></tr><tr><td align="left">IMAGE_SCN_LNK_OTHER</td><td align="left">0x00000100</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_LNK_INFO</td><td align="left">0x00000200</td><td align="left">该节包含解释或其他信息。这只对object files有效</td></tr><tr><td align="left">无</td><td align="left">0x00000400</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_LNK_REMOVE</td><td align="left">0x00000800</td><td align="left">该节将不会成为image的一部分。这只对object files有效。</td></tr><tr><td align="left">IMAGE_SCN_LNK_COMDAT</td><td align="left">0x00001000</td><td align="left">该节包含COMDAT数据。这只对object files有效。</td></tr><tr><td align="left">无</td><td align="left">0x00002000</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_NO_DEFER_SPEC_EXC</td><td align="left">0x00004000</td><td align="left">该节包含重置TLB项中的speculative异常处理位</td></tr><tr><td align="left">IMAGE_SCN_GPREL</td><td align="left">0x00008000</td><td align="left">该节包含通过全局指针引用的数据</td></tr><tr><td align="left">无</td><td align="left">0x00010000</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_MEM_PURGEABLE</td><td align="left">0x00020000</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_MEM_LOCKED</td><td align="left">0x00040000</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_MEM_PRELOAD</td><td align="left">0x00080000</td><td align="left">保留</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_1BYTES</td><td align="left">0x00100000</td><td align="left">在1字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_2BYTES</td><td align="left">0x00200000</td><td align="left">在2字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_4BYTES</td><td align="left">0x00300000</td><td align="left">在4字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_8BYTES</td><td align="left">0x00400000</td><td align="left">在8字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_16BYTES</td><td align="left">0x00500000</td><td align="left">在16字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_32BYTES</td><td align="left">0x00600000</td><td align="left">在32字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_64BYTES</td><td align="left">0x00700000</td><td align="left">在64字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_128BYTES</td><td align="left">0x00800000</td><td align="left">在128字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_256BYTES</td><td align="left">0x00900000</td><td align="left">在256字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_512BYTES</td><td align="left">0x00A00000</td><td align="left">在512字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_1024BYTES</td><td align="left">0x00B00000</td><td align="left">在1024字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_2048BYTES</td><td align="left">0x00C00000</td><td align="left">在2048字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_4096BYTES</td><td align="left">0x00D00000</td><td align="left">在4096字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_ALIGN_8192BYTES</td><td align="left">0x00E00000</td><td align="left">在8192字节的边界上对齐数据。这只对object files有效</td></tr><tr><td align="left">IMAGE_SCN_LNK_NRELOC_OVFL</td><td align="left">0x01000000</td><td align="left">该节包含扩展的重新定位。该节的重定位计数超过了节头中为其保留的16位。如果节头中的NumberOfRelocations字段为0xffff，则实际的重定位计数存储在第一次重定位的VirtualAddress字段中。如果设置了IMAGE_SCN_LNK_NRELOC_OVFL，并且该section中的重定位值小于0xffff，则会产生错误</td></tr><tr><td align="left">IMAGE_SCN_MEM_DISCARDABLE</td><td align="left">0x02000000</td><td align="left">该节可以根据需要丢弃</td></tr><tr><td align="left">IMAGE_SCN_MEM_NOT_CACHED</td><td align="left">0x04000000</td><td align="left">不能缓存该节</td></tr><tr><td align="left">IMAGE_SCN_MEM_NOT_PAGED</td><td align="left">0x08000000</td><td align="left">该节不能分页</td></tr><tr><td align="left">IMAGE_SCN_MEM_SHARED</td><td align="left">0x10000000</td><td align="left">该节可以在内存中共享</td></tr><tr><td align="left">IMAGE_SCN_MEM_EXECUTE</td><td align="left">0x20000000</td><td align="left">该节可以作为代码执行</td></tr><tr><td align="left">IMAGE_SCN_MEM_READ</td><td align="left">0x40000000</td><td align="left">该节可以读</td></tr><tr><td align="left">IMAGE_SCN_MEM_WRITE</td><td align="left">0x80000000</td><td align="left">该节可以写</td></tr></tbody></table><hr><h4 id="通俗版-9"><a href="#通俗版-9" class="headerlink" title="通俗版"></a>通俗版</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401202645060.png" alt="image-20210401202645060"></p><hr><h2 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h2><p>从先前分析的扩展PE头的结尾开始看起，选中部分为节表</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401204202037.png" alt="image-20210401204202037"></p><hr><p>因为有多个节，这里取第一个节进行分析，按顺序依次将数据填入对应的成员得到：</p><table><thead><tr><th align="left">成员</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Name</strong></td><td align="left">2E 74 65 78 74 00 00 00</td><td align="left">对应ASCII为 .text，即节名</td></tr><tr><td align="left">Misc</td><td align="left">0x001990A9</td><td align="left"></td></tr><tr><td align="left"><strong>VirtualAddress</strong></td><td align="left">0x00001000</td><td align="left">RVA=0x1000</td></tr><tr><td align="left"><strong>SizeOfRawData</strong></td><td align="left">0x00199200</td><td align="left">节在文件中对齐后的尺寸为0x00199200</td></tr><tr><td align="left"><strong>PointerToRawData</strong></td><td align="left">0x00000400</td><td align="left">FOA=0x400</td></tr><tr><td align="left">PointerToRelocations</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">PointerToLinenumbers</td><td align="left">0x00000000</td><td align="left"></td></tr><tr><td align="left">NumberOfRelocations</td><td align="left">0x0000</td><td align="left"></td></tr><tr><td align="left">NumberOfLinenumbers</td><td align="left">0x0000</td><td align="left"></td></tr><tr><td align="left"><strong>Characteristics</strong></td><td align="left">0x60000020</td><td align="left">详见下方</td></tr></tbody></table><hr><h3 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h3><p>该节的节名为 .text</p><hr><h3 id="VirtualAddress-1"><a href="#VirtualAddress-1" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h3><p>节的RVA为0x1000</p><p>通过RVA可以得到VA=RVA+ImageBase（在内存中虚拟的地址 = 虚拟地址 + 镜像基地址）</p><p>ImageBase在前面的扩展PE头中已经得知是0x400000，不清楚的可以回顾<a href="https://www.52pojie.cn/thread-1405930-1-1.html#37759493_%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">PE文件笔记五 PE文件头之扩展PE头</a>，这里不再赘述</p><p>所以得到VA=0x1000+0x400000=0x401000</p><p>为了验证这一点，将程序启动，使其加载到内存后再用Winhex查看其状态（具体流程在<a href="https://www.52pojie.cn/thread-1393291-1-1.html#37444347_%E8%BF%90%E8%A1%8C%E6%80%81">PE文件笔记二 PE文件的两种状态</a>中已经说明）</p><p>得到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401210954485.png" alt="image-20210401210954485"></p><hr><p>可以清楚地看到，第一个节的位置对应VA，验证完毕</p><hr><h3 id="Misc和SizeOfRawData"><a href="#Misc和SizeOfRawData" class="headerlink" title="Misc和SizeOfRawData"></a>Misc和SizeOfRawData</h3><p>Misc：该节在没有对齐前的真实尺寸为0x001990A9</p><p>结合前面得到的VA，可以算出，该节在内存中的末尾位置为:VA+Misc=0x401000+0x001990A9=0x59A0A9</p><p>于是要转到相应的位置进行查看：</p><p>在WinHex的底部找到偏移量：XXXX，单击</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401211633311.png" alt="image-20210401211633311"></p><hr><p>在弹出的窗口中修改要跳转的VA（虚拟地址）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401213744534.png" alt="image-20210401213744534"></p><hr><p>跳转后得到：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401213810759.png" alt="image-20210401213810759"></p><p>可以看到，已经跳转到了第一个节的末尾</p><hr><p>SizeOfRawData：该节在文件中对齐后的尺寸为0x00199200</p><p>结合前面得到的VA，可以算出，该节在内存中的末尾位置为:VA+SizeOfRawData=0x401000+0x00199200=0x59A200</p><p>于是要转到相应的位置进行查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401213943737.png" alt="image-20210401213943737"></p><hr><p>发现附近都是00，因为该地址为节在内存中的首地址+<strong>文件对齐</strong>后的地址，<strong>在内存中（运行态）无效</strong></p><p>并且此时会发现SizeOfRawData=0x00199200=(Misc ÷ FileAlignment)<strong>向上取整</strong>×FileAlignment</p><p>即SizeOfRawData=0x00199200=(0x001990A9整除0x200+1)×0x200=（0xCC8+1）×0x200 = 0xCC9 × 0x200 = 0x00199200</p><p>满足SizeOfRawData的定义</p><p>其实SizeOfRawData在<a href="https://www.52pojie.cn/thread-1393291-1-1.html#37444347_%E8%BF%90%E8%A1%8C%E6%80%81">PE文件笔记二 PE文件的两种状态</a>中也已经说明了，这里主要是强调SizeOfRawData在运行态时无效，且验证了SizeOfRawData在运行态时的来源，有关文件对齐和内存对齐等的知识可以前往回顾</p><hr><p>在内存中(运行态时)，实际上 该节在内存中的末尾位置应该为：VA+<strong>内存对齐</strong>后的大小</p><p>但是在节的属性中并没有表示内存对齐后大小的成员，内存对齐后的大小是如何得来的？</p><h4 id="内存对齐后的大小"><a href="#内存对齐后的大小" class="headerlink" title="内存对齐后的大小"></a>内存对齐后的大小</h4><p>决定内存对齐后的大小的因素有2个：</p><ul><li>内存对齐：即SectionAlignment</li><li>Max{Misc,SizeOfRawData}：Misc和SizeOfRawData的最大值</li></ul><p>内存对齐后的大小 = (Max{Misc,SizeOfRawData} ÷ SectionAlignment) <strong>向上取整</strong> × SectionAlignment</p><hr><p>取SizeOfRawData很容易理解，但为什么还和Misc有关？</p><p>Misc表示的是实际大小难道不是一定小于文件对齐后的大小吗？</p><p><strong>并不是</strong>，实际大小也可能要比文件对其后的大小要大，就拿全局变量为例</p><p>全局变量可以分为两种：有初始值的和没有初始值的</p><p>有初始值的全局变量在文件中就已经为其分配了空间，而没有初始值的全局变量只有到程序加载到内存中(运行态)后才会为其分配空间</p><p>假设当前存储的全局变量都是<strong>没有有初始值</strong>的，即在文件中没有为其分配空间，也就是在文件中大小为0，这也就导致SizeOfRawData为0，因此，此时的Misc &gt; SizeOfRawData</p><p>所以<strong>内存对齐后的大小要综合Misc和SizeOfRawData决定</strong></p><hr><p>于是按照上面的公式计算：</p><p>内存对齐后的大小 = (Max{0x001990A9,0x00199200} ÷ 0x1000) <strong>向上取整</strong> × 0x1000 = (0x199200 ÷ 0x1000)向上取整 × 0x1000 = 0x19A000</p><p>该节在内存中的末尾位置应该为：VA+<strong>内存对齐</strong>后的大小 = 0x401000+0x19A000=0x59B000</p><p>再转到相应位置去查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404131954044.png" alt="image-20210404131954044"></p><hr><p>发现已经到达下一个节，和下一个节的起始位置根据VirtualAddress + ImageBase = 0x400000+0x0019b000=0x59B000相匹配</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210404131821611.png" alt="image-20210404131821611"></p><hr><h3 id="PointerToRawData-1"><a href="#PointerToRawData-1" class="headerlink" title="PointerToRawData"></a>PointerToRawData</h3><p>节区在文件中的偏移为0x400，这里引入了一个概念：FOA，即文件偏移地址</p><p>所以PointerToRawData=FOA=文件偏移地址，同样在运行态无效，在<a href="https://www.52pojie.cn/thread-1393291-1-1.html#37444347_%E8%BF%90%E8%A1%8C%E6%80%81">PE文件笔记二 PE文件的两种状态</a>也可以回顾</p><hr><h3 id="Characteristics-1"><a href="#Characteristics-1" class="headerlink" title="Characteristics"></a>Characteristics</h3><p>此时Characteristics=0x60000020=0x40000000+0x20000000+0x00000020</p><p>对照前面的表格：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_SCN_CNT_CODE</td><td align="left">0x00000020</td><td align="left">该节包含可执行代码</td></tr><tr><td align="left">IMAGE_SCN_MEM_EXECUTE</td><td align="left">0x20000000</td><td align="left">该节可以作为代码执行</td></tr><tr><td align="left">IMAGE_SCN_MEM_READ</td><td align="left">0x40000000</td><td align="left">该节可以读</td></tr></tbody></table><p>所以得到了该节的属性为：包含可执行代码、可以作为代码执行、可以读</p><hr><h2 id="自写代码解析节表"><a href="#自写代码解析节表" class="headerlink" title="自写代码解析节表"></a>自写代码解析节表</h2><p>在先前代码的基础上，进一步改进</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\dbgview64.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">    WORD* magic;</span><br><span class="line">    //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">    magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">    //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">    printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">    //根据magic判断为32位程序还是64位程序</span><br><span class="line">    switch (*magic) &#123;</span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;32位程序\n&quot;);</span><br><span class="line">        //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS* nt;</span><br><span class="line">        //让PE文件头指针指向其对应的地址</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while(cnt&lt; nt-&gt;FileHeader.NumberOfSections)&#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER)*cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;64位程序\n&quot;);</span><br><span class="line">        //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">        //创建指向PE文件头的指针</span><br><span class="line">        _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">        nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">        printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">        printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">        //创建一个指针数组，该指针数组用来存储所有的节表指针</span><br><span class="line">        //这里相当于_IMAGE_SECTION_HEADER* sectionArr[nt-&gt;FileHeader.NumberOfSections],声明了一个动态数组</span><br><span class="line">        _IMAGE_SECTION_HEADER** sectionArr = (_IMAGE_SECTION_HEADER**)malloc(sizeof(_IMAGE_SECTION_HEADER*) * nt-&gt;FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">        //创建指向块表的指针</span><br><span class="line">        _IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">        //让块表的指针指向其对应的地址，区别在于这里加上的偏移为_IMAGE_NT_HEADERS64</span><br><span class="line">        sectionHeader = (_IMAGE_SECTION_HEADER*)((UINT)nt + sizeof(_IMAGE_NT_HEADERS64));</span><br><span class="line">        //计数，用来计算块表地址</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        //比较 计数 和 块表的个数，即遍历所有块表</span><br><span class="line">        while (cnt &lt; nt-&gt;FileHeader.NumberOfSections) &#123;</span><br><span class="line">            //创建指向块表的指针</span><br><span class="line">            _IMAGE_SECTION_HEADER* section;</span><br><span class="line">            //让块表的指针指向其对应的地址=第一个块表地址+计数*块表的大小</span><br><span class="line">            section = (_IMAGE_SECTION_HEADER*)((UINT)sectionHeader + sizeof(_IMAGE_SECTION_HEADER) * cnt);</span><br><span class="line">            //将得到的块表指针存入数组</span><br><span class="line">            sectionArr[cnt++] = section;</span><br><span class="line">            //输出块表名称</span><br><span class="line">            printf(&quot;%s\n&quot;, section-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;error!\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="32位运行结果"><a href="#32位运行结果" class="headerlink" title="32位运行结果"></a>32位运行结果</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401230600646.png" alt="image-20210401230600646"></p><hr><h4 id="64位运行结果"><a href="#64位运行结果" class="headerlink" title="64位运行结果"></a>64位运行结果</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210401230508810.png" alt="image-20210401230508810"></p><hr><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>代码基于上一次的笔记<a href="https://www.52pojie.cn/thread-1405930-1-1.html">PE文件笔记五 PE文件头之扩展PE头</a>增加了对块表的解析</p><p>此次代码中用到了动态声明数组，只不过声明的数组为指针数组</p><p>关于指针数组可以回顾<a href="https://www.52pojie.cn/thread-1388861-1-1.html">逆向基础笔记二十三 汇编 指针（四）</a></p><p>这里补充一下动态数组的声明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">int main() &#123;   </span><br><span class="line">    //普通的数组声明</span><br><span class="line">    int arr[5];</span><br><span class="line">    //动态的数组声明</span><br><span class="line">    int num = 5;</span><br><span class="line">    int* arr2 =(int*) malloc(sizeof(int) * 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>普通的数组声明转动态的数组声明</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">int main() &#123;   </span><br><span class="line">    //普通的数组声明</span><br><span class="line">    类型 arr[5];</span><br><span class="line">    //动态的数组声明</span><br><span class="line">    int num = 5;</span><br><span class="line">    类型* arr2 =(类型*) malloc(sizeof(类型) * 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前面的代码无非就是类型为_IMAGE_SECTION_HEADER*的情况</p><p>代入可得</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">int main() &#123;   </span><br><span class="line">    //普通的数组声明</span><br><span class="line">    _IMAGE_SECTION_HEADER* arr[5];</span><br><span class="line">    //动态的数组声明</span><br><span class="line">    int num = 5;</span><br><span class="line">    _IMAGE_SECTION_HEADER** arr2 =(_IMAGE_SECTION_HEADER**) malloc(sizeof(_IMAGE_SECTION_HEADER*) * 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>大致将PE文件的各个结构都说明了一遍，数据目录项之后也会补充，掌握了结构后，就要开始操作这些结构了</p><p>在节表中比较重要的成员就是和内存对齐或文件对齐有关的那几个成员，这次的笔记也稍微提到了FOA、RVA、VA的概念，为后续作个铺垫</p><p>PE文件的学习可能有些枯燥，但只有在了解了其结构以后才能更好地搞事情<del>(￣▽￣)</del>*</p><p>现在看似只是做个类似弱化的PEID，只能读取PE文件的相关数据貌似没有什么意思</p><p>后续有了PE的知识，就可以结合知识，来修改程序使其呈现我们想要的内容以及自己写个保护壳等等，尽请期待</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一个<a href="https://www.52pojie.cn/thread-1407996-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记五 PE文件头之扩展PE头</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%935/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%935/</url>
      
        <content type="html"><![CDATA[<p>继续具体学习PE的各个结构细节，前面学完了标准PE头，接着学习扩展PE头</p><p>由于PE文件头的内容较多，故要拆分为多个笔记，此笔记主要为<strong>扩展PE头</strong></p><p>PS：扩展PE头的成员较多，可以<strong>先看个大概后结合下面的实战分析</strong>来学习扩展PE头的成员</p><h1 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h1><h2 id="扩展PE头所属"><a href="#扩展PE头所属" class="headerlink" title="扩展PE头所属"></a>扩展PE头所属</h2><p><strong>扩展PE头是PE文件头中的一个成员</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328200236487.png" alt="img"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210329125412730.png" alt="img"></p><hr><h3 id="32位所属"><a href="#32位所属" class="headerlink" title="32位所属"></a>32位所属</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;                                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                               //标准PE头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;                                //扩展PE头 32位</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><hr><h3 id="64位所属"><a href="#64位所属" class="headerlink" title="64位所属"></a>64位所属</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">    DWORD Signature;                                       //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;                          //标准PE头        </span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;                //扩展PE头 64位</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><hr><h2 id="两种扩展PE头差异"><a href="#两种扩展PE头差异" class="headerlink" title="两种扩展PE头差异"></a>两种扩展PE头差异</h2><h3 id="两种结构"><a href="#两种结构" class="headerlink" title="两种结构"></a>两种结构</h3><p>扩展PE头的结构根据程序是32位或64位而分成了两种结构，而PE文件头则因扩展PE头的差异也被分成了两种结构</p><table><thead><tr><th align="left">PE文件头结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">_IMAGE_NT_HEADERS</td><td align="left">32位程序对应的PE文件头结构</td></tr><tr><td align="left">_IMAGE_NT_HEADERS64</td><td align="left">64位程序对应的PE文件头结构</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER32</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER32</strong></td><td align="left">扩展PE头 32位</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS64</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识，固定值不可变</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER64</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER64</strong></td><td align="left">扩展PE头 64位</td></tr></tbody></table><hr><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><h4 id="32位结构体"><a href="#32位结构体" class="headerlink" title="32位结构体"></a>32位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><h4 id="64位结构体"><a href="#64位结构体" class="headerlink" title="64位结构体"></a>64位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;</span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><hr><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><table><thead><tr><th align="left">成员\扩展PE头</th><th align="left">_IMAGE_OPTIONAL_HEADER</th><th align="left">_IMAGE_OPTIONAL_HEADER64</th></tr></thead><tbody><tr><td align="left">BaseOfData</td><td align="left">DWORD</td><td align="left">无此成员</td></tr><tr><td align="left">ImageBase</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">DWORD</td><td align="left">ULONGLONG</td></tr></tbody></table><p>可以看到，64位相比于32位其实并没有太大的区别，只是删去了一个成员 以及 五个成员的数据类型由DWORD变为ULONGLONG</p><p>因为其<strong>区别并不明显</strong>，因此以<strong>32位</strong>结构体作为例子分析，64位结构体也<strong>近似相同</strong></p><hr><h2 id="32位扩展PE头分析"><a href="#32位扩展PE头分析" class="headerlink" title="32位扩展PE头分析"></a>32位扩展PE头分析</h2><p>扩展PE头中的成员较多，一般情况只需掌握部分重点即可（重点为表格中加黑的成员）</p><p>下面的分析参考自官方文档：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">ns-winnt-image_optional_header32</a>和《Windows PE 权威指南》</p><p>PS：下面的分析较为冗长,类似参考文档，<strong>可以先跳过，先看下面的实战分析</strong>，<strong>根据实战里的数据到对应的成员参考其含义</strong></p><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Magic</strong></td><td align="left">WORD(2字节)</td><td align="left">镜像文件的状态，可用于判断程序是32位还是64位</td></tr><tr><td align="left">MajorLinkerVersion</td><td align="left">BYTE(字节)</td><td align="left">链接器的主要版本号</td></tr><tr><td align="left">MinorLinkerVersion</td><td align="left">BYTE(字节)</td><td align="left">链接器的次要版本号</td></tr><tr><td align="left">SizeOfCode</td><td align="left">DWORD(4字节)</td><td align="left">代码段的大小</td></tr><tr><td align="left">SizeOfInitializedData</td><td align="left">DWORD(4字节)</td><td align="left">初始化数据段的大小</td></tr><tr><td align="left">SizeOfUninitializedData</td><td align="left">DWORD(4字节)</td><td align="left">未初始化数据段的大小</td></tr><tr><td align="left"><strong>AddressOfEntryPoint</strong></td><td align="left">DWORD(4字节)</td><td align="left">程序入口</td></tr><tr><td align="left">BaseOfCode</td><td align="left">DWORD(4字节)</td><td align="left">代码开始的基址</td></tr><tr><td align="left">BaseOfData</td><td align="left">DWORD(4字节)</td><td align="left">数据开始的基址</td></tr><tr><td align="left"><strong>ImageBase</strong></td><td align="left">DWORD(4字节)</td><td align="left">内存镜像基址</td></tr><tr><td align="left"><strong>SectionAlignment</strong></td><td align="left">DWORD(4字节)</td><td align="left">内存对齐</td></tr><tr><td align="left"><strong>FileAlignment</strong></td><td align="left">WORD(2字节)</td><td align="left">文件对齐</td></tr><tr><td align="left">MajorOperatingSystemVersion</td><td align="left">WORD(2字节)</td><td align="left">标识操作系统版本号 主版本号</td></tr><tr><td align="left">MinorOperatingSystemVersion</td><td align="left">WORD(2字节)</td><td align="left">标识操作系统版本号 次版本号</td></tr><tr><td align="left">MajorImageVersion</td><td align="left">WORD(2字节)</td><td align="left">PE文件自身的版本号</td></tr><tr><td align="left">MinorImageVersion</td><td align="left">WORD(2字节)</td><td align="left">PE文件自身的版本号</td></tr><tr><td align="left">MajorSubsystemVersion</td><td align="left">WORD(2字节)</td><td align="left">运行所需子系统版本号</td></tr><tr><td align="left">MinorSubsystemVersion</td><td align="left">WORD(2字节)</td><td align="left">运行所需子系统版本号</td></tr><tr><td align="left">Win32VersionValue</td><td align="left">DWORD(4字节)</td><td align="left">子系统版本的值，必须为0</td></tr><tr><td align="left"><strong>SizeOfImage</strong></td><td align="left">DWORD(4字节)</td><td align="left">Image大小</td></tr><tr><td align="left"><strong>SizeOfHeaders</strong></td><td align="left">DWORD(4字节)</td><td align="left">所有头+节表按照文件对齐后的大小</td></tr><tr><td align="left"><strong>CheckSum</strong></td><td align="left">DWORD(4字节)</td><td align="left">校验和</td></tr><tr><td align="left">Subsystem</td><td align="left">WORD(2字节)</td><td align="left">子系统</td></tr><tr><td align="left">DllCharacteristics</td><td align="left">WORD(2字节)</td><td align="left">文件特性 不只是针对DLL文件的</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">DWORD(4字节)</td><td align="left">初始化时保留的栈大小</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">DWORD(4字节)</td><td align="left">初始化时实际提交的大小</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">DWORD(4字节)</td><td align="left">初始化时保留的堆大小</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">DWORD(4字节)</td><td align="left">初始化时实践提交的大小</td></tr><tr><td align="left">LoaderFlags</td><td align="left">DWORD(4字节)</td><td align="left">调试相关</td></tr><tr><td align="left">NumberOfRvaAndSizes</td><td align="left">DWORD(4字节)</td><td align="left">目录项数目</td></tr><tr><td align="left"><strong>DataDirectory[16]</strong></td><td align="left">IMAGE_DATA_DIRECTORY[16]=128字节</td><td align="left">指向数据目录中第一个IMAGE_DATA_DIRECTORY结构的指针**(数据目录项)**</td></tr></tbody></table><hr><h3 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h3><p>镜像文件的状态。该成员可以是以下值之一</p><table><thead><tr><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_NT_OPTIONAL_HDR_MAGIC</td><td align="left">该文件是一个可执行的映像。这个值在32位应用程序中定义为IMAGE_NT_OPTIONAL_HDR32_MAGIC，在64位应用程序中定义为IMAGE_NT_OPTIONAL_HDR64_MAGIC</td></tr><tr><td align="left">IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b</td><td align="left">该文件是一个可执行的映像（32位）</td></tr><tr><td align="left">IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b</td><td align="left">该文件是一个可执行的映像（64位）</td></tr><tr><td align="left">IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107</td><td align="left">该文件是ROM镜像</td></tr></tbody></table><hr><h3 id="MajorLinkerVersion"><a href="#MajorLinkerVersion" class="headerlink" title="MajorLinkerVersion"></a>MajorLinkerVersion</h3><p>链接器版本号</p><hr><h3 id="MinorLinkerVersion"><a href="#MinorLinkerVersion" class="headerlink" title="MinorLinkerVersion"></a>MinorLinkerVersion</h3><p>链接器次要版本号</p><hr><h3 id="SizeOfCode"><a href="#SizeOfCode" class="headerlink" title="SizeOfCode"></a>SizeOfCode</h3><p>代码段的大小(以字节为单位)，如果有多个代码段，则为所有这些代码段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="SizeOfInitializedData"><a href="#SizeOfInitializedData" class="headerlink" title="SizeOfInitializedData"></a>SizeOfInitializedData</h3><p>初始化数据段的大小(以字节为单位)，如果有多个初始化数据段，则为所有这些数据段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="SizeOfUninitializedData"><a href="#SizeOfUninitializedData" class="headerlink" title="SizeOfUninitializedData"></a>SizeOfUninitializedData</h3><p>未初始化数据段的大小(以字节为单位)，如果有多个未初始化数据段，则为所有这些数据段的总和。是文件对齐后的大小 编译器填的 没用（不一定准确）</p><hr><h3 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h3><p>一个指向入口点函数的指针，<strong>相对</strong>于Image的基址。</p><ol><li>对于可执行文件，这是起始地址</li><li>对于设备驱动程序，这是初始化函数的地址</li><li>入口点函数对于dll是可选的。当没有入口点存在时，该成员为零</li></ol><hr><h3 id="BaseOfCode"><a href="#BaseOfCode" class="headerlink" title="BaseOfCode"></a>BaseOfCode</h3><p>指向代码段开头的指针，相对于ImageBase。编译器填的 没用（不一定准确）</p><hr><h3 id="BaseOfData"><a href="#BaseOfData" class="headerlink" title="BaseOfData"></a>BaseOfData</h3><p>指向数据段开头的指针，相对于ImageBase。编译器填的 没用（不一定准确）</p><hr><h3 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a>ImageBase</h3><p>Image(PE文件)载入内存时第一个字节的首选地址。<strong>该值是64K字节的倍数</strong></p><ul><li>dll的默认值是0x10000000</li><li>应用程序的默认值为0x00400000,</li><li>Windows CE上的默认值为0x00010000</li></ul><hr><h3 id="SectionAlignment"><a href="#SectionAlignment" class="headerlink" title="SectionAlignment"></a>SectionAlignment</h3><p>加载到内存中的节的对齐方式，以字节为单位。该值必须大于或等于<strong>FileAlignment</strong>(文件对齐)成员。默认值是系统的页面大小</p><hr><h3 id="FileAlignment"><a href="#FileAlignment" class="headerlink" title="FileAlignment"></a>FileAlignment</h3><p>Image(PE文件)中各节的原始数据(以字节为单位)的对齐方式。该值应该是512到64K(包括)之间2的幂。缺省值是512。如果SectionAlignment成员小于系统页面大小，则该成员必须与SectionAlignment相同</p><hr><h3 id="MajorOperatingSystemVersion"><a href="#MajorOperatingSystemVersion" class="headerlink" title="MajorOperatingSystemVersion"></a>MajorOperatingSystemVersion</h3><p>所需操作系统的主要版本号</p><hr><h3 id="MinorOperatingSystemVersion"><a href="#MinorOperatingSystemVersion" class="headerlink" title="MinorOperatingSystemVersion"></a>MinorOperatingSystemVersion</h3><p>所需操作系统的次要版本号</p><hr><h3 id="MajorImageVersion"><a href="#MajorImageVersion" class="headerlink" title="MajorImageVersion"></a>MajorImageVersion</h3><p>镜像（PE文件）的主版本号</p><hr><h3 id="MinorImageVersion"><a href="#MinorImageVersion" class="headerlink" title="MinorImageVersion"></a>MinorImageVersion</h3><p>镜像（PE文件）的次要版本号</p><hr><h3 id="MajorSubsystemVersion"><a href="#MajorSubsystemVersion" class="headerlink" title="MajorSubsystemVersion"></a>MajorSubsystemVersion</h3><p>子系统的主要版本号</p><hr><h3 id="Win32VersionValue"><a href="#Win32VersionValue" class="headerlink" title="Win32VersionValue"></a>Win32VersionValue</h3><p>该成员是保留的，并且必须为0</p><hr><h3 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h3><p>Image的大小，以字节为单位，包括所有头。必须是多个SectionAlignment</p><p>内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment的整数倍</p><hr><h3 id="SizeOfHeaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a>SizeOfHeaders</h3><p>下列项的组合大小，舍入为“文件对齐”成员中指定值的倍数</p><ul><li>IMAGE_DOS_HEADER（DOS MZ头） 中的最后一个成员e_lfanew </li><li>PE文件头标志 signature 的 大小 4字节</li><li>IMAGE_FILE_HEADER（标准PE头）的大小</li><li>扩展PE头的大小</li><li>所有节头（节表）的大小</li></ul><p>SizeOfHeaders=</p><p>{</p><p>e_lfanew</p><p>+sizeof(signature)</p><p>+sizeof(_IMAGE_FILE_HEADER)</p><p>+sizeof(_IMAGE_OPTIONAL_HEADER)</p><p>+sizeof(_IMAGE_SECTION_HEADER)</p><p>}(文件对齐)</p><p>即 DOS部首+PE文件头+节表 按照文件对齐后的大小</p><hr><h3 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a>CheckSum</h3><p>Image(PE文件)校验和。以下文件在加载时进行验证:所有驱动程序，在引导时加载的任何DLL，以及加载到关键系统进程中的任何DLL</p><hr><h3 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h3><p>运行此映像所需的子系统。定义了以下值：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_SUBSYSTEM_UNKNOWN</td><td align="left">0</td><td align="left">未知的子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_NATIVE</td><td align="left">1</td><td align="left">不需要子系统(设备驱动程序和本机系统进程)</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_GUI</td><td align="left">2</td><td align="left">Windows图形用户界面子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_CUI</td><td align="left">3</td><td align="left">Windows字符模式用户界面(CUI)子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_OS2_CUI</td><td align="left">5</td><td align="left">OS/2 CUI子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_POSIX_CUI</td><td align="left">7</td><td align="left">POSIX CUI子系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td><td align="left">9</td><td align="left">Windows CE系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_APPLICATION</td><td align="left">10</td><td align="left">可扩展固件接口(EFI)应用程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER</td><td align="left">11</td><td align="left">带有引导服务的EFI驱动程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</td><td align="left">12</td><td align="left">带有运行时服务的EFI驱动程序</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_EFI_ROM</td><td align="left">13</td><td align="left">EFI ROM镜像</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_XBOX</td><td align="left">14</td><td align="left">Xbox系统</td></tr><tr><td align="left">IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION</td><td align="left">16</td><td align="left">启动应用程序</td></tr></tbody></table><hr><h3 id="DllCharacteristics"><a href="#DllCharacteristics" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h3><h4 id="官方文档版本"><a href="#官方文档版本" class="headerlink" title="官方文档版本"></a>官方文档版本</h4><p>Image的DLL特性，定义了以下值</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">0x0001</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0002</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0004</td><td align="left">保留，必须为0</td></tr><tr><td align="left">无</td><td align="left">0x0008</td><td align="left">保留，必须为0</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA</td><td align="left">0x0020</td><td align="left">具有64位地址空间的ASLR</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</td><td align="left">0x0040</td><td align="left">DLL可以在加载时重新定位</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</td><td align="left">0x0080</td><td align="left">强制进行代码完整性检查。如果你设置了这个标志，并且section只包含未初始化的数据，那么将该section的IMAGE_SECTION_HEADER的PointerToRawData成员设置为0;否则，由于无法验证数字签名，Image将无法加载</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NX_COMPAT</td><td align="left">0x0100</td><td align="left">该映像与数据执行预防(DEP)兼容</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</td><td align="left">0x0200</td><td align="left">映像可以被隔离，但不应该被隔离</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_SEH</td><td align="left">0x0400</td><td align="left">该映像不使用结构化异常处理(SEH)。在此映像中不能调用任何处理程序</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_NO_BIND</td><td align="left">0x0800</td><td align="left">不要绑定映像</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_APPCONTAINER</td><td align="left">0x1000</td><td align="left">映像应该在AppContainer中执行</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</td><td align="left">0x2000</td><td align="left">一个WDM驱动</td></tr><tr><td align="left">IMAGE_DLL_CHARACTERISTICS_GUARD_CF</td><td align="left">0x4000</td><td align="left">映像支持控制流保护(Control Flow Guard)</td></tr><tr><td align="left">IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</td><td align="left">0x8000</td><td align="left">该映像是终端服务器感知的</td></tr></tbody></table><hr><h4 id="PE权威指南版本"><a href="#PE权威指南版本" class="headerlink" title="PE权威指南版本"></a>PE权威指南版本</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330140944224.png" alt="image-20210330140944224"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330141007450.png" alt="image-20210330141007450"></p><hr><h3 id="SizeOfStackReserve"><a href="#SizeOfStackReserve" class="headerlink" title="SizeOfStackReserve"></a>SizeOfStackReserve</h3><p>为堆栈保留的字节数。只有SizeOfStackCommit成员指定的内存在加载时被提交;其余的页面每次只提供一个页面，直到达到这个预留大小</p><hr><h3 id="SizeOfStackCommit"><a href="#SizeOfStackCommit" class="headerlink" title="SizeOfStackCommit"></a>SizeOfStackCommit</h3><p>要提交给堆栈的字节数</p><hr><h3 id="SizeOfHeapReserve"><a href="#SizeOfHeapReserve" class="headerlink" title="SizeOfHeapReserve"></a>SizeOfHeapReserve</h3><p>为本地堆保留的字节数。只有SizeOfHeapCommit成员指定的内存在加载时被提交;其余的页面每次只提供一个页面，直到达到这个预留大小</p><hr><h3 id="SizeOfHeapCommit"><a href="#SizeOfHeapCommit" class="headerlink" title="SizeOfHeapCommit"></a>SizeOfHeapCommit</h3><p>要为本地堆提交的字节数</p><hr><h3 id="LoaderFlags"><a href="#LoaderFlags" class="headerlink" title="LoaderFlags"></a>LoaderFlags</h3><p>该成员已过时</p><hr><h3 id="NumberOfRvaAndSizes"><a href="#NumberOfRvaAndSizes" class="headerlink" title="NumberOfRvaAndSizes"></a>NumberOfRvaAndSizes</h3><p>可选头的其余部分中的目录条目数。每个条目都描述了一个位置和大小</p><hr><h3 id="DataDirectory"><a href="#DataDirectory" class="headerlink" title="DataDirectory"></a>DataDirectory</h3><p>指向数据目录中第一个IMAGE_DATA_DIRECTORY结构的指针</p><p>所需目录条目的索引号。该参数可以是以下值之一：</p><table><thead><tr><th align="left">宏定义</th><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td><td align="left">7</td><td align="left">特定于体系结构的数据，预留为0</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_BASERELOC</td><td align="left">5</td><td align="left">基地址重定位表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td><td align="left">11</td><td align="left">绑定导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td><td align="left">14</td><td align="left">COM描述符表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_DEBUG</td><td align="left">6</td><td align="left">调试表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td><td align="left">13</td><td align="left">延迟导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_EXCEPTION</td><td align="left">3</td><td align="left">异常表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_EXPORT</td><td align="left">0</td><td align="left">导出表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td><td align="left">8</td><td align="left">全局指针的相对虚拟地址</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_IAT</td><td align="left">12</td><td align="left">导入地址表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_IMPORT</td><td align="left">1</td><td align="left">导入表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td><td align="left">10</td><td align="left">加载配置表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_RESOURCE</td><td align="left">2</td><td align="left">资源表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_SECURITY</td><td align="left">4</td><td align="left">安全表</td></tr><tr><td align="left">IMAGE_DIRECTORY_ENTRY_TLS</td><td align="left">9</td><td align="left">线程本地存储表</td></tr></tbody></table><hr><h2 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h2><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>从先前分析的标准PE头的结尾开始看起，选中部分为扩展PE头，共占224字节</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330141822154.png" alt="image-20210330141822154"></p><hr><p>按顺序依次将数据填入对应的成员得到：</p><table><thead><tr><th align="left">成员</th><th align="left">值</th></tr></thead><tbody><tr><td align="left"><strong>Magic</strong></td><td align="left">0x010B</td></tr><tr><td align="left">MajorLinkerVersion</td><td align="left">0x09</td></tr><tr><td align="left">MinorLinkerVersion</td><td align="left">0x00</td></tr><tr><td align="left">SizeOfCode</td><td align="left">0x00199200</td></tr><tr><td align="left">SizeOfInitializedData</td><td align="left">0x000BEC00</td></tr><tr><td align="left">SizeOfUninitializedData</td><td align="left">0x00000000</td></tr><tr><td align="left"><strong>AddressOfEntryPoint</strong></td><td align="left">0x0016AF12</td></tr><tr><td align="left">BaseOfCode</td><td align="left">0x00001000</td></tr><tr><td align="left">BaseOfData</td><td align="left">0x0019B000</td></tr><tr><td align="left"><strong>ImageBase</strong></td><td align="left">0x00400000</td></tr><tr><td align="left"><strong>SectionAlignment</strong></td><td align="left">0x00001000</td></tr><tr><td align="left"><strong>FileAlignment</strong></td><td align="left">0x00000200</td></tr><tr><td align="left">MajorOperatingSystemVersion</td><td align="left">0x0005</td></tr><tr><td align="left">MinorOperatingSystemVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MajorImageVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MinorImageVersion</td><td align="left">0x0000</td></tr><tr><td align="left">MajorSubsystemVersion</td><td align="left">0x0005</td></tr><tr><td align="left">MinorSubsystemVersion</td><td align="left">0x0000</td></tr><tr><td align="left">Win32VersionValue</td><td align="left">0x00000000</td></tr><tr><td align="left"><strong>SizeOfImage</strong></td><td align="left">0x00298000</td></tr><tr><td align="left"><strong>SizeOfHeaders</strong></td><td align="left">0x00000400</td></tr><tr><td align="left"><strong>CheckSum</strong></td><td align="left">0x0025cd89</td></tr><tr><td align="left">Subsystem</td><td align="left">0x0002</td></tr><tr><td align="left">DllCharacteristics</td><td align="left">0x8140</td></tr><tr><td align="left">SizeOfStackReserve</td><td align="left">0x00100000</td></tr><tr><td align="left">SizeOfStackCommit</td><td align="left">0x00001000</td></tr><tr><td align="left">SizeOfHeapReserve</td><td align="left">0x00100000</td></tr><tr><td align="left">SizeOfHeapCommit</td><td align="left">0x00001000</td></tr><tr><td align="left">LoaderFlags</td><td align="left">0x00000000</td></tr><tr><td align="left">NumberOfRvaAndSizes</td><td align="left">0x00000010</td></tr><tr><td align="left"><strong>DataDirectory[16]</strong></td><td align="left">留作之后的笔记</td></tr></tbody></table><hr><h3 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h3><p><strong>鉴于篇幅和实用性考虑，只分析比较重要的成员</strong></p><hr><h4 id="Magic-1"><a href="#Magic-1" class="headerlink" title="Magic"></a>Magic</h4><p>Magic的值为0x010B，根据前面的分析可知：该文件是一个可执行的映像（32位）</p><hr><h4 id="AddressOfEntryPoint-1"><a href="#AddressOfEntryPoint-1" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h4><p>AddressOfEntryPoint的值为0x0016AF12，根据前面的分析可知：一个指向入口点函数的指针，<strong>相对</strong>于Image的基址是0x0016AF12</p><p>而Image的基址就是后面的 ImageBase = 0x00400000</p><p>于是该指针的的绝对地址为基址+偏移=0x00400000+0x0016AF12=0x0056AF12</p><p>于是得到了该程序的程序入口点为0x0056AF12，为了验证其准确性，使用OD打开程序</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144334813.png" alt="image-20210330144334813"></p><p>可以看到OD自动中断在了程序入口点0x0056AF12</p><hr><p>PS：如果OD暂停到了其它地方，则需要设置一下OD的中断点：</p><p>选项→调试设置（或使用快捷键Alt+0）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144509629.png" alt="image-20210330144509629"></p><hr><p>事件→主模块入口点</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330144628298.png" alt="image-20210330144628298"></p><hr><h4 id="ImageBase-1"><a href="#ImageBase-1" class="headerlink" title="ImageBase"></a>ImageBase</h4><p>ImageBase的值为0x00400000，根据前面的分析可知：ImageBase正好是应用程序的默认值0x00400000</p><p>且ImageBase=0x00400000是64K字节的倍数</p><hr><h4 id="SectionAlignment、FileAlignment、SizeOfHeaders"><a href="#SectionAlignment、FileAlignment、SizeOfHeaders" class="headerlink" title="SectionAlignment、FileAlignment、SizeOfHeaders"></a>SectionAlignment、FileAlignment、SizeOfHeaders</h4><p>有关内存对齐和文件对齐的相关内容 在<a href="https://www.52pojie.cn/thread-1393291-1-1.html">PE文件笔记二 PE文件的两种状态</a>已经学习过了，这里不再赘述</p><hr><h4 id="SizeOfImage-1"><a href="#SizeOfImage-1" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h4><p>SizeOfImage的值为0x00298000，根据前面的分析可知：</p><p>SizeOfImage表示内存中整个PE文件的映射的尺寸，可比实际的值大，必须是SectionAlignment的整数倍</p><p>于是打开程序，并使用WinHex查看其在内存中的状态（在<a href="https://www.52pojie.cn/thread-1393291-1-1.html">PE文件笔记二 PE文件的两种状态</a>中已经演示过，这里不再赘述，直接看结果）</p><p>用WinHex附加上程序后，拉到最底部，查看文件的最大偏移量</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330150941336.png" alt="image-20210330150941336"></p><hr><p>可以看到此时的最大偏移量为697FFF，用最大偏移量减去ImageBase 0x400000得到相对偏移为297FFF=SizeOfImage-1</p><p>验证了SizeOfImage可以比实际的值大</p><p>再验证SizeOfImage为内存对齐SectionAlignment的整数倍：</p><p>SizeOfImage/SectionAlignment=0x00298000/0x1000=0x298，可以整除，验证完毕</p><hr><h4 id="CheckSum-1"><a href="#CheckSum-1" class="headerlink" title="CheckSum"></a>CheckSum</h4><p>CheckSum从头部开始 两两字节不断相加，一直相加到最后，期间如果溢出，则直接舍去溢出部分，最后加完的结果再加上整个文件的长度就得到了CheckSum，操作系统就是通过这种方式来检验文件是否被修改</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152330856.png" alt="image-20210330152330856"></p><hr><p>但只对以下文件在加载时进行验证:所有驱动程序，在引导时加载的任何DLL，以及加载到关键系统进程中的任何DLL</p><p>此时程序本身并不属于上面提到的文件类型，于是此时的CheckSum并不生效</p><p>由于CheckSum的计算比较麻烦，于是这里就略去CheckSum计算的验证，简单说明了CheckSum的计算原理</p><p>下面来验证一下CheckSum的作用范围，此时程序的CheckSum应该是无效的</p><p>CheckSum的值为0x0025cd89，将它修改为0</p><p><strong>1.找到CheckSum</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152551798.png" alt="image-20210330152551798"></p><hr><p><strong>2.选中CheckSum，鼠标右键→编辑</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152634764.png" alt="image-20210330152634764"></p><hr><p><strong>3.填充选块</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152830026.png" alt="image-20210330152830026"></p><hr><p><strong>4.填充0</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152847852.png" alt="image-20210330152847852"></p><hr><p><strong>5.修改完毕</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152923193.png" alt="image-20210330152923193"></p><hr><p><strong>6.保存，然后打开程序</strong></p><p>使用快捷键 Ctrl+S 保存，确定</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330152952218.png" alt="image-20210330152952218"></p><hr><p>打开程序，依旧可以正常运行，验证完毕</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330153037836.png" alt="image-20210330153037836"></p><hr><h4 id="Subsystem-1"><a href="#Subsystem-1" class="headerlink" title="Subsystem"></a>Subsystem</h4><p>Subsystem的值为0x0002，根据前面的分析可知：运行该程序所需子系统为：Windows图形用户界面子系统</p><hr><h4 id="DllCharacteristics-1"><a href="#DllCharacteristics-1" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h4><p>DllCharacteristics的值为0x8140</p><h5 id="通过PE权威指南"><a href="#通过PE权威指南" class="headerlink" title="通过PE权威指南"></a>通过PE权威指南</h5><p>转化为二进制得到：1000000101000000</p><p>数据位为1的位数有：第6位，第8位，第15位</p><p>根据前面的分析可知：DLL可以在加载时重新定位、该映像与数据执行预防(DEP)兼容、该映像是终端服务器感知的</p><hr><h5 id="通过官方文档"><a href="#通过官方文档" class="headerlink" title="通过官方文档"></a>通过官方文档</h5><p>DllCharacteristics的值为0x8140=0x8000+0x0100+0x0040</p><p>根据前面的分析可知：DLL可以在加载时重新定位、该映像与数据执行预防(DEP)兼容、该映像是终端服务器感知的</p><hr><h2 id="自写代码解析PE文件头"><a href="#自写代码解析PE文件头" class="headerlink" title="自写代码解析PE文件头"></a>自写代码解析PE文件头</h2><p>在先前代码的基础上，进一步改进</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winnt.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">        //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">        //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Users\\lyl610abc\\Desktop\\dbgview64.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">        //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">        //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">        //类型转换，用结构体的方式来读取</span><br><span class="line">        dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">        //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">        printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">        //创建指向PE文件头标志的指针</span><br><span class="line">        DWORD* peId;</span><br><span class="line">        //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">        peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">        //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">        printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">        //创建指向可选PE头的第一个成员magic的指针</span><br><span class="line">        WORD* magic;</span><br><span class="line">        //让magic指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小+标准PE头大小</span><br><span class="line">        magic = (WORD*)((UINT)peId + sizeof(DWORD) + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出magic，其值为0x10b代表32位程序，其值为0x20b代表64位程序</span><br><span class="line">        printf(&quot;magic:%X\n&quot;, *magic);</span><br><span class="line">        //根据magic判断为32位程序还是64位程序</span><br><span class="line">        switch (*magic) &#123;</span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;32位程序\n&quot;);</span><br><span class="line">                //确定为32位程序后，就可以使用_IMAGE_NT_HEADERS来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS* nt;</span><br><span class="line">                //让PE文件头指针指向其对应的地址</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;64位程序\n&quot;);</span><br><span class="line">                //确定为64位程序后，就可以使用_IMAGE_NT_HEADERS64来接收数据了</span><br><span class="line">                //创建指向PE文件头的指针</span><br><span class="line">                _IMAGE_NT_HEADERS64* nt;</span><br><span class="line">                nt = (_IMAGE_NT_HEADERS64*)peId;</span><br><span class="line">                printf(&quot;Machine:%X\n&quot;, nt-&gt;FileHeader.Machine);</span><br><span class="line">                printf(&quot;Magic:%X\n&quot;, nt-&gt;OptionalHeader.Magic);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;error!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330165824365.png" alt="image-20210330165824365"></p><h4 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330165958055.png" alt="image-20210330165958055"></p><hr><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><p>代码基于上一次的笔记<a href="https://www.52pojie.cn/thread-1404818-1-1.html#37730344_%E4%BB%A3%E7%A0%81%E5%B0%8F%E8%A7%A3">PE文件笔记四 PE文件头之标准PE头</a>改进了判断程序32位或64位的方法，并没有什么太大的变动，有关代码的分析在上一次笔记已经给出，这里也就不再赘述</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>扩展PE头根据程序是32位或64位而对应两种不同的结构</li><li>根据扩展PE头的第一个成员Magic可以判断出程序是32位的还是64位的</li><li>两种扩展PE头结构实际相差不多，掌握了32位的结构其实也相当于掌握了64位的结构</li><li>扩展PE头英文虽然为optional header，译为可选头，但它其实必不可少且极其重要</li><li>扩展PE头中的DataDirectory内容涉及较多，留作之后</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的<a href="https://www.52pojie.cn/thread-1405930-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记四 PE文件头之标准PE头</title>
      <link href="2021/06/15/PE%E6%80%BB%E7%BB%934/"/>
      <url>2021/06/15/PE%E6%80%BB%E7%BB%934/</url>
      
        <content type="html"><![CDATA[<p>转载好文 (๑•̀ㅂ•́)و✧</p><p>继续具体学习PE的各个结构细节，前面学完了DOS部首，接着学习PE文件头</p><p>由于PE文件头的内容较多，故要拆分为多个笔记，此笔记主要为<strong>标准PE头</strong></p><h1 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h1><h2 id="PE文件头结构"><a href="#PE文件头结构" class="headerlink" title="PE文件头结构"></a>PE文件头结构</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328200236487.png" alt="image-20210328200236487"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210403212229062.png" alt="image-20210403212229062"></p><hr><h3 id="两种PE文件头"><a href="#两种PE文件头" class="headerlink" title="两种PE文件头"></a>两种PE文件头</h3><p>PE文件头的结构有两种，<strong>分别对应32位的程序和64位的程序</strong>，它们的<strong>差异在于扩展PE头的结构</strong></p><table><thead><tr><th align="left">PE文件头结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">_IMAGE_NT_HEADERS</td><td align="left">32位程序对应的PE文件头结构</td></tr><tr><td align="left">_IMAGE_NT_HEADERS64</td><td align="left">64位程序对应的PE文件头结构</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER32</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER32</strong></td><td align="left">扩展PE头 32位</td></tr></tbody></table><table><thead><tr><th align="left">_IMAGE_NT_HEADERS64</th><th align="left">对应C中的结构体（类型）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">DOWRD</td><td align="left">PE标识，固定值不可变</td></tr><tr><td align="left">IMAGE_FILE_HEADER</td><td align="left">IMAGE_FILE_HEADER</td><td align="left">标准PE头</td></tr><tr><td align="left">IMAGE_OPTIONAL_HEADER64</td><td align="left"><strong>IMAGE_OPTIONAL_HEADER64</strong></td><td align="left">扩展PE头 64位</td></tr></tbody></table><hr><h3 id="结构体截图"><a href="#结构体截图" class="headerlink" title="结构体截图"></a>结构体截图</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328204339552.png" alt="image-20210328204339552"></p><hr><h3 id="结构体代码"><a href="#结构体代码" class="headerlink" title="结构体代码"></a>结构体代码</h3><h4 id="32位结构体"><a href="#32位结构体" class="headerlink" title="32位结构体"></a>32位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;               //标准PE头</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;     //扩展PE头 32位</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><hr><h4 id="64位结构体"><a href="#64位结构体" class="headerlink" title="64位结构体"></a>64位结构体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS64 &#123;</span><br><span class="line">    DWORD Signature;                            //PE文件头标识</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;               //标准PE头 </span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;     //扩展PE头 64位</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><h2 id="PE文件头标志"><a href="#PE文件头标志" class="headerlink" title="PE文件头标志"></a>PE文件头标志</h2><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>根据DOS MZ头的最后一个成员找到PE文件头的首部，也就是PE文件头标志的首部</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328202904227.png" alt="image-20210328202904227"></p><p>可以看到，PE文件头标志<strong>固定</strong>为 50 45 00 00 ，对应ASCII为“PE ” ，是用来判断文件是否为PE文件的标识之一，还有一个PE标识为MZ头</p><table><thead><tr><th align="left">PE文件头标志</th><th align="left">对应C语言变量</th><th align="left">数据宽度</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">“PE”,0,0</td><td align="left">Signature</td><td align="left">DWORD（4字节）</td><td align="left">50 45 00 00对应ASCII为“PE ”</td><td align="left">PE文件标识</td></tr></tbody></table><hr><h2 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h2><h3 id="结构体截图-1"><a href="#结构体截图-1" class="headerlink" title="结构体截图"></a>结构体截图</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328204842798.png" alt="image-20210328204842798"></p><hr><h3 id="结构体代码-1"><a href="#结构体代码-1" class="headerlink" title="结构体代码"></a>结构体代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_FILE_HEADER &#123;</span><br><span class="line">    WORD    Machine;//可以运行在什么样的CPU上   任意：0    Intel 386以及后续：14C   x64：8664  </span><br><span class="line">    WORD    NumberOfSections;//表示节的数量</span><br><span class="line">    DWORD   TimeDateStamp;//编译器填写的时间戳 与文件属性里面(创建时间、修改时间)无关</span><br><span class="line">    DWORD   PointerToSymbolTable;//调试相关</span><br><span class="line">    DWORD   NumberOfSymbols;//调试相关</span><br><span class="line">    WORD    SizeOfOptionalHeader;//可选PE头的大小(32位PE文件：0xE0  64位PE文件：0xF0)</span><br><span class="line">    WORD    Characteristics;//文件属性</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><hr><h3 id="成员详情"><a href="#成员详情" class="headerlink" title="成员详情"></a>成员详情</h3><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">Machine</td><td align="left">WORD(2字节)</td><td align="left">程序支持的CPU</td><td align="left">任意：0  Intel 386以及后续：14C  x64：8664</td></tr><tr><td align="left">NumberOfSections</td><td align="left">WORD(2字节)</td><td align="left">节的数量</td><td align="left">不大于96</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">DWORD(4字节)</td><td align="left">编译器填写的时间戳</td><td align="left">与文件属性里面(创建时间、修改时间)无关</td></tr><tr><td align="left">PointerToSymbolTable</td><td align="left">DWORD(4字节)</td><td align="left">指向符号表</td><td align="left">调试相关</td></tr><tr><td align="left">NumberOfSymbols</td><td align="left">DWORD(4字节)</td><td align="left">符号表中的符号个数</td><td align="left">调试相关</td></tr><tr><td align="left">SizeOfOptionalHeader</td><td align="left">WORD(2字节)</td><td align="left">可选PE头结构大小</td><td align="left">32位PE文件：0xE0 64位PE文件：0xF0</td></tr><tr><td align="left">Characteristics</td><td align="left">WORD(2字节)</td><td align="left">文件属性</td><td align="left">由数据位拼接而成，详见下方</td></tr></tbody></table><hr><h4 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h4><p>计算机的体系结构类型。映像文件只能在指定的计算机或模拟指定计算机的系统上运行。此成员可以是以下值之一：</p><table><thead><tr><th align="left">值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">宏定义IMAGE_FILE_MACHINE_I386 = 0x014c</td><td align="left">x86</td></tr><tr><td align="left">宏定义IMAGE_FILE_MACHINE_IA64 = 0x0200</td><td align="left">Intel IPF</td></tr><tr><td align="left">宏定义IMAGE_FILE_MACHINE_AMD64 = 0x8664</td><td align="left">x64</td></tr></tbody></table><p>IA64：就是所谓的安腾（Itanium）(IPF)，Intel跟HP联合折腾的一种64-bits全新架构，与x86系列不兼容</p><hr><h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h4><p>节数。这表示紧跟在PE文件头后面的节表的大小。请注意，Windows加载程序将节数限制为96。</p><hr><h4 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h4><p>Image时间戳的低32位。这表示<strong>链接器</strong>创建Image的日期和时间。根据系统时钟，该值以自1970年1月1日午夜（00:00:00）后经过的秒数表示。</p><hr><h4 id="PointerToSymbolTable"><a href="#PointerToSymbolTable" class="headerlink" title="PointerToSymbolTable"></a>PointerToSymbolTable</h4><p>符号表的偏移量，以字节为单位，如果不存在COFF符号表，则为零。</p><p>COFF是指通用对象文件格式，在Microsoft 实现叫做可移植可执行 (PE) 文件格式，在Linux上的实现叫做（可执行与可链接）ELF文件格式；COFF全拼为：Common Object File Format</p><hr><h4 id="NumberOfSymbols"><a href="#NumberOfSymbols" class="headerlink" title="NumberOfSymbols"></a>NumberOfSymbols</h4><p>符号表中的符号数</p><hr><h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h4><p>扩展PE头的大小，以字节为单位。对于对象文件（object files），此值应为0。</p><p>32位的PE文件默认值为0xE0 64位PE文件默认值为0xF0  <strong>该值可变</strong></p><hr><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>Image的文件属性，其值对应的数据位含义为：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328211930866.png" alt="image-20210328211930866"></p><hr><p>Characteristics的数据宽度为WORD（2字节=16 bits）</p><p>假设Characteristics的十六进制为0102，分析其文件属性</p><p>首先将十六进制转化为二进制：0000 0001 0000 0010</p><p>此时可以发现数据位1和8的位置的值为1（数据位由0开始），对照上面可得出：文件属性为 文件是可执行的、只在32位平台上运行</p><hr><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p>紧跟着上面PE文件头标志的实例分析，继续分析标准PE头对应的各个属性</p><p>根据标准PE头各个成员的数据宽度不难得出标准PE头的总宽度为：20字节（4个WORD+3个DWORD=4×2+3×4=20）</p><p>因此从前面PE文件头标志后再数20个字节都是标准PE头的数据</p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210328235126574.png" alt="image-20210328235126574"></p><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">4C 01 05 00 6B 01 AE 55 00 00 00 00 00 00 00 00 E0 00 02 01</span><br></pre></td></tr></table></figure><hr><p>得到：</p><table><thead><tr><th align="left">成员</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">Machine</td><td align="left">x86</td><td align="left">14C</td></tr><tr><td align="left">NumberOfSections</td><td align="left">有5个节</td><td align="left">5</td></tr><tr><td align="left">TimeDateStamp</td><td align="left">编译器填充的时间戳</td><td align="left">55 AE 01 6B</td></tr><tr><td align="left">PointerToSymbolTable</td><td align="left">调试相关</td><td align="left">00 00 00 00</td></tr><tr><td align="left">NumberOfSymbols</td><td align="left">调试相关</td><td align="left">00 00 00 00</td></tr><tr><td align="left">SizeOfOptionalHeader</td><td align="left">可选PE头结构大小为E0</td><td align="left">E0</td></tr><tr><td align="left">Characteristics</td><td align="left">文件属性为 文件可执行且只在32位平台上运行</td><td align="left">102</td></tr></tbody></table><hr><h2 id="自写代码解析PE文件头"><a href="#自写代码解析PE文件头" class="headerlink" title="自写代码解析PE文件头"></a>自写代码解析PE文件头</h2><p>因为有人提议用VS2019来编写，于是这里改成VS2019中的代码，但其实在VC6中也通用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#include &lt;windows.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">//在VC6这个比较旧的环境里，没有定义64位的这个宏，需要自己定义，在VS2019中无需自己定义</span><br><span class="line">#define IMAGE_FILE_MACHINE_AMD64  0x8664</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">    _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">    HANDLE hFile = CreateFileA(&quot;C:\\Users\\sixonezero\\Desktop\\dbgview64.exe&quot;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">    HANDLE hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, 0);</span><br><span class="line">    //映射内容</span><br><span class="line">    LPVOID pFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">    dos = (_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出dos-&gt;e_magic，以十六进制输出</span><br><span class="line">    printf(&quot;dos-&gt;e_magic:%X\n&quot;, dos-&gt;e_magic);</span><br><span class="line"></span><br><span class="line">    //创建指向PE文件头标志的指针</span><br><span class="line">    DWORD* peId;</span><br><span class="line">    //让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">    peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">    //输出PE文件头标志，其值应为4550，否则不是PE文件</span><br><span class="line">    printf(&quot;peId:%X\n&quot;, *peId);</span><br><span class="line"></span><br><span class="line">    //创建标准PE头对应的结构体指针</span><br><span class="line">    _IMAGE_FILE_HEADER* file;</span><br><span class="line">    //让标准PE头指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小</span><br><span class="line">    file = (_IMAGE_FILE_HEADER*)((UINT)peId + sizeof(DWORD));</span><br><span class="line">    //输出file-&gt;Machine</span><br><span class="line">    printf(&quot;file-&gt;Machine:%X\n&quot;, file-&gt;Machine);</span><br><span class="line">    //根据file-&gt;Machine判断程序为 x86或IPF或x64</span><br><span class="line">    switch (file-&gt;Machine) &#123;</span><br><span class="line">    //程序为32位</span><br><span class="line">    case IMAGE_FILE_MACHINE_I386:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;x86 program\n&quot;);</span><br><span class="line">        //确定程序为32位则扩展PE头确定为_IMAGE_OPTIONAL_HEADER</span><br><span class="line">        //创建扩展PE头对应的结构体指针   </span><br><span class="line">        _IMAGE_OPTIONAL_HEADER* opt;</span><br><span class="line">        //让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">        opt = (_IMAGE_OPTIONAL_HEADER*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出opt-&gt;Magic</span><br><span class="line">        printf(&quot;opt-&gt;Magic:%X\n&quot;, opt-&gt;Magic);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    //程序为IPF</span><br><span class="line">    case IMAGE_FILE_MACHINE_IA64:</span><br><span class="line">        printf(&quot;IPF program\n&quot;);</span><br><span class="line">        break;</span><br><span class="line">    //程序为64位</span><br><span class="line">    case IMAGE_FILE_MACHINE_AMD64:</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;x64 program\n&quot;);</span><br><span class="line">        //确定程序为64位则扩展PE头确定为_IMAGE_OPTIONAL_HEADER64</span><br><span class="line">        //创建扩展PE头对应的结构体指针</span><br><span class="line">        _IMAGE_OPTIONAL_HEADER64* opt;</span><br><span class="line">        //让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">        opt = (_IMAGE_OPTIONAL_HEADER64*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">        //输出opt-&gt;Magic</span><br><span class="line">        printf(&quot;opt-&gt;Magic:%X\n&quot;, opt-&gt;Magic);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>分别演示32位程序和64位程序的运行结果</p><h4 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330163616404.png" alt="image-20210330163616404"></p><hr><h4 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210330163506517.png" alt="image-20210330163506517"></p><h3 id="代码小解"><a href="#代码小解" class="headerlink" title="代码小解"></a>代码小解</h3><p>代码中判断程序是32位或64位是看file-&gt;Machine的值来进行判断的，但其实这里<strong>并不一定准确</strong>，实际上<strong>应当判断opt-&gt;Magic才最为准确的</strong>。但关于扩展PE头的内容留作之后，这里为了学习标准PE头，故先采用这种方式进行判断，后面也会修正为使用opt-&gt;Magic来判断程序为32位或64位</p><hr><p>代码中大部分都有注释，并不难理解，主要说明一下 让指针指向对应地址 的代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码//让PE文件头标志指针指向其对应的地址=DOS首地址+偏移</span><br><span class="line">peId = (DWORD*)((UINT)dos + dos-&gt;e_lfanew);</span><br><span class="line">//让标准PE头指针指向其对应的地址=PE文件头标志地址+PE文件头标志大小</span><br><span class="line">file = (_IMAGE_FILE_HEADER*)((UINT)peId + sizeof(DWORD));</span><br><span class="line">//让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">opt = (_IMAGE_OPTIONAL_HEADER*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br><span class="line">//让扩展PE头指针指向其对应的地址=标准PE头地址+标准PE头大小</span><br><span class="line">opt = (_IMAGE_OPTIONAL_HEADER64*)((UINT)file + sizeof(_IMAGE_FILE_HEADER));</span><br></pre></td></tr></table></figure><hr><p>指针的地址 = 首地址 + 偏移 这个没有什么好说的，主要在指针前的一个（UINT）强制类型转换</p><p>为什么要在指针前加一个（UINT）的强制类型转换？</p><p>这就涉及到指针的加减问题了，详解可参考：<a href="https://www.52pojie.cn/thread-1387007-1-1.html#37278091_%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E5%87%8F">指针的加减</a></p><p>这里简单引用一下指针加减的结论：</p><p>无论是指针的加亦或是减（这里只演示了加法，但减法同理），其加或减的<strong>单位</strong>为去掉一个*后的数据宽度</p><p>也就是<strong>实际增减的数值=去掉一个*后的数据宽度 × 增减的数值</strong></p><hr><p>上面的指针都是一级结构体指针，DWORD，_IMAGE_FILE_HEADER，_IMAGE_OPTIONAL_HEADER,_IMAGE_OPTIONAL_HEADER64</p><p>去掉一个*后的数据宽度为结构体的大小，但是我们这里<strong>想要进行的增减的单位应该为字节</strong>，而不是结构体的大小，于是要将指针类型强转为UINT(无符号整数)类型（数据宽度为字节），使得其每次增减的单位为字节</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>PE文件头的起始位置由DOS MZ头的最后一个成员确定</li><li>PE文件头标志固定ASCII为“PE ”，若不是则说明该文件非PE文件</li><li>标准PE头的第一个成员Machine可以判断程序为32位或64位</li><li>标准PE头的第二个成员NumberOfSections表示后面节的个数</li><li>可选PE头结构大小可变，且在标准PE头的第六个成员SizeOfOptionalHeader指定</li><li>标准PE头的最后一个成员Characteristics说明了该文件的属性</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解的<a href="https://www.52pojie.cn/thread-1404818-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记三 DOS部分</title>
      <link href="2021/06/15/pe%E6%80%BB%E7%BB%933/"/>
      <url>2021/06/15/pe%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<p>先转载一下怕以后找不到ヽ(✿ﾟ▽ﾟ)ノ</p><p>前面学习了PE结构的总体结构，接下来将具体学习PE的各个结构细节</p><p>这次学习的结构为DOS 部首</p><h1 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h1><h2 id="DOS部首结构"><a href="#DOS部首结构" class="headerlink" title="DOS部首结构"></a>DOS部首结构</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326211401967.png" alt="image-20210326211401967"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326235719068.png" alt="image-20210326235719068"></p><hr><table><thead><tr><th align="left">DOS部首结构</th><th align="left">对应C中的结构体</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DOS ‘MZ’ HEADER</td><td align="left">_IMAGE_DOS_HEADER</td><td align="left">DOS MZ头 结构体</td></tr><tr><td align="left">DOS stub</td><td align="left">无</td><td align="left">DOS 存根</td></tr></tbody></table><hr><h2 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h2><h3 id="结构体截图"><a href="#结构体截图" class="headerlink" title="结构体截图"></a>结构体截图</h3><p>在winnt.h中找到_IMAGE_DOS_HEADER，得到以下截图（具体查找对应C结构体方法在<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1391994&page=1&extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">PE文件笔记一 PE介绍</a>中已经说明了，这里不再赘述）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326212749211.png" alt="image-20210326212749211"></p><hr><h3 id="结构体代码"><a href="#结构体代码" class="headerlink" title="结构体代码"></a>结构体代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制代码 隐藏代码typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">   WORD   e_magic;                     // Magic number</span><br><span class="line">   WORD   e_cblp;                      // Bytes on last page of file</span><br><span class="line">   WORD   e_cp;                        // Pages in file</span><br><span class="line">   WORD   e_crlc;                      // Relocations</span><br><span class="line">   WORD   e_cparhdr;                   // Size of header in paragraphs</span><br><span class="line">   WORD   e_minalloc;                  // Minimum extra paragraphs needed</span><br><span class="line">   WORD   e_maxalloc;                  // Maximum extra paragraphs needed</span><br><span class="line">   WORD   e_ss;                        // Initial (relative) SS value</span><br><span class="line">   WORD   e_sp;                        // Initial SP value</span><br><span class="line">   WORD   e_csum;                      // Checksum</span><br><span class="line">   WORD   e_ip;                        // Initial IP value</span><br><span class="line">   WORD   e_cs;                        // Initial (relative) CS value</span><br><span class="line">   WORD   e_lfarlc;                    // File address of relocation table</span><br><span class="line">   WORD   e_ovno;                      // Overlay number</span><br><span class="line">   WORD   e_res[4];                    // Reserved words</span><br><span class="line">   WORD   e_oemid;                     // OEM identifier (for e_oeminfo)</span><br><span class="line">   WORD   e_oeminfo;                   // OEM information; e_oemid specific</span><br><span class="line">   WORD   e_res2[10];                  // Reserved words</span><br><span class="line">   LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line"> &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><hr><h3 id="结构体成员分析"><a href="#结构体成员分析" class="headerlink" title="结构体成员分析"></a>结构体成员分析</h3><p>_IMAGE_DOS_HEADER结构体的成员并不少，但在现在需要学习的只有两个</p><p>因为：</p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>DOS部首，可以说是Windows的<strong>历史遗留问题</strong>了，因为Windows程序最早是在DOS系统（16位系统）上运行的</p><p>所以该部分<strong>主要是给DOS用的</strong>（向下兼容）</p><hr><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>目前在32位或64位 WINDOWS系统上还有效的只有两个成员了：</p><ul><li>第一个成员：e_magic</li><li>最后一个成员：e_lfanew</li></ul><hr><h4 id="成员详情"><a href="#成员详情" class="headerlink" title="成员详情"></a>成员详情</h4><table><thead><tr><th align="left">成员</th><th align="left">数据宽度</th><th align="left">注释</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">e_magic</td><td align="left">WORD(2字节)</td><td align="left">Magic number</td><td align="left"><strong>PE文件判断标识</strong></td><td align="left">固定为4d 5a (ASCII=’MZ’)</td></tr><tr><td align="left">e_lfanew</td><td align="left">LONG(4字节)</td><td align="left">File address of new exe header</td><td align="left"><strong>存储PE头首地址</strong></td><td align="left">不定</td></tr></tbody></table><hr><h4 id="验证其余成员无效性"><a href="#验证其余成员无效性" class="headerlink" title="验证其余成员无效性"></a>验证其余成员无效性</h4><p>前面说到在目前的系统中，只有两个成员是有效的，为验证这一点，将其余成员全部置为0试试</p><p><strong>1.用WinHex或UltraEdit等十六进制编辑器打开一个程序</strong></p><p>这里采用<strong>WinHex</strong>进行操作，并选中其余成员部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326223305500.png" alt="image-20210326223305500"></p><hr><p><strong>2.将选中的部分，也就是其余成员部分全部修改为0</strong></p><p>右键→编辑→填充选块 （快捷键Ctrl+L）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224239328.png" alt="image-20210326224239328"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224313607.png" alt="image-20210326224313607"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224403422.png" alt="image-20210326224403422"></p><hr><p>确定修改后：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224440179.png" alt="image-20210326224440179"></p><hr><p><strong>3.保存修改的文件</strong></p><p>文件→保存（快捷键Ctrl+S）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224522965.png" alt="image-20210326224522965"></p><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224557452.png" alt="image-20210326224557452"></p><hr><p><strong>4.执行修改后的文件</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326220814513.png" alt="image-20210326220814513"></p><hr><p>可以看到程序仍然可以正常运行，验证了：其余成员在32位及以上的Windows系统中<strong>无效</strong></p><h2 id="Dos-Stub"><a href="#Dos-Stub" class="headerlink" title="Dos Stub"></a>Dos Stub</h2><p>Dos Stub在32位及以上的Windows系统中其实也无效，但不妨研究一下他的作用</p><p><strong>1.截取出Dos Stub部分的数据</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224705523.png" alt="image-20210326224705523"></p><p>选中部分为Dos Stub，其数据范围由_IMAGE_DOS_HEADER结构体中的最后一个成员e_lfanew决定</p><hr><p><strong>2.复制选中部分也就是Dos Stub部分的数据</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326224751035.png" alt="image-20210326224751035"></p><hr><p><strong>3.将数据粘贴到记事本中</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326225328310.png" alt="image-20210326225328310"></p><hr><h3 id="对应数据"><a href="#对应数据" class="headerlink" title="对应数据"></a>对应数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码</span><br><span class="line">0E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000FD661975B9077726B9077726B90777260448E126BB077726B07FE226A2077726A755F326BE077726B07FE426A6077726B9077626E8057726B07FF4267D077726B07FF32651077726A755E326B8077726B907E026BB077726B07FE626B807772652696368B90777260000000000000000</span><br></pre></td></tr></table></figure><hr><h3 id="对应数据反汇编"><a href="#对应数据反汇编" class="headerlink" title="对应数据反汇编"></a>对应数据反汇编</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码PUSH CS</span><br><span class="line">POP DS</span><br><span class="line">MOV DX,000E</span><br><span class="line">MOV AH,09</span><br><span class="line">INT 21</span><br><span class="line">MOV AX,4C01</span><br><span class="line">INT 21</span><br><span class="line">DB 54</span><br><span class="line">DB 68</span><br><span class="line">DB 69</span><br><span class="line">DB 00</span><br><span class="line">DB 33</span><br><span class="line">DB 70</span><br><span class="line">……</span><br></pre></td></tr></table></figure><hr><p>通过<strong>16位的反汇编引擎</strong>即可得到对应的反汇编代码</p><p>这里我们主要关注DB段，也就是汇编中数据段部分有DB 54；DB 68；DB 69 ……</p><p>在WINHEX中找到其对应的数据部分，查看其对应的ASCII</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326231526001.png" alt="image-20210326231526001"></p><hr><p>数据部分为This program cannot be run in DOS</p><p>结合前面的两个INT 21 中断 不难猜测出该段数据对应的16位反汇编为输出数据部分的内容：This program cannot be run in DOS</p><h2 id="自写代码解析DOS-MZ头"><a href="#自写代码解析DOS-MZ头" class="headerlink" title="自写代码解析DOS MZ头"></a>自写代码解析DOS MZ头</h2><p>了解了DOS部首的结构以后就可以自己写代码来读取DOS MZ头了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码// PE.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //创建DOS对应的结构体指针</span><br><span class="line">        _IMAGE_DOS_HEADER* dos;</span><br><span class="line">    //读取文件，返回文件句柄</span><br><span class="line">        HANDLE hFile = CreateFileA(&quot;C:\\Documents and Settings\\Administrator\\桌面\\dbghelp.dll&quot;,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,0);</span><br><span class="line">    //根据文件句柄创建映射</span><br><span class="line">        HANDLE hMap = CreateFileMappingA(hFile,NULL,PAGE_READONLY,0,0,0);</span><br><span class="line">    //映射内容</span><br><span class="line">        LPVOID pFile = MapViewOfFile(hMap,FILE_MAP_READ,0,0,0);</span><br><span class="line">    //类型转换，用结构体的方式来读取</span><br><span class="line">        dos=(_IMAGE_DOS_HEADER*)pFile;</span><br><span class="line">    //输出结构体的第一个成员，以十六进制输出</span><br><span class="line">        printf(&quot;%X\n&quot;,dos-&gt;e_magic);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210326234752508.png" alt="image-20210326234752508"></p><p>可以看到能够正确地得到DOS MZ头对应的第一个成员的值：5A4D（对应ASCII为MZ）</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>DOS部首分为两部分：DOS ‘MZ’ HEADER 和 DOS stub</li><li>DOS ‘MZ’ HEADER对应的结构体_IMAGE_DOS_HEADER中仅第一个成员和最后一个成员在32位及以上的WINDOWS系统上有效</li><li>DOS Stub对应为一串反汇编代码，其功能和输出This program cannot be run in DOS相关</li><li>DOS ‘MZ’ HEADER中无效的成员部分可用来填充shellcode来达到其它目的</li></ul><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p><p>转载自吾爱破解上的一位<a href="https://www.52pojie.cn/thread-1403011-1-1.html">大佬</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界 re -re1</title>
      <link href="2021/06/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre1/"/>
      <url>2021/06/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cre1/</url>
      
        <content type="html"><![CDATA[<p>一天一道ctf系列</p><p><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5073&page=1">攻防世界re1</a></p><p>这道题我们有两种解法，先说说第一种</p><h4 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h4><p>我们先直接拖入ida</p><p><img src="https://img-blog.csdnimg.cn/20190506221846329.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgxNTA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>f5查看伪代码，如上图，可以分析出flag保存在v9中，然后再和v5比较，如果相同则输出aflag。所以我们可以猜测flag的值作为常量保存在了程序内部，那么我们直接查看字符串。</p><p><img src="https://img-blog.csdnimg.cn/20190506223041162.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDgxNTA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>为啥找不到呢 ？</p><p>一脸懵逼的我打开了百度搜索，看到了这个大佬的<a href="https://blog.csdn.net/qq_40481505/article/details/89893552">文章</a></p><p><img src="/images/image-20210615110705664.png" alt="image-20210615110705664"></p><p>大概意思是ida在反编译过程中采用的是下降法，这种方法很少会误将数据当作代码进行反编译，但是这次很不幸，我们的flag呗反编译了，所以解决方法是：在IDA打开文件时选择binary file,在此模式下IDA不会进行反编译，此时再打开strings界面就可发现flag。</p><p>开始实践：<br><img src="/images/image-20210615111021666.png" alt="image-20210615111021666"></p><p>成功找到</p><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>正常流程进入main函数，发现flag输入v9中且和v5比较，所以我们推测flag存储在v5中，通过源码追踪v5。</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816175750099-2081804484.png" alt="img"></p><p>可以看到，xmmword_413E34赋值给了v5，所以xmmword_413E34就是我们要找的值，双击进去，得到了一串数字。</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816175915527-148146356.png" alt="img"></p><p>将数字转化为字符串</p><p><img src="https://img2018.cnblogs.com/blog/1228809/201908/1228809-20190816180036597-1259453797.png" alt="img"></p><p>因为计算机采取的是小端存储，所以我们倒着输入就成功了</p><h4 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag!"></a>get flag!</h4><p>DUTCTF{We1c0met0DUTCTF}</p>]]></content>
      
      
      <categories>
          
          <category> ctf-re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp定律脱壳</title>
      <link href="2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/"/>
      <url>2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>esp定律脱壳</p><p>————————————纯属个人理解，如有不对求大佬指正。</p><p>看了好多关于esp定律脱壳的文章，都没看懂，o(≧口≦)o，可能是本人太笨了吧。所以就来浅谈一下自己对于esp脱壳的理解。</p><p>个人对于esp脱壳的理解是先把壳跑完，此时的oep就是真正的程序入口。然后再将源程序通过工具dump出来为一个exe文件，再进行一些修复操作，就脱壳完毕了。</p><p>接下来是实战操作 ┭┮﹏┭┮ ，我直接通过buuctf里的<a href="https://buuoj.cn/challenges#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90">新年快乐</a>题目来操作吧。</p><h4 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h4><p>首先拖入ide中，我们会发现只有两个函数，是不是很可疑，</p><p><img src="https://img-blog.csdnimg.cn/20201113093639895.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="没脱壳拖入ida"></p><p>所以我们直接将它拖入Exeinfope中</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210614185118093.png" alt="image-20210614185118093"></p><p>可以看到该exe文件里有一个UPX壳，那么我们就开始脱壳吧。</p><h4 id="esp脱壳"><a href="#esp脱壳" class="headerlink" title="esp脱壳"></a>esp脱壳</h4><p>esp定律脱壳（个人理解）：<br>在外壳代码中有一个pushad的指令，该指令会将所有的寄存器的值都压入栈中也就是说在pushad指令之后esp的值就是指向外壳的代码段了，等之后运行完外壳程序，我们只要找到OEP就可以了</p><p>关于esp定律如果有不懂的话推荐看一下这个<a href="https://www.52pojie.cn/thread-294844-1-1.html">文章</a>，或者百度。反正都比我讲的好多了。 o(￣ヘ￣o＃)</p><h5 id="拖入od"><a href="#拖入od" class="headerlink" title="拖入od"></a>拖入od</h5><p>将exe拖入X32dbg开始分析，首先找到pushad，</p><p><img src="https://img-blog.csdnimg.cn/20201114084054781.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>双击进入，将eip指向这里</p><p><img src="https://img-blog.csdnimg.cn/20201114084329271.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后f8单步运行，此时我们可以看到esp的变化，右键esp，转到内存窗口设置断点</p><p><img src="https://img-blog.csdnimg.cn/20201114084603988.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设置内存断点"></p><p><img src="https://img-blog.csdnimg.cn/20201114084842340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设断点"></p><p>运行，关于这两步操作我来做一下解释，因为pushad以后esp指向的是外壳的代码段，所以我们将断点设置在此处，然后运行到此处以后，就可以找到我们的程序入口oep了。</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210614185448616.png" alt="image-20210614185448616"></p><p>此时，程序停下来以后，往上看我们可以看到popad，该指令刚好与pushad对应，可以将内存器里的值进行还原。找到下面jmp指令要跳转的位置就是我们的程序的入口oep。</p><p><img src="https://img-blog.csdnimg.cn/202011140852477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>oep已找到，接下来开始dump</p><h4 id="dump操作"><a href="#dump操作" class="headerlink" title="dump操作"></a>dump操作</h4><p>（这里忘截图了，直接挂大佬的操作图了）<img src="https://img-blog.csdnimg.cn/20201114091101713.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>操作如下：<img src="https://img-blog.csdnimg.cn/20201114091242417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114092646790.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后再fixdump一下，会弹下图，如果未弹出，可以先perebuild（具体操作与fixdump相同）然后再fixdump（具体原理还在挖掘中）</p><p><img src="https://img-blog.csdnimg.cn/20201114092717465.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092726792.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092735101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092739904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>脱壳完成！</p><p>另外鸣谢大佬，挂上大佬<a href="https://blog.csdn.net/weixin_46287316/article/details/109669066?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base">文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记二 PE文件的两种状态</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%932/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<p>一篇转载文章，转载于：<a href="https://www.52pojie.cn/thread-1393291-1-1.html">https://www.52pojie.cn/thread-1393291-1-1.html</a><br>一个PE文件可以分为两种状态：运行态和非运行态</p><p>非运行态：当一个PE文件尚未被运行时，其数据<strong>存储在磁盘中</strong>，也就是<a href="https://www.52pojie.cn/thread-1391994-1-1.html">PE个人笔记一之PE介绍</a>中PE的状态</p><p>运行态：当一个PE文件被打开后，PE文件的相关数据将被<strong>装载到内存中</strong>，此时为运行态</p><hr><p>在细讲PE两种状态前，回顾先前在笔记一中的相关内容：</p><h2 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316164115579.png" alt="image-20210316164115579"></p><h2 id="整体结构表"><a href="#整体结构表" class="headerlink" title="整体结构表"></a>整体结构表</h2><table><thead><tr><th align="left">结构</th><th align="left">对应C数据结构</th><th align="left">默认占用空间大小（单位字节）</th></tr></thead><tbody><tr><td align="left">DOS MZ头</td><td align="left">_IMAGE_DOS_HEADER</td><td align="left">64</td></tr><tr><td align="left">DOS Stub</td><td align="left">仅在MS-DOS系统下有效，不作研究</td><td align="left">不固定</td></tr><tr><td align="left">PE文件头</td><td align="left">_IMAGE_NT_HEADERS</td><td align="left">4+20+224=248</td></tr><tr><td align="left">PE文件头标志</td><td align="left">Signature</td><td align="left">4</td></tr><tr><td align="left">PE文件表头/标准PE头</td><td align="left">_IMAGE_FILE_HEADER</td><td align="left">20</td></tr><tr><td align="left">PE文件表头可选部分/扩展PE头</td><td align="left">_IMAGE_OPTIONAL_HEADER</td><td align="left">224</td></tr><tr><td align="left">块表/节表</td><td align="left">_IMAGE_SECTION_HEADER</td><td align="left">40</td></tr><tr><td align="left">块/节</td><td align="left">无</td><td align="left">由块表/节表决定</td></tr></tbody></table><hr><h1 id="非运行态"><a href="#非运行态" class="headerlink" title="非运行态"></a>非运行态</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先前的笔记一中只是简单介绍了非运行态下如何判断一个文件是否为PE文件</p><p>接下来讲讲为何能通过之前的方法来判断PE文件</p><hr><p><strong>判断PE文件的流程</strong>可概括为如下三步：</p><ol><li>判断头2个字节是否为4D 5A（ASCII码为MZ）</li><li>找到3Ch位置数据</li><li>根据第二步中的位置数据再找到对应的地址，判断这个地址是否为50 45 00 00（对应ACSII码为PE..）</li></ol><hr><table><thead><tr><th align="left">地址</th><th align="left">长度（单位字节）</th><th align="left">对应C的数据结构</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的第一个成员e_magic</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的最后一个成员e_lfanew</td><td align="left">指出PE头文件偏移位置</td><td align="left">不定</td><td align="left">不定</td></tr><tr><td align="left">[3C]</td><td align="left">4</td><td align="left">Signature</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>下面结合实例再来分析：</p><p>这次使用WinHex这个工具来进行查看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315210005799.png" alt="image-20210315210005799"></p><hr><p>此时对应的表格数据为：</p><table><thead><tr><th align="left">地址</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">指出PE头文件偏移位置</td><td align="left">F0</td><td align="left"></td></tr><tr><td align="left">F0</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>上面对一个PE文件的判断只涉及了DOS MZ头和PE文件头中的PE文件头标志</p><p>下面继续分析其它结构</p><hr><h2 id="后续分析"><a href="#后续分析" class="headerlink" title="后续分析"></a>后续分析</h2><h3 id="PE文件头标志和标准PE头"><a href="#PE文件头标志和标准PE头" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p>从先前的PE的结构继续向后看24个字节（PE文件头标志的大小+标准PE头大小 4+20）得到扩展PE头的首地址</p><p>先前的地址为：F0</p><p>后来的地址为：0xF0+24=240+24=264=0x108</p><p>所以从F0～108为PE文件头标志和标准PE头</p><p>从108开始就是扩展PE头了</p><p>PE文件头标志和标准PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315212241373.png" alt="image-20210315212241373"></p><hr><h3 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p>从先前得到的扩展PE头地址继续向后看224个字节（扩展PE头大小）得到块表的首地址</p><p>先前的地址为：108</p><p>后来的地址为：0x108+224=264+224=488=0x1E8</p><p>所以从108~1E8为扩展PE头</p><p>从1E8开始就是块表了</p><p>扩展PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315213947563.png" alt="image-20210315213947563"></p><hr><h3 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h3><p>从先前得到的块表头地址继续向后看40个字节（块表大小）得到第二个块表的首地址</p><p>先前的地址为：1E8</p><p>后来的地址为：0x1E8+40=488+40=528=0x210</p><p>所以从1E8~210为第一个块表</p><p>从210开始就是第二个块表了</p><p>第一个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315234922585.png" alt="image-20210315234922585"></p><hr><p>同理可得剩下的几个块表</p><p>第二个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235048573.png" alt="image-20210315235048573"></p><p>地址从210~238</p><hr><p>第三个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235154581.png" alt="image-20210315235154581"></p><p>地址从238~260</p><hr><p>第四个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235402774.png" alt="image-20210315235402774"></p><p>地址从260~288</p><hr><p>第五个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235504709.png" alt="image-20210315235504709"></p><p>地址从288~2B0</p><hr><h4 id="汇总块表"><a href="#汇总块表" class="headerlink" title="汇总块表"></a>汇总块表</h4><table><thead><tr><th align="left">块名称</th><th align="left">块地址</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">1E8~210</td></tr><tr><td align="left">.rdata</td><td align="left">210~238</td></tr><tr><td align="left">.data</td><td align="left">238~260</td></tr><tr><td align="left">.rsrc</td><td align="left">260~288</td></tr><tr><td align="left">.reloc</td><td align="left">288~2B0</td></tr></tbody></table><hr><h3 id="块表后的空隙"><a href="#块表后的空隙" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>块表后面跟着的应该是块，但在块表后和块之前却多出了一段空间</p><p>这里为2B0~400</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316000131381.png" alt="image-20210316000131381"></p><hr><p>先前的PE结构中间都没有空隙，为<strong>连续存储</strong></p><p>但在<strong>块表和块之间是可能存在空隙的</strong>，这个空隙里一般被填充为编译器插入的数据（也可以没有,就是此时的情况）</p><p>这段空隙的修改并不会导致程序不可运行，因而可被拿来写入自己想要的代码来对程序进行修改</p><hr><p><strong>为什么会存在这段空隙？</strong></p><p>这段空隙存在的原因在于块表和块并没有<strong>连续存储</strong></p><p>所以这段空隙的存在与否及长度 取决于 <strong>块的起始位置</strong></p><p>而块的起始位置则<strong>由扩展PE头中的某个成员决定</strong></p><hr><p>给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SizeOfHeaders成员（DWORD类型占4个字节）</p><p>SizeOfHeaders的含义为<strong>3个头按照文件对齐后的大小</strong>：（DOS头大小+PE头大小+块表大小）加完的结果进行<strong>文件对齐</strong>后得到的大小</p><p>头大小相加很好理解，按照之前得到的头大小和为：2B0，于是问题就在于文件对齐</p><h4 id="什么是文件对齐"><a href="#什么是文件对齐" class="headerlink" title="什么是文件对齐"></a>什么是文件对齐</h4><p>讲到文件对齐就涉及到扩展PE头中的另一个成员：FileAlignment（DWORD类型占4个字节）</p><p>文件对齐就是要求SizeOfHeaders必须为FileAlignment的<strong>整数倍</strong></p><hr><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为108</p><p>从108开始往后找36个字节（中间间隔了1个WORD，2个BYTE，8个DWORD，即1<em>2+2</em>1+8*4=36）</p><p>FileAlignment的地址为：0x108+36=264+36=300=0x12C</p><p>FileAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003503508.png" alt="image-20210316003503508"></p><p>FileAlignment为00 00 02 00=0x200（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是FileAlignment的整数倍</p><p>于是将SizeOfHeaders设置为FileAlignment的整数倍：(2B0/200+1)*200=400</p><p>得出的SizeOfHeaders的大小应该为0x400</p><hr><p>再来验证一下SizeOfHeaders的大小</p><p>前面得到的FileAlignment的地址为12C</p><p>从12C开始往后找24个字节（中间间隔了6个WORD，3个DWORD，即6<em>2+3</em>4=24）</p><p>SizeOfHeaders的地址为：0x12C+24=300+24=324=0x144</p><p>SizeOfHeaders：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003735412.png" alt="image-20210316003735412"></p><p>SizeOfHeaders为 00 00 04 00=0x400（小端存储）</p><p>得到的大小和计算出来的大小一致，验证完毕</p><hr><h4 id="为什么要文件对齐"><a href="#为什么要文件对齐" class="headerlink" title="为什么要文件对齐"></a>为什么要文件对齐</h4><p>和内存对齐一样，都是为了使执行时的效率更高，有关内存对齐可参考：<a href="https://www.52pojie.cn/thread-1385641-1-1.html#37246226_%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">逆向基础笔记十八 汇编 结构体和内存对齐</a></p><p>PS：上面的内存对齐为程序中<strong>局部的内存对齐</strong>，主要针对的是编程时的变量、结构体等，和后面要讲的内存对齐要区别开</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块的起始地址由块表中的PointerToRawData决定，<strong>第一个块</strong>的起始地址则由上面的SizeOfHeaders决定</p><p>块部分存储的为数据，如何存储由块表决定，这里主要探讨<strong>每个块的 起始地址、块大小、结束地址</strong>，其它留作之后的笔记</p><p>给出块表在C中的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#define IMAGE_SIZEOF_SHORT_NAME              8</span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;                        //&lt;--- 块的大小</span><br><span class="line">    DWORD   PointerToRawData;                //&lt;--- 块在磁盘文件中的偏移</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><hr><h4 id="块的起始地址"><a href="#块的起始地址" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>找到结构体中的PointerToRawData成员（DWORD类型占4个字节）</p><p>PointerToRawData的含义为<strong>该块在磁盘文件中的偏移</strong></p><p>前面已经知道第一个块表的首地址为1E8</p><p>从1E8开始往后找20个字节（中间间隔了1个BYTE[8]，3个DWORD，即1<em>8+3</em>4=20）</p><p>PointerToRawData的地址为：0x1E8+20=488+20=508=0x1FC</p><p>PointerToRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316011603629.png" alt="image-20210316011603629"></p><p>PointerToRawData为00 00 04 00=0x400</p><p>和通过SizeOfHeaders得到的一致，验证了<strong>第一个</strong>块的PointerToRawData由SizeOfHeaders决定</p><h4 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h4><p>SizeOfRawData为块的大小（文件对齐后）</p><p>SizeOfRawData就在PointerToRawData前面</p><p>所以其地址为：PointerToRawData地址-4=0x1FC-4=0x1F8</p><p>SizeOfRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316152420615.png" alt="image-20210316152420615"></p><p>SizeOfRawData为00 92 19 00=0x199200</p><p>块的大小和前面三个头(DOS部首+PE文件头+块表)的大小一样，也要<strong>满足文件对齐</strong></p><p>先前得到的FileAlignment为0x200，这里的SizeOfRawData：0x199200为FileAlignment的整数倍，满足文件对齐</p><hr><h4 id="块的结束地址-下一个块的起始地址"><a href="#块的结束地址-下一个块的起始地址" class="headerlink" title="块的结束地址(下一个块的起始地址)"></a>块的结束地址(下一个块的起始地址)</h4><p>块的结束地址为块的起始地址+块的大小</p><p>即块的结束地址=0x400+0x199200=199600</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316153738194.png" alt="image-20210316153738194"></p><hr><p>可以看到第一个块和第二个块之前是<strong>存在空隙</strong>的，这段空隙也是由于<strong>文件对齐</strong>产生的</p><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>在非运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>文件对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>文件对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SizeOfHeaders</td><td align="left">扩展PE头</td><td align="left">头大小（文件对齐后）</td></tr><tr><td align="left">FileAlignment</td><td align="left">扩展PE头</td><td align="left">文件对齐</td></tr><tr><td align="left">PointerToRawData</td><td align="left">块表</td><td align="left">第一个块表的PointerToRawData由SizeOfHeaders决定，后面块表的PointerToRawData由前一个块表的PointerToRawData+SizeOfRawData决定</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">块表</td><td align="left">块表的大小（文件对齐后）</td></tr></tbody></table><hr><p>记录一下各结构的起始和结束位置，方便和运行态进行比较</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">0</td><td align="left">F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">F0</td><td align="left">1E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">1E8</td><td align="left">2B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">0</td><td align="left">400</td><td align="left">0x400（文件对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">400</td><td align="left">199600</td><td align="left">0x199200（文件对齐后）</td></tr></tbody></table><hr><h1 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h1><p>前面介绍了非运行态（硬盘状态）下PE文件的结构，现在看看运行态（内存状态）下PE文件的结构</p><h2 id="加载运行态的PE文件"><a href="#加载运行态的PE文件" class="headerlink" title="加载运行态的PE文件"></a>加载运行态的PE文件</h2><p><strong>1.启动PE文件</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132316337.png" alt="image-20210316132316337"></p><hr><p><strong>2.然后返回WinHex，点击工具→打开RAM(R)… 或直接使用快捷键Alt+F9</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132406704.png" alt="image-20210316132406704"></p><hr><p><strong>3.打开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132549551.png" alt="image-20210316132549551"></p><p><strong>选中我们要分析的PE文件，使其展开</strong></p><hr><p><strong>4.展开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132819269.png" alt="image-20210316132819269"></p><p><strong>选中.exe打开</strong></p><hr><p><strong>5.最后确定即可</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316133031067.png" alt="image-20210316133031067"></p><hr><h2 id="分析运行态的PE文件"><a href="#分析运行态的PE文件" class="headerlink" title="分析运行态的PE文件"></a>分析运行态的PE文件</h2><p>按照先前分析的流程，再分析一遍运行态下的PE文件</p><h3 id="DOS部首和PE头标志"><a href="#DOS部首和PE头标志" class="headerlink" title="DOS部首和PE头标志"></a>DOS部首和PE头标志</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134218062.png" alt="image-20210316134218062"></p><p>此时的DOS部首起始地址为400000，结束地址为4000F0</p><hr><h3 id="PE文件头标志和标准PE头-1"><a href="#PE文件头标志和标准PE头-1" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134123745.png" alt="image-20210316134123745"></p><p>此时PE文件头的起始地址为4000F0，结束地址为400108</p><hr><h3 id="扩展PE头-1"><a href="#扩展PE头-1" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134503765.png" alt="image-20210316134503765"></p><p>此时PE文件头的起始地址为400108，结束地址为4001E8</p><hr><h3 id="块表-1"><a href="#块表-1" class="headerlink" title="块表"></a>块表</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134642926.png" alt="image-20210316134642926"></p><p>此时块表的起始地址为4001E8，结束地址为4002B0</p><hr><h3 id="块表后的空隙-1"><a href="#块表后的空隙-1" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>从前面的分析来看，在块表前的结构在运行态和非运行态除了起始地址不同以外，其它地方并无不同</p><p>起始地址的由来等相关内容留作之后的笔记说明</p><p>按照经验，块表后的空隙也应该是持续到先前的400+400000=400400</p><p>于是前往查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135241232.png" alt="image-20210316135241232"></p><hr><p>发现并非如此，400400仍然为空隙</p><p>先前分析得知在非运行态块表后的空隙是因为文件对齐产生的</p><p>而在运行态中，显然就<strong>不是由文件对齐决定的</strong></p><hr><p>接着向下查看，找到<strong>块的起始位置</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135922474.png" alt="image-20210316135922474"></p><hr><p>发现此时块的起始位置为401000，偏移为1000，而不是 非运行态的400</p><p>于是熟悉的问题又回来了：</p><p><strong>为什么会存在这段空隙？</strong></p><p>和先前的文件对齐类似，当程序处于运行态时，会有另一种对齐方式：<strong>内存对齐</strong></p><p>和内存对齐相关的属性和文件对齐（FileAlignment）类似，也是取决于扩展PE头中的一个成员</p><hr><p>再次给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;                        //&lt;--- 内存对齐</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SectionAlignment成员，会发现它就在FileAlignment（文件对齐）成员的上面</p><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为400108</p><p>从400108开始往后找32个字节（中间间隔了1个WORD，2个BYTE，7个DWORD，即1<em>2+2</em>1+7*4=32）</p><p>SectionAlignment的地址为：0x400108+32=0x400000+264+32=0x400000+296=0x400128</p><p>SectionAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316141510008.png" alt="image-20210316141510008"></p><p>SectionAlignment为00 10 00 00=0x1000（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是SectionAlignment的整数倍</p><p>头大小应该设置为SectionAlignment的整数倍：(2B0/1000+1)*1000=1000</p><p>PS：这里的头大小不会被设置到SizeOfHeaders，因为SizeOfHeaders为文件对齐专用</p><h3 id="块-1"><a href="#块-1" class="headerlink" title="块"></a>块</h3><p>在非运行态中，块的起始位置由PointerToRawData决定，且PointerToRawData必须为FileAlignment的整数倍</p><p>但在运行态中，块的起始位置则并不由PointerToRawData决定，PointerToRawData和SizeOfHeaders一样都为文件对齐专用</p><p>运行态块存储涉及内容较多，这里只查看一下第一个块的起始地址、结束地址和大小，<strong>不作具体探究</strong>，其它留作之后的笔记</p><h4 id="块的起始地址-1"><a href="#块的起始地址-1" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>第一个块的起始地址取决于（DOS部首+PE文件头+块表）的总大小进行内存对齐后的结果</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162649154.png" alt="image-20210316162649154"></p><p>第一个块的起始地址=0x400000+0x1000=0x401000</p><hr><h4 id="块的结束地址"><a href="#块的结束地址" class="headerlink" title="块的结束地址"></a>块的结束地址</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162347979.png" alt="image-20210316162347979"></p><p>第一个块的结束地址=0x59B000</p><hr><h4 id="块的大小-1"><a href="#块的大小-1" class="headerlink" title="块的大小"></a>块的大小</h4><p>块的大小=块的结束地址-块的起始地址=0x59B000-0x401000=0x19A000（满足内存对齐）</p><hr><p><strong>运行态时，块的大小满足内存对齐，非先前的文件对齐</strong></p><hr><h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p>在运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>内存对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>内存对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SectionAlignment</td><td align="left">扩展PE头</td><td align="left">内存对齐</td></tr></tbody></table><hr><p>各结构的起始和结束位置：</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">400000</td><td align="left">4000F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">4000F0</td><td align="left">4001E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">4001E8</td><td align="left">4002B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">400000</td><td align="left">401000</td><td align="left">0x1000（内存对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">401000</td><td align="left">59B000</td><td align="left">0x19A000（内存对齐后）</td></tr></tbody></table><hr><h1 id="对比PE两种状态"><a href="#对比PE两种状态" class="headerlink" title="对比PE两种状态"></a>对比PE两种状态</h1><p>本笔记主要针对PE两种状态中的文件对齐和内存对齐进行比较，<strong>其它的内容暂时没有涉及</strong>，将在后续笔记里陆续提到</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>无论是在运行态还是在非运行态，DOS部首、PE文件头、块表块表均为连续存储，中间没有空隙</p><p>第一个块表的首地址都受DOS部首大小+PE文件头大小+块表大小影响，都需要对齐</p><p>块和块之间也都需要对齐</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>运行态和非运行态的起始地址不同</p><p>在非运行态中，块表和块之间的空隙由<strong>文件对齐</strong>产生，块和块之间的空隙由<strong>文件对齐</strong>产生</p><p>在运行态中，块表和块之间的空隙由<strong>内存对齐</strong>产生，块和块之间的空隙由<strong>内存对齐</strong>产生</p><hr><h2 id="非运行态和运行态映射图"><a href="#非运行态和运行态映射图" class="headerlink" title="非运行态和运行态映射图"></a>非运行态和运行态映射图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316163800340.png" alt="image-20210316163800340"></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记一 PE介绍</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%931/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%931/</url>
      
        <content type="html"><![CDATA[<p>近期发现了一个超牛逼的大佬，和大佬写的超详细的pe总结，所以就根据（抄袭）大佬文章做一些pe总结来巩固学习。</p><p>先挂上大佬文章链接：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89</a></p><h5 id="可执行文件的格式"><a href="#可执行文件的格式" class="headerlink" title="可执行文件的格式"></a>可执行文件的格式</h5><hr><h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><p>PE(Portable Executable)<strong>文件结构</strong></p><h4 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h4><p>ELF(Executable and Linking Format)<strong>文件结构</strong></p><hr><h5 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h5><p>.exe .dll .sys都是windows下常见的可执行文件。（他们都遵循pe文件结构大二的格式）</p><hr><h5 id="常见的非可执行文件"><a href="#常见的非可执行文件" class="headerlink" title="常见的非可执行文件"></a>常见的非可执行文件</h5><ul><li>.txt .png .mp4等等都是非可执行文件，它们都需要使用其它可执行文件的软件进行加载</li><li>.txt可以使用Notepad、UltraEdit等 文本 工具查看</li><li>.png可以使用PhotoShop等 图片 工具查看</li><li>.mp4可以使用PotPlayer等 播放器 工具查看</li></ul><hr><h5 id="为什么要学习pe"><a href="#为什么要学习pe" class="headerlink" title="为什么要学习pe"></a>为什么要学习pe</h5><ul><li>pe是windows下可执行文件必须遵循的规范</li><li>对软件的加壳与脱壳都基于pe</li><li>EXE文件如何加载到内存中也涉及PE的知识</li><li>一个合格的逆向人员，必须熟悉PE</li></ul><hr><h5 id="如何识别pe文件"><a href="#如何识别pe文件" class="headerlink" title="如何识别pe文件"></a>如何识别pe文件</h5><p>不管是.exe .dll还是.sys ，他们都是pe文件，所以他们的前两个字节一定都是4D 5A(ASCII码为MZ)</p><p>我们用winhex打开三种文件观察一下（这里直接没用大佬的三张图）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131655743.png" alt="exe文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131945543.png" alt="dll文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315132009119.png" alt="sys文件"></p><hr><h5 id="3Ch位置的数据（不做总结了）"><a href="#3Ch位置的数据（不做总结了）" class="headerlink" title="3Ch位置的数据（不做总结了）"></a>3Ch位置的数据（不做总结了）</h5><hr><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>如果一个文件，它的头两个字节为4D 5A（ASCII码为MZ），并且通过3Ch位置的数据再找到的位置里的数据为PE则基本可以断定这个文件是Windows下的可执行文件（满足PE结构）</p><hr><h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><p>随便拉一个图片png文件进来看看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315134549954.png" alt="image-20210315134549954"></p><p>很显然，开头的两个字节就已经表明它不是一个PE文件了</p><p>PS：识别可执行文件不能通过文件的后缀名来判断，而应该采用上述的方式进行判断，因为后缀名是可以改的。</p><hr><p>通过前面列举的知识，我们已经知道如何识别一个pe文件了，但是为什么是查看一个文件的前2个字节和3Ch的位置，以及其它位置数据作用呢。</p><p>这便是PE结构所<strong>规定</strong>的</p><h5 id="下面是PE文件的总体结构"><a href="#下面是PE文件的总体结构" class="headerlink" title="下面是PE文件的总体结构"></a>下面是PE文件的总体结构</h5><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144634951.png" alt="pe文件结构"></p><hr><p>可以看到先前判断PE文件特征里的头两个字节对应这里的文件头：DOS ‘MZ’ HEADER</p><p>后面根据3Ch得到的50 45（对应ACSII码为PE）对应这里的PE文件头中的”PE”</p><hr><p>（接下来是重点）</p><hr><h5 id="pe在c中的定义"><a href="#pe在c中的定义" class="headerlink" title="pe在c中的定义"></a>pe在c中的定义</h5><p>pe文件结构自然也是一种数据结构（比较复杂的数据结构）</p><p>在c语言中的winnt.h这个头文件中定义了pe文件结构相关的结构体。</p><p>所以我们可以直接通过c语言中的pe的定义来更好的学习pe</p><p>（直接cv大佬）</p><p>随便创建一个空的控制台项目，然后引入winnt.h这个头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103747813.png" alt="image-20210612103747813"></p><p>然后在引入的头文件处右键转到文档</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103935331.png" alt="image-20210612103935331"></p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104002548.png" alt="image-20210612104002548"></p><p>接下来大佬就会根据这个头文件来学习pe文件的总体结构了</p><hr><h5 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h5><p>该部分结构对应winnt.h中的**_IMAGE_DOS_HEADER**结构体</p><p>可以在先前打开的winnt.h中Ctrl+F搜索_IMAGE_DOS_HEADER</p><p>查找后得到</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104222424.png" alt="image-20210612104222424"></p><p>这里贴上大佬提出来的字段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><hr><p>这里我们只需要关注这两个字段就好了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WORD   e_magic                *    <span class="string">&quot;MZ标记&quot;</span> 用于判断是否为可执行文件.</span><br><span class="line">DWORD  e_lfanew;              *    PE头相对于文件的偏移，用于定位PE文件</span><br></pre></td></tr></table></figure><hr><h3 id="PE文件头-NT头"><a href="#PE文件头-NT头" class="headerlink" title="PE文件头(NT头)"></a>PE文件头(NT头)</h3><p>该部分结构对应winnt.h中的**_IMAGE_NT_HEADERS**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>可以看到PE文件头对应的结构体中还包含了其它结构体，这里依旧只介绍大体作用，细节留作之后的笔记</p><p>这里的PE文件头相对于先前的DOS部首则是<strong>给Windows使用的</strong></p><hr><h3 id="块表-节表"><a href="#块表-节表" class="headerlink" title="块表(节表)"></a>块表(节表)</h3><p>该部分结构对应winnt.h中的**_IMAGE_SECTION_HEADER**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>块表主要用来表示当前文件一共分为几个部分，和后面的块相对应</p><p>块表决定了后面的块，每一块从哪里开始，里面存储的数据是什么等等</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块部分是由前面的块表决定的，是具体的存储数据的部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144652675.png" alt="image-20210315144652675"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315195059766.png" alt="image-20210315195059766"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/PE.png" alt="PE"></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构新增节</title>
      <link href="2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/"/>
      <url>2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>首先先了解一下节表</strong></p><p>如下图，打开一个exe文件，我们可以看到有多个节表。<br><img src="https://img-blog.csdnimg.cn/20210611093247579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要有这么多节表呢？每个节表都有自己的任务与功能，所以我们可以手动添加一个节来实现我们自己想实现的功能。</p><hr><p>然后我们在了解一下节表的主要成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//8个字节名字.自己可以起.编译器也可以给定.不重要.</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;       </span><br><span class="line">            DWORD   VirtualSize;           <span class="comment">//节数据没有对齐后的大小.也就是没有对齐.节数据有多大.</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;　　　　　　　　　　<span class="comment">//加载到内存中的第一个字节的地址.也就是虚拟地址.节在内存中哪里开始.内存中的VA + ImageBase 才是真正的节开始位置</span></span><br><span class="line">    DWORD   SizeOfRawData;　　　　　　　　　　 <span class="comment">//修改这个属性的值,即可扩大节.并且在PE文件中添加相应的0数据进行填充.</span></span><br><span class="line">    DWORD   PointerToRawData;　　　　　　　　  <span class="comment">//在文件中的偏移.是文件对齐成员倍数.</span></span><br><span class="line">    DWORD   PointerToRelocations;           <span class="comment">//一下都是调试相关.</span></span><br><span class="line">    DWORD   PointerToLinenumbers;           <span class="comment">//</span></span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;　　　　　　　　　　<span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>重点了解以下成员</p><blockquote><p>Name[IMAGE_SIZEOF_SHORT_NAME]:我们可以随便起一个自己喜欢的名字 VirtualSize：是在内存中的真实大小<br>VirtualAddress：是加载到内存中第一个字节的偏移地址 SizeOfRawData：该节在文件对齐后的大小</p></blockquote><hr><p>了解过节表以后，我们再来整理一下操作步骤。</p><p>[TOC]</p><h1 id="1-判断是否有空间新增一个节。"><a href="#1-判断是否有空间新增一个节。" class="headerlink" title="1.判断是否有空间新增一个节。"></a>1.判断是否有空间新增一个节。</h1><p>使用工具打开一个exe文件，我们只需要40个字节，所以空间足够<br><img src="https://img-blog.csdnimg.cn/20210611122435362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="2-在节表的最后一个成员后新增一个成员。"><a href="#2-在节表的最后一个成员后新增一个成员。" class="headerlink" title="2.在节表的最后一个成员后新增一个成员。"></a>2.在节表的最后一个成员后新增一个成员。</h1><p>添加的新成员我们可以选择直接复制text节表，因为text作为代码段，可读可写可执行，非常完美。如下图，我们已经添加好了数据。<br><img src="https://img-blog.csdnimg.cn/20210611122700675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="3-修改节的数量。"><a href="#3-修改节的数量。" class="headerlink" title="3.修改节的数量。"></a>3.修改节的数量。</h1><p>标准pe头中有一个字段为 NumberOfSections，该字段控制文件中节的数量<br>，所以我们讲该字段的值加一，如下图，原来为08，我们修改为09</p><p><img src="https://img-blog.csdnimg.cn/20210611153418937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="4-修改sizeOfImage的大小"><a href="#4-修改sizeOfImage的大小" class="headerlink" title="4.修改sizeOfImage的大小"></a>4.修改sizeOfImage的大小</h1><p>修改前：<br>可选头中：SizeofImage ：000AC000<br><img src="https://img-blog.csdnimg.cn/20210611154120619.png" alt="在这里插入图片描述"></p><p>我们新增了0x1000节数据大小.那么我们的镜像大小也要加0x1000大小进行映射.注意.要按照内存对齐。<br>我们的原镜像大小以及按照内存对齐的方式存放了. 就是0xAC000. 那么我们加了0x1000的数据就是 0x1E000大小.我们修改为0xAD000。</p><hr><h1 id="5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍"><a href="#5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍" class="headerlink" title="5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)"></a>5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)</h1><p>插入了0x1000字节，填充为0</p><hr><h1 id="6-添加新增节表的属性"><a href="#6-添加新增节表的属性" class="headerlink" title="6.添加新增节表的属性"></a>6.添加新增节表的属性</h1><p>想要添加一个节表，首先我们需要为这个节表指明内存中开始展开的位置，文件中展开的位置，以及节表的大小。<br>这三个属性的字段分别是VirtualAddress、PointerToRawData、SizeOfRawData。然后我们在pe中把他们找出来并修改。<br>例如上一个节表对齐后的展开位置为 0xAc000 那么我们就修改为 0xAd000<br>修改前：<br><img src="https://img-blog.csdnimg.cn/20210611182603575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>修改后：</p><p><img src="https://img-blog.csdnimg.cn/20210611182610388.png" alt="在这里插入图片描述"></p><p>节.sizeofRawData修改<br>这个成员就是节数据按照文件对齐后的大小.取决于我们给这个节添加多少数据，这里我们之前添加了0x1000个字节。<br>　　这里修改为1000<br>　　<br><img src="https://img-blog.csdnimg.cn/20210611182619861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.PointerRawToData 文件偏移修改<br>最后修改的就是节在文件中哪里展开的. 这个我们需要看上一个节的文件偏移.以及节数据大小. 算出来的.<br>例如：<br>新增节的上一个节，偏移位置为1000，节数据在文件中对齐后的尺寸为100，那么1000-1100都是上一个节的数据</p><p>.tttt上一个节在文件中的偏移为8200，大小为600；<br>　那么tttt节的文件偏移就为8800<br>　<img src="https://img-blog.csdnimg.cn/20210611182634534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.VirtualSize修改<br>申请的新节空间大小，1000</p><p>节.PointerRawToData 文件偏移修改<br>我们新增节一般都是要求可读可写可执行的，所以这里直接修改为60000020。</p><p>实验结果：<br>新增节后的文件正常执行</p><p><img src="https://img-blog.csdnimg.cn/20210611182641868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>部分内容转载于：<a href="https://blog.csdn.net/weixin_43742894/article/details/115376779">https://blog.csdn.net/weixin_43742894/article/details/115376779</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构在空白区添加代码</title>
      <link href="2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"><a href="#想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。" class="headerlink" title="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"></a><strong>想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。</strong></h2></blockquote><p>1.查找本机MessageBoxA地址<br>2.打开OD调试工具拖入要添加的exe程序。<br>3.在命令中输入 : （输入后按下回车键）<br>4.找任意一段空白区添加上代码 （最好是添加到 空白区开始预留一行的位置，便于以后再添加更多代码节约空间）<br>5.计算E8跳转的地址<br>6.修改OEP （程序入口的点）</p><blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2></blockquote><table><thead><tr><th>汇编指令</th><th>硬编码</th></tr></thead><tbody><tr><td>call</td><td>E8 00 00 00 00</td></tr><tr><td>jmp</td><td>E9 00 00 00 00</td></tr><tr><td>push</td><td>6A 00</td></tr></tbody></table><h2 id="1-查找本机MessageBoxA地址"><a href="#1-查找本机MessageBoxA地址" class="headerlink" title="1.查找本机MessageBoxA地址"></a>1.查找本机MessageBoxA地址</h2><p>1.打开OD调试工具拖入要添加的exe程序。<br>讲你想要修改的exe程序拖入od调试工具中，这里我们需要注意该exe程序必须有user32.dll，否则没有我们要添加的代码–MessageA函数的地址。<br><img src="https://img-blog.csdnimg.cn/20210609215454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-在命令中输入-（输入后按下回车键）"><a href="#2-在命令中输入-（输入后按下回车键）" class="headerlink" title="2.在命令中输入 : （输入后按下回车键）"></a>2.在命令中输入 : （输入后按下回车键）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp MessageBoxA</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210609215640888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如此一来，我们就成功在MessageA函数的地址下了断点。点击断点的窗口即可查看我们设置好的断点。<br><img src="https://img-blog.csdnimg.cn/20210609215811850.png" alt="在这里插入图片描述"></p><h2 id="开始添加代码"><a href="#开始添加代码" class="headerlink" title="开始添加代码"></a>开始添加代码</h2><p>1.接下来就该添加我们想要添加的代码了，随便找一个空白位置，然后我们计算call后的值，<br>call后的值=调用函数的地址-message函数的地址-5（call命令本身所占的内存大小），现在调用函数的地址是在问价中的地址，而不是在内存中的地址，所以首先我们需要找到程序载入内存的基地址ImageBase，在扩展PE头的第 28 个字节后面的 4 个字节表示的 ImageBase ( 程序基地址 )，如下图<br><img src="https://img-blog.csdnimg.cn/20210610205831374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1表示扩展pe头，2表示标准pe头），所以当前调用函数的地址为我们在文件中添加call指令的地址加上imagebase的值，所以call后的值=MessageBoxA的地址 - 当前调用函数的地址 - 5<br>此时计算好地址后，查看对应的硬编码，首先是三个push：6A 00 6A 00 6A 00 6A 00 然后是call 指令 E8，然后写如我们计算好的地址，记得小端存储。<br>代码我们已经写好了，那么我们现在应该想想怎么使程序到这个地址来执行我们添加的代码，我们可以修改程序的入口函数eop，（在扩展PE头的第 16 个字节后面的 4 个字节），如下图<br><img src="https://img-blog.csdnimg.cn/20210610211816996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1程序入口:0x401170（相对于程序基地址）2，扩展PE头的开始）<br>把程序拖入OD，程序第一次停止的的地址就是程序入口<br><img src="https://img-blog.csdnimg.cn/20210610212056621.png" alt="在这里插入图片描述"></p><p>所以只要修改程序入口地址，把程序入口改为调用函数的地址，然后在调用后再返回到真正的程序入口，就可以在程序执行前执行我们想调用的函数</p><p>修改程序入口为0x600</p><p><img src="https://img-blog.csdnimg.cn/20210610212115474.png" alt="在这里插入图片描述"></p><p>现在就9可以达到在程序执行前调用MessgaBoxA函数的效果，但是要执行完这个函数后，再返回到真正的程序入口，不然程序不能够正常运行，于是又要在我们要调用的函数后面再制造一个返回到真正程序入口处的机器码<br>这里就在用到jmp这个指令，表示直接跳转到某个指定的地址</p><p>先看一下jmp要如何使用</p><p><img src="https://img-blog.csdnimg.cn/20210610212230109.png" alt="在这里插入图片描述"></p><p>这里jmp的使用方法其实和call的规律一样只是开头的 E8 变成了 E9</p><p><img src="https://img-blog.csdnimg.cn/20210610212236672.png" alt="在这里插入图片描述"></p><p>所以E9后面的值应该是</p><p>jmp后的值 = 程序入口的地址 - 当前的地址 - 5 = 0x401170 - 0x40060D - 5 = 0x0B5E</p><p>当前的地址应该是0x40060D</p><p>所以修改后就是这样的<br><img src="https://img-blog.csdnimg.cn/20210610212246737.png" alt="在这里插入图片描述"></p><p>此时把程序另存为message_test.exe, 运行出现了我们预期的效果<br><img src="https://img-blog.csdnimg.cn/20210610212254405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>源程序的代码是很简单，但是要注意要有MessageBoxA函数</p><p>不然在最开始没有user32dll，我也不知道为什么，但如果是正常的程序都会有user32dll(因为一般的程序都有窗口)</p><p>我是用下面的代码做的实验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// messge.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nothing...&quot;</span>);</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">&quot;这是已有的弹框&quot;</span>,<span class="string">&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单介绍一点点PE文件头结构</p><p>DOS头部分：</p><p>DOS MZ 文件头 (64字节):<br>前 64 个字节，最后 8 个字节表示 PE 文件头的开始位置, DOS 块结束前的位置，绿色箭头指向PE文件头的开始<br><img src="https://img-blog.csdnimg.cn/20210610212422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>DOS 块 (不确定):<br>链接器可插入数据</p><p>PE文件头:</p><p>PE文件标识 (4字节):<br>50 45 00 00</p><p>标准 PE 头 (20字节):</p><p>扩展 PE 头</p><p>(32位 224 [0xE0] , 64 位 240 [0xF0] ):</p><pre><code>  第 36 个字节开始的后 4 个字节表示 硬盘 中文件对齐的字节数大小,  前 4 个字节表示 内存 中文件对齐的字节数大小,  第 60 个字节开始的四个字节表示整个文件头的大小( DOS 部分+ PE 文件头),一定是对齐字节数的整数倍  第 16 个字节后面的 4 个字节表示程序入口(相对 ImageBase )  第 28 个字节后面面的 4 个字节表示的 ImageBase ( 程序基地址 )</code></pre><p>图片与部分内容转载于<a href="https://blog.csdn.net/m0_49490199/article/details/111657821">https://blog.csdn.net/m0_49490199/article/details/111657821</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于硬编码的一些理解（水）</title>
      <link href="2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/"/>
      <url>2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在最近的学习过程中，了解到了硬编码这一个名词，于是就去百度了一下，从字面意思上来看，我对硬编码的理解就是一种类似于编程语言的东西，但百度过后发现好像每一篇文章对硬编码的讲解都不大一样，搞得我一脸懵逼，于是就来总结一下各篇文章的讲解。首先我们看一下百度百科的结果：</p><blockquote><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。<br>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。<br>硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。<br>另一方面，软编码数据对用户输入，HTTP服务器响应或配置文件等任意信息进行编码，并在运行时确定。</p></blockquote><p>看完以后仍然一脸懵逼，于是继续百度，过程中看到了一个例子：<br><strong>硬编码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">　　a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a直接用固定数值2限定死了，如果想要修改的话(修改a的值或者==号右边的值都是很不方便的，而且很容易出错）很不方便。</p><p><strong>软编码</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">　　a ++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a和b都是变量名称，我们完全可以在初始化a和b的时候给二者赋值，不必直接用固定数值限定死，这样有利于方便修改，可谓”占据制高点，统筹全局”。<br>转载于:<a href="https://www.cnblogs.com/zhongshujunqia/p/4611543.html">https://www.cnblogs.com/zhongshujunqia/p/4611543.html</a></p><p>看过这两条例子以后，大概了解到硬编码只是一种编程方式。再结合百度百科的结果：<strong>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。</strong>大概了解到硬编码是把一个本来应该（可以）写到配置信息中的信息直接在程序代码中写死了。<br>例如，写了一个收发邮件的程序，用户名，密码，服务器地址等最好做成外部配置， 但是如果直接写死在程序代码中，每次改信息时需要重新编译了……这种程序不好维护。一般懒的程序员或者初学者这种程序产量较大。<br>在计算机程序或文本编辑中，hardcode(这个词比hard code用起来要频繁一些)是指将可变变量用一个固定值来代替的方法。<br>用这种方法编译后，如果以后需要更改此变量就非常困难了。<br>大部分程序语言里，可以将一个固定数值定义为一个标记，然后用这个特殊标记来取代变量名称。当标记名称改变时，变量名不变，这样，当重新编译整个程序时，所有变量都不再是固定值，这样就更容易的实现了改变变量的目的。<br>尽管通过编辑器的查找替换功能也能实现整个变量名称的替换，但也很有可能出现多换或者少换的情况，而在计算机程序中，任何小错误的出现都是不可饶恕的。<br>最好的方法是单独为变量名划分空间，来实现这种变化，就如同前面说的那样，将需要改变的变量名暂时用一个定义好的标记名称来代替就是一种很好的方法。<br>通常情况下，都应该避免使用hardcode方法。有时也用hardcode来形容那些非常难学的语言，比如C或者C++语言，相对的，用softcode来形容象VB这类简单好用的程序语言。<br><strong>hardcode就是固化的代码</strong>。有的代码不能写死，不然修改起来很麻烦。比如说写链接写死<a href="http://www.abc.com,所有的地方都用这个,如果下次域名变了,那么就要找到所有的www.abc.com修改成新的域名./">www.abc.com，所有的地方都用这个，如果下次域名变了，那么就要找到所有的www.abc.com修改成新的域名。</a><br>但是如果用一个常量来存放<a href="http://www.abc.com,然后所有链接都引用常量,那么以后修改就只要修改常量了./">www.abc.com，然后所有链接都引用常量，那么以后修改就只要修改常量了。</a></p><p>部分内容参考于<a href="https://zhuanlan.zhihu.com/p/54134459">https://zhuanlan.zhihu.com/p/54134459</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件对齐</title>
      <link href="2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/"/>
      <url>2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>内存对齐与文件对齐</strong></p></blockquote><p>一个pe文件无论在磁盘和内存中存放都会进行对齐，但他们的对齐值会不相同。<br>PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。<br>PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。<br>rva与fov的相互转换</p><blockquote><p><strong>RVA与FOV的相互转换</strong></p></blockquote><p>为什么要转换：可以通过内存位置.找到文件中这个数据的位置. 或者反之. 如果找到就可以进行修改了。<br>RVA(Relative Virtual Address)指的是内存中的一个数据相对于文件头位置的偏移量。<br>举个例子：<br>当我们想要访问一个数据时，如果 Windows 装载器将一个PE 文件装入到 00400000h 处的内存中，而某个区块中的某个数据被装入 0040…xh 处，那么这个数据的 RVA 就是（0040…xh - 00400000h ）= …xh。(RVA = 虚拟地址-ImageBase(模块基址.程序一开始的地址.))<br>FOV与RVA大致相同，FOV指的是文件在硬盘中时访问的数据的的位置相对于文件头位置的偏移量。<br>所以由此我们可以看到他们之间的关系。当rva的位置在文件头中时，由于rva还没有收到拉伸的影响，所以此时rva等于fov的值。<br>当不在文件头中时，我们只需要计算出数据的位置，与该数据所在的节的差值，然后该差值是与硬盘中的数据所在位置与所在节的差值相同，所以我们先求出差值=rva-节<em>virtualadress(内存对齐值)。然后fov=差值+节</em>pointertorawData(文件对齐值)。</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/06/01/pe%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/01/pe%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a><strong>DOS头</strong></h2></blockquote><p>typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header<br>WORD   e_magic;                     // 一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>WORD   e_cblp;                      <br>WORD   e_cp;                        <br>WORD   e_crlc;                      <br>WORD   e_cparhdr;                <br>WORD   e_minalloc;                  <br>WORD   e_maxalloc;                <br>WORD   e_ss;                      <br>WORD   e_sp;                      <br>WORD   e_csum;                <br>WORD   e_ip;                        <br>WORD   e_cs;                        <br>WORD   e_lfarlc;                <br>WORD   e_ovno;                <br>WORD   e_res[4];      <br>WORD   e_oemid;                  <br>WORD   e_oeminfo;                  <br>WORD   e_res2[10];                <br>LONG   e_lfanew;                    //Offset to start of PE header   指向PE文件头<br>  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;                                        </p><blockquote><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a><strong>PE文件头</strong></h2></blockquote><p>IMAGE_NT_HEADERS STRUCT<br>DWORD Signature                    PE文件标识<br>IMAGE_FILE_HEADER  FileHeader     pe标准文件头<br>IMAGE_OPTIONAL_HEADER32 OptionalHeader<br>IMAGE_NT_HEADERS ENDS                                        </p><blockquote><h2 id="pe标准文件头"><a href="#pe标准文件头" class="headerlink" title="pe标准文件头"></a><strong>pe标准文件头</strong></h2></blockquote><p>typedef struct_IMAGE_FILE_HEADER{<br>WORD Machine;          //可以运行在什么cpu上，任意: 0   Intel 386以及后续: 14C   x86: 8864<br>WORD NumberOfSections;                  //表示节的数量(一共有多少个节)<br>DWORD TimeDataStamp;              //编写器填写的时间戳 与文件属性里面(创建时间、修改时间)无关<br>DWORD PointerToSymbolTable          //调试相关<br>DWORD PointerOfSymbols;             //调试相关<br>WORD SizeOfOptionalHeader             //可选PE头的大小(32位PE文件;  0xE0 64位PE文件: 0xF0)<br>WORD Characteristics;               //文件属性<br>}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;                                        </p><blockquote><h2 id="pe可选文件头"><a href="#pe可选文件头" class="headerlink" title="pe可选文件头"></a><strong>pe可选文件头</strong></h2></blockquote><p>//32位的可选pe头长度为E0， 64位的可选pe头长度为F0</p><p>WORD    Magic;        *                说明文件类型：10B 32位下的PE文件     20B 64位下的PE文件<br>BYTE    MajorLinkerVersion;<br>BYTE    MinorLinkerVersion;<br>DWORD   SizeOfCode;*                所有代码节的和，必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfInitializedData;*                已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfUninitializedData;*                未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   AddressOfEntryPoint;*                程序入口<br>DWORD   BaseOfCode;*                代码开始的基址，编译器填的   没用<br>DWORD   BaseOfData;*                数据开始的基址，编译器填的   没用<br>DWORD   ImageBase;*                内存镜像基址<br>DWORD   SectionAlignment;*                内存对齐<br>DWORD   FileAlignment;*                文件对齐<br>WORD    MajorOperatingSystemVersion;<br>WORD    MinorOperatingSystemVersion;<br>WORD    MajorImageVersion;<br>WORD    MinorImageVersion;<br>WORD    MajorSubsystemVersion;<br>WORD    MinorSubsystemVersion;<br>DWORD   Win32VersionValue;<br>DWORD   SizeOfImage;*                内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍<br>DWORD   SizeOfHeaders;*                所有头+节表按照文件对齐后的大小，否则加载会出错<br>DWORD   CheckSum;*                校验和，一些系统文件有要求.用来判断文件是否被修改.<br>WORD    Subsystem;<br>WORD    DllCharacteristics;<br>DWORD   SizeOfStackReserve;*                初始化时保留的堆栈大小<br>DWORD   SizeOfStackCommit;*                初始化时实际提交的大小<br>DWORD   SizeOfHeapReserve;*                初始化时保留的堆大小<br>DWORD   SizeOfHeapCommit;*                初始化时实践提交的大小<br>DWORD   LoaderFlags;<br>DWORD   NumberOfRvaAndSizes;*                目录项数目，剩余结构体的数量            </p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
