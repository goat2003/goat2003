<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pe文件结构在空白区添加代码</title>
      <link href="2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"><a href="#想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。" class="headerlink" title="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"></a><strong>想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。</strong></h2></blockquote><p>1.查找本机MessageBoxA地址<br>2.打开OD调试工具拖入要添加的exe程序。<br>3.在命令中输入 : （输入后按下回车键）<br>4.找任意一段空白区添加上代码 （最好是添加到 空白区开始预留一行的位置，便于以后再添加更多代码节约空间）<br>5.计算E8跳转的地址<br>6.修改OEP （程序入口的点）</p><blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2></blockquote><table><thead><tr><th>汇编指令</th><th>硬编码</th></tr></thead><tbody><tr><td>call</td><td>E8 00 00 00 00</td></tr><tr><td>jmp</td><td>E9 00 00 00 00</td></tr><tr><td>push</td><td>6A 00</td></tr></tbody></table><h2 id="1-查找本机MessageBoxA地址"><a href="#1-查找本机MessageBoxA地址" class="headerlink" title="1.查找本机MessageBoxA地址"></a>1.查找本机MessageBoxA地址</h2><p>1.打开OD调试工具拖入要添加的exe程序。<br>讲你想要修改的exe程序拖入od调试工具中，这里我们需要注意该exe程序必须有user32.dll，否则没有我们要添加的代码–MessageA函数的地址。<br><img src="https://img-blog.csdnimg.cn/20210609215454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-在命令中输入-（输入后按下回车键）"><a href="#2-在命令中输入-（输入后按下回车键）" class="headerlink" title="2.在命令中输入 : （输入后按下回车键）"></a>2.在命令中输入 : （输入后按下回车键）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp MessageBoxA</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210609215640888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如此一来，我们就成功在MessageA函数的地址下了断点。点击断点的窗口即可查看我们设置好的断点。<br><img src="https://img-blog.csdnimg.cn/20210609215811850.png" alt="在这里插入图片描述"></p><h2 id="开始添加代码"><a href="#开始添加代码" class="headerlink" title="开始添加代码"></a>开始添加代码</h2><p>1.接下来就该添加我们想要添加的代码了，随便找一个空白位置，然后我们计算call后的值，<br>call后的值=调用函数的地址-message函数的地址-5（call命令本身所占的内存大小），现在调用函数的地址是在问价中的地址，而不是在内存中的地址，所以首先我们需要找到程序载入内存的基地址ImageBase，在扩展PE头的第 28 个字节后面的 4 个字节表示的 ImageBase ( 程序基地址 )，如下图<br><img src="https://img-blog.csdnimg.cn/20210610205831374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1表示扩展pe头，2表示标准pe头），所以当前调用函数的地址为我们在文件中添加call指令的地址加上imagebase的值，所以call后的值=MessageBoxA的地址 - 当前调用函数的地址 - 5<br>此时计算好地址后，查看对应的硬编码，首先是三个push：6A 00 6A 00 6A 00 6A 00 然后是call 指令 E8，然后写如我们计算好的地址，记得小端存储。<br>代码我们已经写好了，那么我们现在应该想想怎么使程序到这个地址来执行我们添加的代码，我们可以修改程序的入口函数eop，（在扩展PE头的第 16 个字节后面的 4 个字节），如下图<br><img src="https://img-blog.csdnimg.cn/20210610211816996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1程序入口:0x401170（相对于程序基地址）2，扩展PE头的开始）<br>把程序拖入OD，程序第一次停止的的地址就是程序入口<br><img src="https://img-blog.csdnimg.cn/20210610212056621.png" alt="在这里插入图片描述"></p><p>所以只要修改程序入口地址，把程序入口改为调用函数的地址，然后在调用后再返回到真正的程序入口，就可以在程序执行前执行我们想调用的函数</p><p>修改程序入口为0x600</p><p><img src="https://img-blog.csdnimg.cn/20210610212115474.png" alt="在这里插入图片描述"></p><p>现在就9可以达到在程序执行前调用MessgaBoxA函数的效果，但是要执行完这个函数后，再返回到真正的程序入口，不然程序不能够正常运行，于是又要在我们要调用的函数后面再制造一个返回到真正程序入口处的机器码<br>这里就在用到jmp这个指令，表示直接跳转到某个指定的地址</p><p>先看一下jmp要如何使用</p><p><img src="https://img-blog.csdnimg.cn/20210610212230109.png" alt="在这里插入图片描述"></p><p>这里jmp的使用方法其实和call的规律一样只是开头的 E8 变成了 E9</p><p><img src="https://img-blog.csdnimg.cn/20210610212236672.png" alt="在这里插入图片描述"></p><p>所以E9后面的值应该是</p><p>jmp后的值 = 程序入口的地址 - 当前的地址 - 5 = 0x401170 - 0x40060D - 5 = 0x0B5E</p><p>当前的地址应该是0x40060D</p><p>所以修改后就是这样的<br><img src="https://img-blog.csdnimg.cn/20210610212246737.png" alt="在这里插入图片描述"></p><p>此时把程序另存为message_test.exe, 运行出现了我们预期的效果<br><img src="https://img-blog.csdnimg.cn/20210610212254405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>源程序的代码是很简单，但是要注意要有MessageBoxA函数</p><p>不然在最开始没有user32dll，我也不知道为什么，但如果是正常的程序都会有user32dll(因为一般的程序都有窗口)</p><p>我是用下面的代码做的实验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// messge.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nothing...&quot;</span>);</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">&quot;这是已有的弹框&quot;</span>,<span class="string">&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单介绍一点点PE文件头结构</p><p>DOS头部分：</p><p>DOS MZ 文件头 (64字节):<br>前 64 个字节，最后 8 个字节表示 PE 文件头的开始位置, DOS 块结束前的位置，绿色箭头指向PE文件头的开始<br><img src="https://img-blog.csdnimg.cn/20210610212422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>DOS 块 (不确定):<br>链接器可插入数据</p><p>PE文件头:</p><p>PE文件标识 (4字节):<br>50 45 00 00</p><p>标准 PE 头 (20字节):</p><p>扩展 PE 头</p><p>(32位 224 [0xE0] , 64 位 240 [0xF0] ):</p><pre><code>  第 36 个字节开始的后 4 个字节表示 硬盘 中文件对齐的字节数大小,  前 4 个字节表示 内存 中文件对齐的字节数大小,  第 60 个字节开始的四个字节表示整个文件头的大小( DOS 部分+ PE 文件头),一定是对齐字节数的整数倍  第 16 个字节后面的 4 个字节表示程序入口(相对 ImageBase )  第 28 个字节后面面的 4 个字节表示的 ImageBase ( 程序基地址 )</code></pre><p>图片与部分内容转载于<a href="https://blog.csdn.net/m0_49490199/article/details/111657821">https://blog.csdn.net/m0_49490199/article/details/111657821</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于硬编码的一些理解（水）</title>
      <link href="2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/"/>
      <url>2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在最近的学习过程中，了解到了硬编码这一个名词，于是就去百度了一下，从字面意思上来看，我对硬编码的理解就是一种类似于编程语言的东西，但百度过后发现好像每一篇文章对硬编码的讲解都不大一样，搞得我一脸懵逼，于是就来总结一下各篇文章的讲解。首先我们看一下百度百科的结果：</p><blockquote><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。<br>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。<br>硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。<br>另一方面，软编码数据对用户输入，HTTP服务器响应或配置文件等任意信息进行编码，并在运行时确定。</p></blockquote><p>看完以后仍然一脸懵逼，于是继续百度，过程中看到了一个例子：<br><strong>硬编码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">　　a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a直接用固定数值2限定死了，如果想要修改的话(修改a的值或者==号右边的值都是很不方便的，而且很容易出错）很不方便。</p><p><strong>软编码</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">　　a ++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a和b都是变量名称，我们完全可以在初始化a和b的时候给二者赋值，不必直接用固定数值限定死，这样有利于方便修改，可谓”占据制高点，统筹全局”。<br>转载于:<a href="https://www.cnblogs.com/zhongshujunqia/p/4611543.html">https://www.cnblogs.com/zhongshujunqia/p/4611543.html</a></p><p>看过这两条例子以后，大概了解到硬编码只是一种编程方式。再结合百度百科的结果：<strong>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。</strong>大概了解到硬编码是把一个本来应该（可以）写到配置信息中的信息直接在程序代码中写死了。<br>例如，写了一个收发邮件的程序，用户名，密码，服务器地址等最好做成外部配置， 但是如果直接写死在程序代码中，每次改信息时需要重新编译了……这种程序不好维护。一般懒的程序员或者初学者这种程序产量较大。<br>在计算机程序或文本编辑中，hardcode(这个词比hard code用起来要频繁一些)是指将可变变量用一个固定值来代替的方法。<br>用这种方法编译后，如果以后需要更改此变量就非常困难了。<br>大部分程序语言里，可以将一个固定数值定义为一个标记，然后用这个特殊标记来取代变量名称。当标记名称改变时，变量名不变，这样，当重新编译整个程序时，所有变量都不再是固定值，这样就更容易的实现了改变变量的目的。<br>尽管通过编辑器的查找替换功能也能实现整个变量名称的替换，但也很有可能出现多换或者少换的情况，而在计算机程序中，任何小错误的出现都是不可饶恕的。<br>最好的方法是单独为变量名划分空间，来实现这种变化，就如同前面说的那样，将需要改变的变量名暂时用一个定义好的标记名称来代替就是一种很好的方法。<br>通常情况下，都应该避免使用hardcode方法。有时也用hardcode来形容那些非常难学的语言，比如C或者C++语言，相对的，用softcode来形容象VB这类简单好用的程序语言。<br><strong>hardcode就是固化的代码</strong>。有的代码不能写死，不然修改起来很麻烦。比如说写链接写死<a href="http://www.abc.com,所有的地方都用这个,如果下次域名变了,那么就要找到所有的www.abc.com修改成新的域名./">www.abc.com，所有的地方都用这个，如果下次域名变了，那么就要找到所有的www.abc.com修改成新的域名。</a><br>但是如果用一个常量来存放<a href="http://www.abc.com,然后所有链接都引用常量,那么以后修改就只要修改常量了./">www.abc.com，然后所有链接都引用常量，那么以后修改就只要修改常量了。</a></p><p>部分内容参考于<a href="https://zhuanlan.zhihu.com/p/54134459">https://zhuanlan.zhihu.com/p/54134459</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件对齐</title>
      <link href="2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/"/>
      <url>2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>内存对齐与文件对齐</strong></p></blockquote><p>一个pe文件无论在磁盘和内存中存放都会进行对齐，但他们的对齐值会不相同。<br>PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。<br>PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。<br>rva与fov的相互转换</p><blockquote><p><strong>RVA与FOV的相互转换</strong></p></blockquote><p>为什么要转换：可以通过内存位置.找到文件中这个数据的位置. 或者反之. 如果找到就可以进行修改了。<br>RVA(Relative Virtual Address)指的是内存中的一个数据相对于文件头位置的偏移量。<br>举个例子：<br>当我们想要访问一个数据时，如果 Windows 装载器将一个PE 文件装入到 00400000h 处的内存中，而某个区块中的某个数据被装入 0040…xh 处，那么这个数据的 RVA 就是（0040…xh - 00400000h ）= …xh。(RVA = 虚拟地址-ImageBase(模块基址.程序一开始的地址.))<br>FOV与RVA大致相同，FOV指的是文件在硬盘中时访问的数据的的位置相对于文件头位置的偏移量。<br>所以由此我们可以看到他们之间的关系。当rva的位置在文件头中时，由于rva还没有收到拉伸的影响，所以此时rva等于fov的值。<br>当不在文件头中时，我们只需要计算出数据的位置，与该数据所在的节的差值，然后该差值是与硬盘中的数据所在位置与所在节的差值相同，所以我们先求出差值=rva-节<em>virtualadress(内存对齐值)。然后fov=差值+节</em>pointertorawData(文件对齐值)。</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/06/01/pe%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/01/pe%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a><strong>DOS头</strong></h2></blockquote><p>typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header<br>WORD   e_magic;                     // 一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>WORD   e_cblp;                      <br>WORD   e_cp;                        <br>WORD   e_crlc;                      <br>WORD   e_cparhdr;                <br>WORD   e_minalloc;                  <br>WORD   e_maxalloc;                <br>WORD   e_ss;                      <br>WORD   e_sp;                      <br>WORD   e_csum;                <br>WORD   e_ip;                        <br>WORD   e_cs;                        <br>WORD   e_lfarlc;                <br>WORD   e_ovno;                <br>WORD   e_res[4];      <br>WORD   e_oemid;                  <br>WORD   e_oeminfo;                  <br>WORD   e_res2[10];                <br>LONG   e_lfanew;                    //Offset to start of PE header   指向PE文件头<br>  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;                                        </p><blockquote><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a><strong>PE文件头</strong></h2></blockquote><p>IMAGE_NT_HEADERS STRUCT<br>DWORD Signature                    PE文件标识<br>IMAGE_FILE_HEADER  FileHeader     pe标准文件头<br>IMAGE_OPTIONAL_HEADER32 OptionalHeader<br>IMAGE_NT_HEADERS ENDS                                        </p><blockquote><h2 id="pe标准文件头"><a href="#pe标准文件头" class="headerlink" title="pe标准文件头"></a><strong>pe标准文件头</strong></h2></blockquote><p>typedef struct_IMAGE_FILE_HEADER{<br>WORD Machine;          //可以运行在什么cpu上，任意: 0   Intel 386以及后续: 14C   x86: 8864<br>WORD NumberOfSections;                  //表示节的数量(一共有多少个节)<br>DWORD TimeDataStamp;              //编写器填写的时间戳 与文件属性里面(创建时间、修改时间)无关<br>DWORD PointerToSymbolTable          //调试相关<br>DWORD PointerOfSymbols;             //调试相关<br>WORD SizeOfOptionalHeader             //可选PE头的大小(32位PE文件;  0xE0 64位PE文件: 0xF0)<br>WORD Characteristics;               //文件属性<br>}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;                                        </p><blockquote><h2 id="pe可选文件头"><a href="#pe可选文件头" class="headerlink" title="pe可选文件头"></a><strong>pe可选文件头</strong></h2></blockquote><p>//32位的可选pe头长度为E0， 64位的可选pe头长度为F0</p><p>WORD    Magic;        *                说明文件类型：10B 32位下的PE文件     20B 64位下的PE文件<br>BYTE    MajorLinkerVersion;<br>BYTE    MinorLinkerVersion;<br>DWORD   SizeOfCode;*                所有代码节的和，必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfInitializedData;*                已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfUninitializedData;*                未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   AddressOfEntryPoint;*                程序入口<br>DWORD   BaseOfCode;*                代码开始的基址，编译器填的   没用<br>DWORD   BaseOfData;*                数据开始的基址，编译器填的   没用<br>DWORD   ImageBase;*                内存镜像基址<br>DWORD   SectionAlignment;*                内存对齐<br>DWORD   FileAlignment;*                文件对齐<br>WORD    MajorOperatingSystemVersion;<br>WORD    MinorOperatingSystemVersion;<br>WORD    MajorImageVersion;<br>WORD    MinorImageVersion;<br>WORD    MajorSubsystemVersion;<br>WORD    MinorSubsystemVersion;<br>DWORD   Win32VersionValue;<br>DWORD   SizeOfImage;*                内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍<br>DWORD   SizeOfHeaders;*                所有头+节表按照文件对齐后的大小，否则加载会出错<br>DWORD   CheckSum;*                校验和，一些系统文件有要求.用来判断文件是否被修改.<br>WORD    Subsystem;<br>WORD    DllCharacteristics;<br>DWORD   SizeOfStackReserve;*                初始化时保留的堆栈大小<br>DWORD   SizeOfStackCommit;*                初始化时实际提交的大小<br>DWORD   SizeOfHeapReserve;*                初始化时保留的堆大小<br>DWORD   SizeOfHeapCommit;*                初始化时实践提交的大小<br>DWORD   LoaderFlags;<br>DWORD   NumberOfRvaAndSizes;*                目录项数目，剩余结构体的数量            </p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
