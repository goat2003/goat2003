<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对于硬编码的一些理解（水）</title>
      <link href="2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/"/>
      <url>2021/06/14/esp%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>esp定律脱壳</p><p>————————————纯属个人理解，如有不对求大佬指正。</p><p>看了好多关于esp定律脱壳的文章，都没看懂，o(≧口≦)o，可能是本人太笨了吧。所以就来浅谈一下自己对于esp脱壳的理解。</p><p>个人对于esp脱壳的理解是先把壳跑完，此时的oep就是真正的程序入口。然后再将源程序通过工具dump出来为一个exe文件，再进行一些修复操作，就脱壳完毕了。</p><p>接下来是实战操作 ┭┮﹏┭┮ ，我直接通过buuctf里的<a href="https://buuoj.cn/challenges#%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90">新年快乐</a>题目来操作吧。</p><h4 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h4><p>首先拖入ide中，我们会发现只有两个函数，是不是很可疑，</p><p><img src="https://img-blog.csdnimg.cn/20201113093639895.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="没脱壳拖入ida"></p><p>所以我们直接将它拖入Exeinfope中</p><p><img src="/.com//blog\source\images\esp脱壳\image-20210614154629368.png" alt="查壳"></p><p>可以看到该exe文件里有一个UPX壳，那么我们就开始脱壳吧。</p><h4 id="esp脱壳"><a href="#esp脱壳" class="headerlink" title="esp脱壳"></a>esp脱壳</h4><p>esp定律脱壳（个人理解）：<br>在外壳代码中有一个pushad的指令，该指令会将所有的寄存器的值都压入栈中也就是说在pushad指令之后esp的值就是指向外壳的代码段了，等之后运行完外壳程序，我们只要找到OEP就可以了</p><p>关于esp定律如果有不懂的话推荐看一下这个<a href="https://www.52pojie.cn/thread-294844-1-1.html">文章</a>，或者百度。反正都比我讲的好多了。 o(￣ヘ￣o＃)</p><h5 id="拖入od"><a href="#拖入od" class="headerlink" title="拖入od"></a>拖入od</h5><p>将exe拖入XP2dbg开始分析，首先找到pushad，</p><p><img src="/.com//blog\source\images\esp脱壳\image-20210614155437315.png" alt="找pushad的断点"></p><p>双击进入，将eip指向这里</p><p><img src="/.com//blog\source\images\esp脱壳\image-20210614155556333.png" alt="从pushad断点开始运行"></p><p>然后f8单步运行，此时我们可以看到esp的变化，右键esp，转到内存窗口设置断点</p><p><img src="https://img-blog.csdnimg.cn/20201114084603988.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设置内存断点"></p><p><img src="https://img-blog.csdnimg.cn/20201114084842340.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="设断点"></p><p>运行，关于这两步操作我来做一下解释，因为pushad以后esp指向的是外壳的代码段，所以我们将断点设置在此处，然后运行到此处以后，就可以找到我们的程序入口oep了。</p><p><img src="/.com//blog\source\images\esp脱壳\image-20210614163413468.png" alt="image-20210614163413468"></p><p>此时，程序停下来以后，往上看我们可以看到popad，该指令刚好与pushad对应，可以将内存器里的值进行还原。找到下面jmp指令要跳转的位置就是我们的程序的入口oep。</p><p><img src="/.com//blog\source\images\esp脱壳\image-20210614170558703.png" alt="找到oep"></p><p>oep已找到，接下来开始dump</p><h4 id="dump操作"><a href="#dump操作" class="headerlink" title="dump操作"></a>dump操作</h4><p>（这里忘截图了，直接挂大佬的操作图了）<img src="https://img-blog.csdnimg.cn/20201114091101713.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>操作如下：<img src="https://img-blog.csdnimg.cn/20201114091242417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201114092646790.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后再fixdump一下，会弹下图，如果未弹出，可以先perebuild（具体操作与fixdump相同）然后再fixdump（具体原理还在挖掘中）</p><p><img src="https://img-blog.csdnimg.cn/20201114092717465.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092726792.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092735101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114092739904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI4NzMxNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>脱壳完成！</p><p>另外鸣谢大佬，挂上大佬<a href="https://blog.csdn.net/weixin_46287316/article/details/109669066?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-11.base">文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe总结2（转载）</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%932/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<p>一篇转载文章，转载于：<a href="https://www.52pojie.cn/thread-1393291-1-1.html">https://www.52pojie.cn/thread-1393291-1-1.html</a><br>一个PE文件可以分为两种状态：运行态和非运行态</p><p>非运行态：当一个PE文件尚未被运行时，其数据<strong>存储在磁盘中</strong>，也就是<a href="https://www.52pojie.cn/thread-1391994-1-1.html">PE个人笔记一之PE介绍</a>中PE的状态</p><p>运行态：当一个PE文件被打开后，PE文件的相关数据将被<strong>装载到内存中</strong>，此时为运行态</p><hr><p>在细讲PE两种状态前，回顾先前在笔记一中的相关内容：</p><h2 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316164115579.png" alt="image-20210316164115579"></p><h2 id="整体结构表"><a href="#整体结构表" class="headerlink" title="整体结构表"></a>整体结构表</h2><table><thead><tr><th align="left">结构</th><th align="left">对应C数据结构</th><th align="left">默认占用空间大小（单位字节）</th></tr></thead><tbody><tr><td align="left">DOS MZ头</td><td align="left">_IMAGE_DOS_HEADER</td><td align="left">64</td></tr><tr><td align="left">DOS Stub</td><td align="left">仅在MS-DOS系统下有效，不作研究</td><td align="left">不固定</td></tr><tr><td align="left">PE文件头</td><td align="left">_IMAGE_NT_HEADERS</td><td align="left">4+20+224=248</td></tr><tr><td align="left">PE文件头标志</td><td align="left">Signature</td><td align="left">4</td></tr><tr><td align="left">PE文件表头/标准PE头</td><td align="left">_IMAGE_FILE_HEADER</td><td align="left">20</td></tr><tr><td align="left">PE文件表头可选部分/扩展PE头</td><td align="left">_IMAGE_OPTIONAL_HEADER</td><td align="left">224</td></tr><tr><td align="left">块表/节表</td><td align="left">_IMAGE_SECTION_HEADER</td><td align="left">40</td></tr><tr><td align="left">块/节</td><td align="left">无</td><td align="left">由块表/节表决定</td></tr></tbody></table><hr><h1 id="非运行态"><a href="#非运行态" class="headerlink" title="非运行态"></a>非运行态</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>先前的笔记一中只是简单介绍了非运行态下如何判断一个文件是否为PE文件</p><p>接下来讲讲为何能通过之前的方法来判断PE文件</p><hr><p><strong>判断PE文件的流程</strong>可概括为如下三步：</p><ol><li>判断头2个字节是否为4D 5A（ASCII码为MZ）</li><li>找到3Ch位置数据</li><li>根据第二步中的位置数据再找到对应的地址，判断这个地址是否为50 45 00 00（对应ACSII码为PE..）</li></ol><hr><table><thead><tr><th align="left">地址</th><th align="left">长度（单位字节）</th><th align="left">对应C的数据结构</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的第一个成员e_magic</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">2</td><td align="left">_IMAGE_DOS_HEADER的最后一个成员e_lfanew</td><td align="left">指出PE头文件偏移位置</td><td align="left">不定</td><td align="left">不定</td></tr><tr><td align="left">[3C]</td><td align="left">4</td><td align="left">Signature</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>下面结合实例再来分析：</p><p>这次使用WinHex这个工具来进行查看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315210005799.png" alt="image-20210315210005799"></p><hr><p>此时对应的表格数据为：</p><table><thead><tr><th align="left">地址</th><th align="left">说明</th><th align="left">值</th><th align="left">ASCII</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">DOS MZ头的第一个成员</td><td align="left">4D 5A</td><td align="left">MZ</td></tr><tr><td align="left">3C</td><td align="left">指出PE头文件偏移位置</td><td align="left">F0</td><td align="left"></td></tr><tr><td align="left">F0</td><td align="left">PE文件头标志</td><td align="left">50 45 00 00</td><td align="left">PE..</td></tr></tbody></table><hr><p>上面对一个PE文件的判断只涉及了DOS MZ头和PE文件头中的PE文件头标志</p><p>下面继续分析其它结构</p><hr><h2 id="后续分析"><a href="#后续分析" class="headerlink" title="后续分析"></a>后续分析</h2><h3 id="PE文件头标志和标准PE头"><a href="#PE文件头标志和标准PE头" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p>从先前的PE的结构继续向后看24个字节（PE文件头标志的大小+标准PE头大小 4+20）得到扩展PE头的首地址</p><p>先前的地址为：F0</p><p>后来的地址为：0xF0+24=240+24=264=0x108</p><p>所以从F0～108为PE文件头标志和标准PE头</p><p>从108开始就是扩展PE头了</p><p>PE文件头标志和标准PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315212241373.png" alt="image-20210315212241373"></p><hr><h3 id="扩展PE头"><a href="#扩展PE头" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p>从先前得到的扩展PE头地址继续向后看224个字节（扩展PE头大小）得到块表的首地址</p><p>先前的地址为：108</p><p>后来的地址为：0x108+224=264+224=488=0x1E8</p><p>所以从108~1E8为扩展PE头</p><p>从1E8开始就是块表了</p><p>扩展PE头：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315213947563.png" alt="image-20210315213947563"></p><hr><h3 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h3><p>从先前得到的块表头地址继续向后看40个字节（块表大小）得到第二个块表的首地址</p><p>先前的地址为：1E8</p><p>后来的地址为：0x1E8+40=488+40=528=0x210</p><p>所以从1E8~210为第一个块表</p><p>从210开始就是第二个块表了</p><p>第一个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315234922585.png" alt="image-20210315234922585"></p><hr><p>同理可得剩下的几个块表</p><p>第二个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235048573.png" alt="image-20210315235048573"></p><p>地址从210~238</p><hr><p>第三个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235154581.png" alt="image-20210315235154581"></p><p>地址从238~260</p><hr><p>第四个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235402774.png" alt="image-20210315235402774"></p><p>地址从260~288</p><hr><p>第五个块表：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315235504709.png" alt="image-20210315235504709"></p><p>地址从288~2B0</p><hr><h4 id="汇总块表"><a href="#汇总块表" class="headerlink" title="汇总块表"></a>汇总块表</h4><table><thead><tr><th align="left">块名称</th><th align="left">块地址</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">1E8~210</td></tr><tr><td align="left">.rdata</td><td align="left">210~238</td></tr><tr><td align="left">.data</td><td align="left">238~260</td></tr><tr><td align="left">.rsrc</td><td align="left">260~288</td></tr><tr><td align="left">.reloc</td><td align="left">288~2B0</td></tr></tbody></table><hr><h3 id="块表后的空隙"><a href="#块表后的空隙" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>块表后面跟着的应该是块，但在块表后和块之前却多出了一段空间</p><p>这里为2B0~400</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316000131381.png" alt="image-20210316000131381"></p><hr><p>先前的PE结构中间都没有空隙，为<strong>连续存储</strong></p><p>但在<strong>块表和块之间是可能存在空隙的</strong>，这个空隙里一般被填充为编译器插入的数据（也可以没有,就是此时的情况）</p><p>这段空隙的修改并不会导致程序不可运行，因而可被拿来写入自己想要的代码来对程序进行修改</p><hr><p><strong>为什么会存在这段空隙？</strong></p><p>这段空隙存在的原因在于块表和块并没有<strong>连续存储</strong></p><p>所以这段空隙的存在与否及长度 取决于 <strong>块的起始位置</strong></p><p>而块的起始位置则<strong>由扩展PE头中的某个成员决定</strong></p><hr><p>给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SizeOfHeaders成员（DWORD类型占4个字节）</p><p>SizeOfHeaders的含义为<strong>3个头按照文件对齐后的大小</strong>：（DOS头大小+PE头大小+块表大小）加完的结果进行<strong>文件对齐</strong>后得到的大小</p><p>头大小相加很好理解，按照之前得到的头大小和为：2B0，于是问题就在于文件对齐</p><h4 id="什么是文件对齐"><a href="#什么是文件对齐" class="headerlink" title="什么是文件对齐"></a>什么是文件对齐</h4><p>讲到文件对齐就涉及到扩展PE头中的另一个成员：FileAlignment（DWORD类型占4个字节）</p><p>文件对齐就是要求SizeOfHeaders必须为FileAlignment的<strong>整数倍</strong></p><hr><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为108</p><p>从108开始往后找36个字节（中间间隔了1个WORD，2个BYTE，8个DWORD，即1<em>2+2</em>1+8*4=36）</p><p>FileAlignment的地址为：0x108+36=264+36=300=0x12C</p><p>FileAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003503508.png" alt="image-20210316003503508"></p><p>FileAlignment为00 00 02 00=0x200（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是FileAlignment的整数倍</p><p>于是将SizeOfHeaders设置为FileAlignment的整数倍：(2B0/200+1)*200=400</p><p>得出的SizeOfHeaders的大小应该为0x400</p><hr><p>再来验证一下SizeOfHeaders的大小</p><p>前面得到的FileAlignment的地址为12C</p><p>从12C开始往后找24个字节（中间间隔了6个WORD，3个DWORD，即6<em>2+3</em>4=24）</p><p>SizeOfHeaders的地址为：0x12C+24=300+24=324=0x144</p><p>SizeOfHeaders：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316003735412.png" alt="image-20210316003735412"></p><p>SizeOfHeaders为 00 00 04 00=0x400（小端存储）</p><p>得到的大小和计算出来的大小一致，验证完毕</p><hr><h4 id="为什么要文件对齐"><a href="#为什么要文件对齐" class="headerlink" title="为什么要文件对齐"></a>为什么要文件对齐</h4><p>和内存对齐一样，都是为了使执行时的效率更高，有关内存对齐可参考：<a href="https://www.52pojie.cn/thread-1385641-1-1.html#37246226_%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">逆向基础笔记十八 汇编 结构体和内存对齐</a></p><p>PS：上面的内存对齐为程序中<strong>局部的内存对齐</strong>，主要针对的是编程时的变量、结构体等，和后面要讲的内存对齐要区别开</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块的起始地址由块表中的PointerToRawData决定，<strong>第一个块</strong>的起始地址则由上面的SizeOfHeaders决定</p><p>块部分存储的为数据，如何存储由块表决定，这里主要探讨<strong>每个块的 起始地址、块大小、结束地址</strong>，其它留作之后的笔记</p><p>给出块表在C中的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码#define IMAGE_SIZEOF_SHORT_NAME              8</span><br><span class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;                        //&lt;--- 块的大小</span><br><span class="line">    DWORD   PointerToRawData;                //&lt;--- 块在磁盘文件中的偏移</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><hr><h4 id="块的起始地址"><a href="#块的起始地址" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>找到结构体中的PointerToRawData成员（DWORD类型占4个字节）</p><p>PointerToRawData的含义为<strong>该块在磁盘文件中的偏移</strong></p><p>前面已经知道第一个块表的首地址为1E8</p><p>从1E8开始往后找20个字节（中间间隔了1个BYTE[8]，3个DWORD，即1<em>8+3</em>4=20）</p><p>PointerToRawData的地址为：0x1E8+20=488+20=508=0x1FC</p><p>PointerToRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316011603629.png" alt="image-20210316011603629"></p><p>PointerToRawData为00 00 04 00=0x400</p><p>和通过SizeOfHeaders得到的一致，验证了<strong>第一个</strong>块的PointerToRawData由SizeOfHeaders决定</p><h4 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h4><p>SizeOfRawData为块的大小（文件对齐后）</p><p>SizeOfRawData就在PointerToRawData前面</p><p>所以其地址为：PointerToRawData地址-4=0x1FC-4=0x1F8</p><p>SizeOfRawData：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316152420615.png" alt="image-20210316152420615"></p><p>SizeOfRawData为00 92 19 00=0x199200</p><p>块的大小和前面三个头(DOS部首+PE文件头+块表)的大小一样，也要<strong>满足文件对齐</strong></p><p>先前得到的FileAlignment为0x200，这里的SizeOfRawData：0x199200为FileAlignment的整数倍，满足文件对齐</p><hr><h4 id="块的结束地址-下一个块的起始地址"><a href="#块的结束地址-下一个块的起始地址" class="headerlink" title="块的结束地址(下一个块的起始地址)"></a>块的结束地址(下一个块的起始地址)</h4><p>块的结束地址为块的起始地址+块的大小</p><p>即块的结束地址=0x400+0x199200=199600</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316153738194.png" alt="image-20210316153738194"></p><hr><p>可以看到第一个块和第二个块之前是<strong>存在空隙</strong>的，这段空隙也是由于<strong>文件对齐</strong>产生的</p><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>在非运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>文件对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>文件对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SizeOfHeaders</td><td align="left">扩展PE头</td><td align="left">头大小（文件对齐后）</td></tr><tr><td align="left">FileAlignment</td><td align="left">扩展PE头</td><td align="left">文件对齐</td></tr><tr><td align="left">PointerToRawData</td><td align="left">块表</td><td align="left">第一个块表的PointerToRawData由SizeOfHeaders决定，后面块表的PointerToRawData由前一个块表的PointerToRawData+SizeOfRawData决定</td></tr><tr><td align="left">SizeOfRawData</td><td align="left">块表</td><td align="left">块表的大小（文件对齐后）</td></tr></tbody></table><hr><p>记录一下各结构的起始和结束位置，方便和运行态进行比较</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">0</td><td align="left">F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">F0</td><td align="left">1E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">1E8</td><td align="left">2B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">0</td><td align="left">400</td><td align="left">0x400（文件对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">400</td><td align="left">199600</td><td align="left">0x199200（文件对齐后）</td></tr></tbody></table><hr><h1 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h1><p>前面介绍了非运行态（硬盘状态）下PE文件的结构，现在看看运行态（内存状态）下PE文件的结构</p><h2 id="加载运行态的PE文件"><a href="#加载运行态的PE文件" class="headerlink" title="加载运行态的PE文件"></a>加载运行态的PE文件</h2><p><strong>1.启动PE文件</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132316337.png" alt="image-20210316132316337"></p><hr><p><strong>2.然后返回WinHex，点击工具→打开RAM(R)… 或直接使用快捷键Alt+F9</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132406704.png" alt="image-20210316132406704"></p><hr><p><strong>3.打开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132549551.png" alt="image-20210316132549551"></p><p><strong>选中我们要分析的PE文件，使其展开</strong></p><hr><p><strong>4.展开后显示如下：</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316132819269.png" alt="image-20210316132819269"></p><p><strong>选中.exe打开</strong></p><hr><p><strong>5.最后确定即可</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316133031067.png" alt="image-20210316133031067"></p><hr><h2 id="分析运行态的PE文件"><a href="#分析运行态的PE文件" class="headerlink" title="分析运行态的PE文件"></a>分析运行态的PE文件</h2><p>按照先前分析的流程，再分析一遍运行态下的PE文件</p><h3 id="DOS部首和PE头标志"><a href="#DOS部首和PE头标志" class="headerlink" title="DOS部首和PE头标志"></a>DOS部首和PE头标志</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134218062.png" alt="image-20210316134218062"></p><p>此时的DOS部首起始地址为400000，结束地址为4000F0</p><hr><h3 id="PE文件头标志和标准PE头-1"><a href="#PE文件头标志和标准PE头-1" class="headerlink" title="PE文件头标志和标准PE头"></a>PE文件头标志和标准PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134123745.png" alt="image-20210316134123745"></p><p>此时PE文件头的起始地址为4000F0，结束地址为400108</p><hr><h3 id="扩展PE头-1"><a href="#扩展PE头-1" class="headerlink" title="扩展PE头"></a>扩展PE头</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134503765.png" alt="image-20210316134503765"></p><p>此时PE文件头的起始地址为400108，结束地址为4001E8</p><hr><h3 id="块表-1"><a href="#块表-1" class="headerlink" title="块表"></a>块表</h3><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316134642926.png" alt="image-20210316134642926"></p><p>此时块表的起始地址为4001E8，结束地址为4002B0</p><hr><h3 id="块表后的空隙-1"><a href="#块表后的空隙-1" class="headerlink" title="块表后的空隙"></a>块表后的空隙</h3><p>从前面的分析来看，在块表前的结构在运行态和非运行态除了起始地址不同以外，其它地方并无不同</p><p>起始地址的由来等相关内容留作之后的笔记说明</p><p>按照经验，块表后的空隙也应该是持续到先前的400+400000=400400</p><p>于是前往查看：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135241232.png" alt="image-20210316135241232"></p><hr><p>发现并非如此，400400仍然为空隙</p><p>先前分析得知在非运行态块表后的空隙是因为文件对齐产生的</p><p>而在运行态中，显然就<strong>不是由文件对齐决定的</strong></p><hr><p>接着向下查看，找到<strong>块的起始位置</strong></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316135922474.png" alt="image-20210316135922474"></p><hr><p>发现此时块的起始位置为401000，偏移为1000，而不是 非运行态的400</p><p>于是熟悉的问题又回来了：</p><p><strong>为什么会存在这段空隙？</strong></p><p>和先前的文件对齐类似，当程序处于运行态时，会有另一种对齐方式：<strong>内存对齐</strong></p><p>和内存对齐相关的属性和文件对齐（FileAlignment）类似，也是取决于扩展PE头中的一个成员</p><hr><p>再次给出扩展PE头在C中的定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_OPTIONAL_HEADER &#123;</span><br><span class="line">    //</span><br><span class="line">    // Standard fields.</span><br><span class="line">    //</span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line">    //</span><br><span class="line">    // NT additional fields.</span><br><span class="line">    //</span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;                        //&lt;--- 内存对齐</span><br><span class="line">    DWORD   FileAlignment;                                //&lt;--- 文件对齐</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;                                //&lt;--- 决定块的起始位置</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><hr><p>找到结构体中的SectionAlignment成员，会发现它就在FileAlignment（文件对齐）成员的上面</p><p>知道了由来以后，验证一下</p><p>前面已经得知了扩展PE头的首地址为400108</p><p>从400108开始往后找32个字节（中间间隔了1个WORD，2个BYTE，7个DWORD，即1<em>2+2</em>1+7*4=32）</p><p>SectionAlignment的地址为：0x400108+32=0x400000+264+32=0x400000+296=0x400128</p><p>SectionAlignment：</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316141510008.png" alt="image-20210316141510008"></p><p>SectionAlignment为00 10 00 00=0x1000（小端存储）</p><p>前面得到的头大小和为0x2B0显然不是SectionAlignment的整数倍</p><p>头大小应该设置为SectionAlignment的整数倍：(2B0/1000+1)*1000=1000</p><p>PS：这里的头大小不会被设置到SizeOfHeaders，因为SizeOfHeaders为文件对齐专用</p><h3 id="块-1"><a href="#块-1" class="headerlink" title="块"></a>块</h3><p>在非运行态中，块的起始位置由PointerToRawData决定，且PointerToRawData必须为FileAlignment的整数倍</p><p>但在运行态中，块的起始位置则并不由PointerToRawData决定，PointerToRawData和SizeOfHeaders一样都为文件对齐专用</p><p>运行态块存储涉及内容较多，这里只查看一下第一个块的起始地址、结束地址和大小，<strong>不作具体探究</strong>，其它留作之后的笔记</p><h4 id="块的起始地址-1"><a href="#块的起始地址-1" class="headerlink" title="块的起始地址"></a>块的起始地址</h4><p>第一个块的起始地址取决于（DOS部首+PE文件头+块表）的总大小进行内存对齐后的结果</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162649154.png" alt="image-20210316162649154"></p><p>第一个块的起始地址=0x400000+0x1000=0x401000</p><hr><h4 id="块的结束地址"><a href="#块的结束地址" class="headerlink" title="块的结束地址"></a>块的结束地址</h4><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316162347979.png" alt="image-20210316162347979"></p><p>第一个块的结束地址=0x59B000</p><hr><h4 id="块的大小-1"><a href="#块的大小-1" class="headerlink" title="块的大小"></a>块的大小</h4><p>块的大小=块的结束地址-块的起始地址=0x59B000-0x401000=0x19A000（满足内存对齐）</p><hr><p><strong>运行态时，块的大小满足内存对齐，非先前的文件对齐</strong></p><hr><h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p>在运行态下：</p><ul><li>DOS部首和PE文件头及块表连续存储，中间没有空隙</li><li>而块表和块之间由于<strong>内存对齐</strong>可能会存在空隙</li><li>块和块之间也由于<strong>内存对齐</strong>可能会存在空隙</li></ul><hr><p>相关数据结构成员：</p><table><thead><tr><th align="left">数据结构成员</th><th align="left">所属数据结构</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SectionAlignment</td><td align="left">扩展PE头</td><td align="left">内存对齐</td></tr></tbody></table><hr><p>各结构的起始和结束位置：</p><table><thead><tr><th align="left">结构</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">DOS部首</td><td align="left">400000</td><td align="left">4000F0</td><td align="left">0xF0=240</td></tr><tr><td align="left">PE文件头</td><td align="left">4000F0</td><td align="left">4001E8</td><td align="left">0xF8=244=224+40</td></tr><tr><td align="left">块表</td><td align="left">4001E8</td><td align="left">4002B0</td><td align="left">0xC8=200=5*40</td></tr><tr><td align="left">前三个结构</td><td align="left">400000</td><td align="left">401000</td><td align="left">0x1000（内存对齐后）</td></tr><tr><td align="left">第一个块</td><td align="left">401000</td><td align="left">59B000</td><td align="left">0x19A000（内存对齐后）</td></tr></tbody></table><hr><h1 id="对比PE两种状态"><a href="#对比PE两种状态" class="headerlink" title="对比PE两种状态"></a>对比PE两种状态</h1><p>本笔记主要针对PE两种状态中的文件对齐和内存对齐进行比较，<strong>其它的内容暂时没有涉及</strong>，将在后续笔记里陆续提到</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>无论是在运行态还是在非运行态，DOS部首、PE文件头、块表块表均为连续存储，中间没有空隙</p><p>第一个块表的首地址都受DOS部首大小+PE文件头大小+块表大小影响，都需要对齐</p><p>块和块之间也都需要对齐</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>运行态和非运行态的起始地址不同</p><p>在非运行态中，块表和块之间的空隙由<strong>文件对齐</strong>产生，块和块之间的空隙由<strong>文件对齐</strong>产生</p><p>在运行态中，块表和块之间的空隙由<strong>内存对齐</strong>产生，块和块之间的空隙由<strong>内存对齐</strong>产生</p><hr><h2 id="非运行态和运行态映射图"><a href="#非运行态和运行态映射图" class="headerlink" title="非运行态和运行态映射图"></a>非运行态和运行态映射图</h2><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210316163800340.png" alt="image-20210316163800340"></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>附上本笔记中分析的EverEdit文件：<a href="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/EverEdit.zip?versionId=CAEQHhiBgID6g6vXxBciIDMxMjY5Y2Q0NGE5NTRkNmNiNTUwOGM0YjdmZTQxMTI3">点我下载</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件笔记一 PE介绍</title>
      <link href="2021/06/12/pe%E6%80%BB%E7%BB%931/"/>
      <url>2021/06/12/pe%E6%80%BB%E7%BB%931/</url>
      
        <content type="html"><![CDATA[<p>近期发现了一个超牛逼的大佬，和大佬写的超详细的pe总结，所以就根据（抄袭）大佬文章做一些pe总结来巩固学习。</p><p>先挂上大佬文章链接：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1391994&amp;page=1&amp;extra=#37411342_pe%E5%9C%A8c%E4%B8%AD%E7%9A%84%E5%AE%9A%E4%B9%89</a></p><h5 id="可执行文件的格式"><a href="#可执行文件的格式" class="headerlink" title="可执行文件的格式"></a>可执行文件的格式</h5><hr><h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><p>PE(Portable Executable)<strong>文件结构</strong></p><h4 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h4><p>ELF(Executable and Linking Format)<strong>文件结构</strong></p><hr><h5 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h5><p>.exe .dll .sys都是windows下常见的可执行文件。（他们都遵循pe文件结构大二的格式）</p><hr><h5 id="常见的非可执行文件"><a href="#常见的非可执行文件" class="headerlink" title="常见的非可执行文件"></a>常见的非可执行文件</h5><ul><li>.txt .png .mp4等等都是非可执行文件，它们都需要使用其它可执行文件的软件进行加载</li><li>.txt可以使用Notepad、UltraEdit等 文本 工具查看</li><li>.png可以使用PhotoShop等 图片 工具查看</li><li>.mp4可以使用PotPlayer等 播放器 工具查看</li></ul><hr><h5 id="为什么要学习pe"><a href="#为什么要学习pe" class="headerlink" title="为什么要学习pe"></a>为什么要学习pe</h5><ul><li>pe是windows下可执行文件必须遵循的规范</li><li>对软件的加壳与脱壳都基于pe</li><li>EXE文件如何加载到内存中也涉及PE的知识</li><li>一个合格的逆向人员，必须熟悉PE</li></ul><hr><h5 id="如何识别pe文件"><a href="#如何识别pe文件" class="headerlink" title="如何识别pe文件"></a>如何识别pe文件</h5><p>不管是.exe .dll还是.sys ，他们都是pe文件，所以他们的前两个字节一定都是4D 5A(ASCII码为MZ)</p><p>我们用winhex打开三种文件观察一下（这里直接没用大佬的三张图）</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131655743.png" alt="exe文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315131945543.png" alt="dll文件"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315132009119.png" alt="sys文件"></p><hr><h5 id="3Ch位置的数据（不做总结了）"><a href="#3Ch位置的数据（不做总结了）" class="headerlink" title="3Ch位置的数据（不做总结了）"></a>3Ch位置的数据（不做总结了）</h5><hr><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>如果一个文件，它的头两个字节为4D 5A（ASCII码为MZ），并且通过3Ch位置的数据再找到的位置里的数据为PE则基本可以断定这个文件是Windows下的可执行文件（满足PE结构）</p><hr><h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><p>随便拉一个图片png文件进来看看</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315134549954.png" alt="image-20210315134549954"></p><p>很显然，开头的两个字节就已经表明它不是一个PE文件了</p><p>PS：识别可执行文件不能通过文件的后缀名来判断，而应该采用上述的方式进行判断，因为后缀名是可以改的。</p><hr><p>通过前面列举的知识，我们已经知道如何识别一个pe文件了，但是为什么是查看一个文件的前2个字节和3Ch的位置，以及其它位置数据作用呢。</p><p>这便是PE结构所<strong>规定</strong>的</p><h5 id="下面是PE文件的总体结构"><a href="#下面是PE文件的总体结构" class="headerlink" title="下面是PE文件的总体结构"></a>下面是PE文件的总体结构</h5><hr><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144634951.png" alt="pe文件结构"></p><hr><p>可以看到先前判断PE文件特征里的头两个字节对应这里的文件头：DOS ‘MZ’ HEADER</p><p>后面根据3Ch得到的50 45（对应ACSII码为PE）对应这里的PE文件头中的”PE”</p><hr><p>（接下来是重点）</p><hr><h5 id="pe在c中的定义"><a href="#pe在c中的定义" class="headerlink" title="pe在c中的定义"></a>pe在c中的定义</h5><p>pe文件结构自然也是一种数据结构（比较复杂的数据结构）</p><p>在c语言中的winnt.h这个头文件中定义了pe文件结构相关的结构体。</p><p>所以我们可以直接通过c语言中的pe的定义来更好的学习pe</p><p>（直接cv大佬）</p><p>随便创建一个空的控制台项目，然后引入winnt.h这个头文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103747813.png" alt="image-20210612103747813"></p><p>然后在引入的头文件处右键转到文档</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612103935331.png" alt="image-20210612103935331"></p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104002548.png" alt="image-20210612104002548"></p><p>接下来大佬就会根据这个头文件来学习pe文件的总体结构了</p><hr><h5 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h5><p>该部分结构对应winnt.h中的**_IMAGE_DOS_HEADER**结构体</p><p>可以在先前打开的winnt.h中Ctrl+F搜索_IMAGE_DOS_HEADER</p><p>查找后得到</p><p><img src="/.com//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210612104222424.png" alt="image-20210612104222424"></p><p>这里贴上大佬提出来的字段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><hr><p>这里我们只需要关注这两个字段就好了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WORD   e_magic                *    <span class="string">&quot;MZ标记&quot;</span> 用于判断是否为可执行文件.</span><br><span class="line">DWORD  e_lfanew;              *    PE头相对于文件的偏移，用于定位PE文件</span><br></pre></td></tr></table></figure><hr><h3 id="PE文件头-NT头"><a href="#PE文件头-NT头" class="headerlink" title="PE文件头(NT头)"></a>PE文件头(NT头)</h3><p>该部分结构对应winnt.h中的**_IMAGE_NT_HEADERS**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>可以看到PE文件头对应的结构体中还包含了其它结构体，这里依旧只介绍大体作用，细节留作之后的笔记</p><p>这里的PE文件头相对于先前的DOS部首则是<strong>给Windows使用的</strong></p><hr><h3 id="块表-节表"><a href="#块表-节表" class="headerlink" title="块表(节表)"></a>块表(节表)</h3><p>该部分结构对应winnt.h中的**_IMAGE_SECTION_HEADER**结构体</p><p>使用同样的方法得到对应的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 复制代码 隐藏代码typedef struct _IMAGE_SECTION_HEADER &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    union &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>块表主要用来表示当前文件一共分为几个部分，和后面的块相对应</p><p>块表决定了后面的块，每一块从哪里开始，里面存储的数据是什么等等</p><hr><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块部分是由前面的块表决定的，是具体的存储数据的部分</p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315144652675.png" alt="image-20210315144652675"></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210315195059766.png" alt="image-20210315195059766"></p><p><img src="https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/PE.png" alt="PE"></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构新增节</title>
      <link href="2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/"/>
      <url>2021/06/11/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%96%B0%E5%A2%9E%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>首先先了解一下节表</strong></p><p>如下图，打开一个exe文件，我们可以看到有多个节表。<br><img src="https://img-blog.csdnimg.cn/20210611093247579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要有这么多节表呢？每个节表都有自己的任务与功能，所以我们可以手动添加一个节来实现我们自己想实现的功能。</p><hr><p>然后我们在了解一下节表的主要成员：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//8个字节名字.自己可以起.编译器也可以给定.不重要.</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;       </span><br><span class="line">            DWORD   VirtualSize;           <span class="comment">//节数据没有对齐后的大小.也就是没有对齐.节数据有多大.</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;　　　　　　　　　　<span class="comment">//加载到内存中的第一个字节的地址.也就是虚拟地址.节在内存中哪里开始.内存中的VA + ImageBase 才是真正的节开始位置</span></span><br><span class="line">    DWORD   SizeOfRawData;　　　　　　　　　　 <span class="comment">//修改这个属性的值,即可扩大节.并且在PE文件中添加相应的0数据进行填充.</span></span><br><span class="line">    DWORD   PointerToRawData;　　　　　　　　  <span class="comment">//在文件中的偏移.是文件对齐成员倍数.</span></span><br><span class="line">    DWORD   PointerToRelocations;           <span class="comment">//一下都是调试相关.</span></span><br><span class="line">    DWORD   PointerToLinenumbers;           <span class="comment">//</span></span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;　　　　　　　　　　<span class="comment">//节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>重点了解以下成员</p><blockquote><p>Name[IMAGE_SIZEOF_SHORT_NAME]:我们可以随便起一个自己喜欢的名字 VirtualSize：是在内存中的真实大小<br>VirtualAddress：是加载到内存中第一个字节的偏移地址 SizeOfRawData：该节在文件对齐后的大小</p></blockquote><hr><p>了解过节表以后，我们再来整理一下操作步骤。</p><p>[TOC]</p><h1 id="1-判断是否有空间新增一个节。"><a href="#1-判断是否有空间新增一个节。" class="headerlink" title="1.判断是否有空间新增一个节。"></a>1.判断是否有空间新增一个节。</h1><p>使用工具打开一个exe文件，我们只需要40个字节，所以空间足够<br><img src="https://img-blog.csdnimg.cn/20210611122435362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="2-在节表的最后一个成员后新增一个成员。"><a href="#2-在节表的最后一个成员后新增一个成员。" class="headerlink" title="2.在节表的最后一个成员后新增一个成员。"></a>2.在节表的最后一个成员后新增一个成员。</h1><p>添加的新成员我们可以选择直接复制text节表，因为text作为代码段，可读可写可执行，非常完美。如下图，我们已经添加好了数据。<br><img src="https://img-blog.csdnimg.cn/20210611122700675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="3-修改节的数量。"><a href="#3-修改节的数量。" class="headerlink" title="3.修改节的数量。"></a>3.修改节的数量。</h1><p>标准pe头中有一个字段为 NumberOfSections，该字段控制文件中节的数量<br>，所以我们讲该字段的值加一，如下图，原来为08，我们修改为09</p><p><img src="https://img-blog.csdnimg.cn/20210611153418937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="4-修改sizeOfImage的大小"><a href="#4-修改sizeOfImage的大小" class="headerlink" title="4.修改sizeOfImage的大小"></a>4.修改sizeOfImage的大小</h1><p>修改前：<br>可选头中：SizeofImage ：000AC000<br><img src="https://img-blog.csdnimg.cn/20210611154120619.png" alt="在这里插入图片描述"></p><p>我们新增了0x1000节数据大小.那么我们的镜像大小也要加0x1000大小进行映射.注意.要按照内存对齐。<br>我们的原镜像大小以及按照内存对齐的方式存放了. 就是0xAC000. 那么我们加了0x1000的数据就是 0x1E000大小.我们修改为0xAD000。</p><hr><h1 id="5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍"><a href="#5-再原有数据的最后，新增一个节的数据-内存对齐的整数倍" class="headerlink" title="5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)"></a>5.再原有数据的最后，新增一个节的数据(内存对齐的整数倍)</h1><p>插入了0x1000字节，填充为0</p><hr><h1 id="6-添加新增节表的属性"><a href="#6-添加新增节表的属性" class="headerlink" title="6.添加新增节表的属性"></a>6.添加新增节表的属性</h1><p>想要添加一个节表，首先我们需要为这个节表指明内存中开始展开的位置，文件中展开的位置，以及节表的大小。<br>这三个属性的字段分别是VirtualAddress、PointerToRawData、SizeOfRawData。然后我们在pe中把他们找出来并修改。<br>例如上一个节表对齐后的展开位置为 0xAc000 那么我们就修改为 0xAd000<br>修改前：<br><img src="https://img-blog.csdnimg.cn/20210611182603575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>修改后：</p><p><img src="https://img-blog.csdnimg.cn/20210611182610388.png" alt="在这里插入图片描述"></p><p>节.sizeofRawData修改<br>这个成员就是节数据按照文件对齐后的大小.取决于我们给这个节添加多少数据，这里我们之前添加了0x1000个字节。<br>　　这里修改为1000<br>　　<br><img src="https://img-blog.csdnimg.cn/20210611182619861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.PointerRawToData 文件偏移修改<br>最后修改的就是节在文件中哪里展开的. 这个我们需要看上一个节的文件偏移.以及节数据大小. 算出来的.<br>例如：<br>新增节的上一个节，偏移位置为1000，节数据在文件中对齐后的尺寸为100，那么1000-1100都是上一个节的数据</p><p>.tttt上一个节在文件中的偏移为8200，大小为600；<br>　那么tttt节的文件偏移就为8800<br>　<img src="https://img-blog.csdnimg.cn/20210611182634534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>节.VirtualSize修改<br>申请的新节空间大小，1000</p><p>节.PointerRawToData 文件偏移修改<br>我们新增节一般都是要求可读可写可执行的，所以这里直接修改为60000020。</p><p>实验结果：<br>新增节后的文件正常执行</p><p><img src="https://img-blog.csdnimg.cn/20210611182641868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>部分内容转载于：<a href="https://blog.csdn.net/weixin_43742894/article/details/115376779">https://blog.csdn.net/weixin_43742894/article/details/115376779</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件结构在空白区添加代码</title>
      <link href="2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/"/>
      <url>2021/06/10/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A9%BA%E7%99%BD%E5%8C%BA%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"><a href="#想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。" class="headerlink" title="想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。"></a><strong>想要再空白区添加代码，首先我们需要清晰一下我们需要做的步骤。</strong></h2></blockquote><p>1.查找本机MessageBoxA地址<br>2.打开OD调试工具拖入要添加的exe程序。<br>3.在命令中输入 : （输入后按下回车键）<br>4.找任意一段空白区添加上代码 （最好是添加到 空白区开始预留一行的位置，便于以后再添加更多代码节约空间）<br>5.计算E8跳转的地址<br>6.修改OEP （程序入口的点）</p><blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2></blockquote><table><thead><tr><th>汇编指令</th><th>硬编码</th></tr></thead><tbody><tr><td>call</td><td>E8 00 00 00 00</td></tr><tr><td>jmp</td><td>E9 00 00 00 00</td></tr><tr><td>push</td><td>6A 00</td></tr></tbody></table><h2 id="1-查找本机MessageBoxA地址"><a href="#1-查找本机MessageBoxA地址" class="headerlink" title="1.查找本机MessageBoxA地址"></a>1.查找本机MessageBoxA地址</h2><p>1.打开OD调试工具拖入要添加的exe程序。<br>讲你想要修改的exe程序拖入od调试工具中，这里我们需要注意该exe程序必须有user32.dll，否则没有我们要添加的代码–MessageA函数的地址。<br><img src="https://img-blog.csdnimg.cn/20210609215454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-在命令中输入-（输入后按下回车键）"><a href="#2-在命令中输入-（输入后按下回车键）" class="headerlink" title="2.在命令中输入 : （输入后按下回车键）"></a>2.在命令中输入 : （输入后按下回车键）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bp MessageBoxA</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210609215640888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如此一来，我们就成功在MessageA函数的地址下了断点。点击断点的窗口即可查看我们设置好的断点。<br><img src="https://img-blog.csdnimg.cn/20210609215811850.png" alt="在这里插入图片描述"></p><h2 id="开始添加代码"><a href="#开始添加代码" class="headerlink" title="开始添加代码"></a>开始添加代码</h2><p>1.接下来就该添加我们想要添加的代码了，随便找一个空白位置，然后我们计算call后的值，<br>call后的值=调用函数的地址-message函数的地址-5（call命令本身所占的内存大小），现在调用函数的地址是在问价中的地址，而不是在内存中的地址，所以首先我们需要找到程序载入内存的基地址ImageBase，在扩展PE头的第 28 个字节后面的 4 个字节表示的 ImageBase ( 程序基地址 )，如下图<br><img src="https://img-blog.csdnimg.cn/20210610205831374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1表示扩展pe头，2表示标准pe头），所以当前调用函数的地址为我们在文件中添加call指令的地址加上imagebase的值，所以call后的值=MessageBoxA的地址 - 当前调用函数的地址 - 5<br>此时计算好地址后，查看对应的硬编码，首先是三个push：6A 00 6A 00 6A 00 6A 00 然后是call 指令 E8，然后写如我们计算好的地址，记得小端存储。<br>代码我们已经写好了，那么我们现在应该想想怎么使程序到这个地址来执行我们添加的代码，我们可以修改程序的入口函数eop，（在扩展PE头的第 16 个字节后面的 4 个字节），如下图<br><img src="https://img-blog.csdnimg.cn/20210610211816996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1程序入口:0x401170（相对于程序基地址）2，扩展PE头的开始）<br>把程序拖入OD，程序第一次停止的的地址就是程序入口<br><img src="https://img-blog.csdnimg.cn/20210610212056621.png" alt="在这里插入图片描述"></p><p>所以只要修改程序入口地址，把程序入口改为调用函数的地址，然后在调用后再返回到真正的程序入口，就可以在程序执行前执行我们想调用的函数</p><p>修改程序入口为0x600</p><p><img src="https://img-blog.csdnimg.cn/20210610212115474.png" alt="在这里插入图片描述"></p><p>现在就9可以达到在程序执行前调用MessgaBoxA函数的效果，但是要执行完这个函数后，再返回到真正的程序入口，不然程序不能够正常运行，于是又要在我们要调用的函数后面再制造一个返回到真正程序入口处的机器码<br>这里就在用到jmp这个指令，表示直接跳转到某个指定的地址</p><p>先看一下jmp要如何使用</p><p><img src="https://img-blog.csdnimg.cn/20210610212230109.png" alt="在这里插入图片描述"></p><p>这里jmp的使用方法其实和call的规律一样只是开头的 E8 变成了 E9</p><p><img src="https://img-blog.csdnimg.cn/20210610212236672.png" alt="在这里插入图片描述"></p><p>所以E9后面的值应该是</p><p>jmp后的值 = 程序入口的地址 - 当前的地址 - 5 = 0x401170 - 0x40060D - 5 = 0x0B5E</p><p>当前的地址应该是0x40060D</p><p>所以修改后就是这样的<br><img src="https://img-blog.csdnimg.cn/20210610212246737.png" alt="在这里插入图片描述"></p><p>此时把程序另存为message_test.exe, 运行出现了我们预期的效果<br><img src="https://img-blog.csdnimg.cn/20210610212254405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>源程序的代码是很简单，但是要注意要有MessageBoxA函数</p><p>不然在最开始没有user32dll，我也不知道为什么，但如果是正常的程序都会有user32dll(因为一般的程序都有窗口)</p><p>我是用下面的代码做的实验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// messge.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nothing...&quot;</span>);</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">&quot;这是已有的弹框&quot;</span>,<span class="string">&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;Hello World!\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单介绍一点点PE文件头结构</p><p>DOS头部分：</p><p>DOS MZ 文件头 (64字节):<br>前 64 个字节，最后 8 个字节表示 PE 文件头的开始位置, DOS 块结束前的位置，绿色箭头指向PE文件头的开始<br><img src="https://img-blog.csdnimg.cn/20210610212422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>DOS 块 (不确定):<br>链接器可插入数据</p><p>PE文件头:</p><p>PE文件标识 (4字节):<br>50 45 00 00</p><p>标准 PE 头 (20字节):</p><p>扩展 PE 头</p><p>(32位 224 [0xE0] , 64 位 240 [0xF0] ):</p><pre><code>  第 36 个字节开始的后 4 个字节表示 硬盘 中文件对齐的字节数大小,  前 4 个字节表示 内存 中文件对齐的字节数大小,  第 60 个字节开始的四个字节表示整个文件头的大小( DOS 部分+ PE 文件头),一定是对齐字节数的整数倍  第 16 个字节后面的 4 个字节表示程序入口(相对 ImageBase )  第 28 个字节后面面的 4 个字节表示的 ImageBase ( 程序基地址 )</code></pre><p>图片与部分内容转载于<a href="https://blog.csdn.net/m0_49490199/article/details/111657821">https://blog.csdn.net/m0_49490199/article/details/111657821</a></p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于硬编码的一些理解（水）</title>
      <link href="2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/"/>
      <url>2021/06/08/%E5%AF%B9%E4%BA%8E%E7%A1%AC%E7%BC%96%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E6%B0%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在最近的学习过程中，了解到了硬编码这一个名词，于是就去百度了一下，从字面意思上来看，我对硬编码的理解就是一种类似于编程语言的东西，但百度过后发现好像每一篇文章对硬编码的讲解都不大一样，搞得我一脸懵逼，于是就来总结一下各篇文章的讲解。首先我们看一下百度百科的结果：</p><blockquote><p>硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。<br>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。<br>硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。<br>另一方面，软编码数据对用户输入，HTTP服务器响应或配置文件等任意信息进行编码，并在运行时确定。</p></blockquote><p>看完以后仍然一脸懵逼，于是继续百度，过程中看到了一个例子：<br><strong>硬编码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">　　a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a直接用固定数值2限定死了，如果想要修改的话(修改a的值或者==号右边的值都是很不方便的，而且很容易出错）很不方便。</p><p><strong>软编码</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">　　a ++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此，a和b都是变量名称，我们完全可以在初始化a和b的时候给二者赋值，不必直接用固定数值限定死，这样有利于方便修改，可谓”占据制高点，统筹全局”。<br>转载于:<a href="https://www.cnblogs.com/zhongshujunqia/p/4611543.html">https://www.cnblogs.com/zhongshujunqia/p/4611543.html</a></p><p>看过这两条例子以后，大概了解到硬编码只是一种编程方式。再结合百度百科的结果：<strong>硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。</strong>大概了解到硬编码是把一个本来应该（可以）写到配置信息中的信息直接在程序代码中写死了。<br>例如，写了一个收发邮件的程序，用户名，密码，服务器地址等最好做成外部配置， 但是如果直接写死在程序代码中，每次改信息时需要重新编译了……这种程序不好维护。一般懒的程序员或者初学者这种程序产量较大。<br>在计算机程序或文本编辑中，hardcode(这个词比hard code用起来要频繁一些)是指将可变变量用一个固定值来代替的方法。<br>用这种方法编译后，如果以后需要更改此变量就非常困难了。<br>大部分程序语言里，可以将一个固定数值定义为一个标记，然后用这个特殊标记来取代变量名称。当标记名称改变时，变量名不变，这样，当重新编译整个程序时，所有变量都不再是固定值，这样就更容易的实现了改变变量的目的。<br>尽管通过编辑器的查找替换功能也能实现整个变量名称的替换，但也很有可能出现多换或者少换的情况，而在计算机程序中，任何小错误的出现都是不可饶恕的。<br>最好的方法是单独为变量名划分空间，来实现这种变化，就如同前面说的那样，将需要改变的变量名暂时用一个定义好的标记名称来代替就是一种很好的方法。<br>通常情况下，都应该避免使用hardcode方法。有时也用hardcode来形容那些非常难学的语言，比如C或者C++语言，相对的，用softcode来形容象VB这类简单好用的程序语言。<br><strong>hardcode就是固化的代码</strong>。有的代码不能写死，不然修改起来很麻烦。比如说写链接写死<a href="http://www.abc.com,所有的地方都用这个,如果下次域名变了,那么就要找到所有的www.abc.com修改成新的域名./">www.abc.com，所有的地方都用这个，如果下次域名变了，那么就要找到所有的www.abc.com修改成新的域名。</a><br>但是如果用一个常量来存放<a href="http://www.abc.com,然后所有链接都引用常量,那么以后修改就只要修改常量了./">www.abc.com，然后所有链接都引用常量，那么以后修改就只要修改常量了。</a></p><p>部分内容参考于<a href="https://zhuanlan.zhihu.com/p/54134459">https://zhuanlan.zhihu.com/p/54134459</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe文件对齐</title>
      <link href="2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/"/>
      <url>2021/06/08/pe%E6%96%87%E4%BB%B6%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>内存对齐与文件对齐</strong></p></blockquote><p>一个pe文件无论在磁盘和内存中存放都会进行对齐，但他们的对齐值会不相同。<br>PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。<br>PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。<br>rva与fov的相互转换</p><blockquote><p><strong>RVA与FOV的相互转换</strong></p></blockquote><p>为什么要转换：可以通过内存位置.找到文件中这个数据的位置. 或者反之. 如果找到就可以进行修改了。<br>RVA(Relative Virtual Address)指的是内存中的一个数据相对于文件头位置的偏移量。<br>举个例子：<br>当我们想要访问一个数据时，如果 Windows 装载器将一个PE 文件装入到 00400000h 处的内存中，而某个区块中的某个数据被装入 0040…xh 处，那么这个数据的 RVA 就是（0040…xh - 00400000h ）= …xh。(RVA = 虚拟地址-ImageBase(模块基址.程序一开始的地址.))<br>FOV与RVA大致相同，FOV指的是文件在硬盘中时访问的数据的的位置相对于文件头位置的偏移量。<br>所以由此我们可以看到他们之间的关系。当rva的位置在文件头中时，由于rva还没有收到拉伸的影响，所以此时rva等于fov的值。<br>当不在文件头中时，我们只需要计算出数据的位置，与该数据所在的节的差值，然后该差值是与硬盘中的数据所在位置与所在节的差值相同，所以我们先求出差值=rva-节<em>virtualadress(内存对齐值)。然后fov=差值+节</em>pointertorawData(文件对齐值)。</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/06/01/pe%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/01/pe%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a><strong>DOS头</strong></h2></blockquote><p>typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header<br>WORD   e_magic;                     // 一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都是’MZ’开头。<br>WORD   e_cblp;                      <br>WORD   e_cp;                        <br>WORD   e_crlc;                      <br>WORD   e_cparhdr;                <br>WORD   e_minalloc;                  <br>WORD   e_maxalloc;                <br>WORD   e_ss;                      <br>WORD   e_sp;                      <br>WORD   e_csum;                <br>WORD   e_ip;                        <br>WORD   e_cs;                        <br>WORD   e_lfarlc;                <br>WORD   e_ovno;                <br>WORD   e_res[4];      <br>WORD   e_oemid;                  <br>WORD   e_oeminfo;                  <br>WORD   e_res2[10];                <br>LONG   e_lfanew;                    //Offset to start of PE header   指向PE文件头<br>  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;                                        </p><blockquote><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a><strong>PE文件头</strong></h2></blockquote><p>IMAGE_NT_HEADERS STRUCT<br>DWORD Signature                    PE文件标识<br>IMAGE_FILE_HEADER  FileHeader     pe标准文件头<br>IMAGE_OPTIONAL_HEADER32 OptionalHeader<br>IMAGE_NT_HEADERS ENDS                                        </p><blockquote><h2 id="pe标准文件头"><a href="#pe标准文件头" class="headerlink" title="pe标准文件头"></a><strong>pe标准文件头</strong></h2></blockquote><p>typedef struct_IMAGE_FILE_HEADER{<br>WORD Machine;          //可以运行在什么cpu上，任意: 0   Intel 386以及后续: 14C   x86: 8864<br>WORD NumberOfSections;                  //表示节的数量(一共有多少个节)<br>DWORD TimeDataStamp;              //编写器填写的时间戳 与文件属性里面(创建时间、修改时间)无关<br>DWORD PointerToSymbolTable          //调试相关<br>DWORD PointerOfSymbols;             //调试相关<br>WORD SizeOfOptionalHeader             //可选PE头的大小(32位PE文件;  0xE0 64位PE文件: 0xF0)<br>WORD Characteristics;               //文件属性<br>}IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;                                        </p><blockquote><h2 id="pe可选文件头"><a href="#pe可选文件头" class="headerlink" title="pe可选文件头"></a><strong>pe可选文件头</strong></h2></blockquote><p>//32位的可选pe头长度为E0， 64位的可选pe头长度为F0</p><p>WORD    Magic;        *                说明文件类型：10B 32位下的PE文件     20B 64位下的PE文件<br>BYTE    MajorLinkerVersion;<br>BYTE    MinorLinkerVersion;<br>DWORD   SizeOfCode;*                所有代码节的和，必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfInitializedData;*                已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   SizeOfUninitializedData;*                未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的  没用<br>DWORD   AddressOfEntryPoint;*                程序入口<br>DWORD   BaseOfCode;*                代码开始的基址，编译器填的   没用<br>DWORD   BaseOfData;*                数据开始的基址，编译器填的   没用<br>DWORD   ImageBase;*                内存镜像基址<br>DWORD   SectionAlignment;*                内存对齐<br>DWORD   FileAlignment;*                文件对齐<br>WORD    MajorOperatingSystemVersion;<br>WORD    MinorOperatingSystemVersion;<br>WORD    MajorImageVersion;<br>WORD    MinorImageVersion;<br>WORD    MajorSubsystemVersion;<br>WORD    MinorSubsystemVersion;<br>DWORD   Win32VersionValue;<br>DWORD   SizeOfImage;*                内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍<br>DWORD   SizeOfHeaders;*                所有头+节表按照文件对齐后的大小，否则加载会出错<br>DWORD   CheckSum;*                校验和，一些系统文件有要求.用来判断文件是否被修改.<br>WORD    Subsystem;<br>WORD    DllCharacteristics;<br>DWORD   SizeOfStackReserve;*                初始化时保留的堆栈大小<br>DWORD   SizeOfStackCommit;*                初始化时实际提交的大小<br>DWORD   SizeOfHeapReserve;*                初始化时保留的堆大小<br>DWORD   SizeOfHeapCommit;*                初始化时实践提交的大小<br>DWORD   LoaderFlags;<br>DWORD   NumberOfRvaAndSizes;*                目录项数目，剩余结构体的数量            </p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#109;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
