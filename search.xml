<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pe字段总结(持续更新中...)</title>
      <link href="2021/06/01/pe%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/01/pe%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>首先放一张pe文件结构图</strong><br><img src="https://img-blog.csdnimg.cn/20210601212954990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pe文件结构大致分为以下几个部分<br><img src="https://img-blog.csdnimg.cn/20210601175248115.png" alt="在这里插入图片描述"></p><p>DOS头是用来兼容MS-DOS操作系统的<br>NT头包含windows PE文件的主要信息<br>节表：是PE文件后续节的描述<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义。<br>在学习pe文件结构中，熟悉文件结构图非常重要，下面我们就来一起学习一下。</p><blockquote><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a><strong>DOS头</strong></h2></blockquote><p>IMAGE_DOS_HEADER STRUCT</p><p>{<br> <strong>+0hWORDe_magic //这个字段是来标示是否为Dos 程序的，如果是的话那么就会有MZ 的标记</strong></p><p>   +2h WORD e_cblp //Bytes on last page of file</p><p>   +4hWORD e_cp //Pages in file</p><p>   +6hWORD e_crlc //Relocations</p><p>   +8hWORD e_cparhdr //Size of header in paragraphs</p><p>   +0ahWORD e_minalloc //Minimun extra paragraphs needs</p><p>   +0chWORD e_maxalloc //Maximun extra paragraphs needs</p><p>   +0ehWORD e_ss //intial(relative)SS value DOS 代码的初始化堆栈SS</p><p>   +10hWORD e_sp //intial SP value DOS 代码的初始化堆栈指针SP</p><p>   +12hWORD e_csum //Checksum</p><p>   +14hWORD e_ip // intial IP value DOS 代码的初始化指令入口[指针IP]</p><p>   +16hWORD e_cs //intial(relative)CS value DOS 代码的初始堆栈入口</p><p>   +18hWORD e_lfarlc //File Address of relocation table</p><p>   +1ahWORD e_ovno // Overlay number</p><p>   +1chWORD e_res[4] //Reserved words</p><p>   +24hWORD e_oemid // OEM identifier(for e_oeminfo)</p><p>   +26hWORD e_oeminfo // OEM information;e_oemid specific</p><p>   +29hWORD e_res2[10] // Reserved words</p><p>   <strong>+3chDWORD e_lfanew //这是一个指向PE 文件头的指针，指出了PE 文件头在PE 文件中的偏移。如果这个值为0，那么说明这个exe 文件是一个Dos 程序，windows 会启动Dos 子系统来运行它。</strong></p><p>} IMAGE_DOS_HEADER ENDS</p><blockquote><h2 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h2></blockquote><p>PE头实际上是一个IMAGE_NT_HEADER结构，它的定义为：</p><p> IMAGE_NT_HEADERS STRUCT<br><strong>+0hDWORDSignature   //在一个有效的PE 文件里，Signature 字段被设置为00004550h, ASCII 码字符是“PE00”。标志这PE 文件头的开始。“PE00” 字符串是PE 文件头的开始， DOS 头部的e_lfanew 字段正是指向这里。</strong></p><p>+4h IMAGE_FILE_HEADER FileHeader //PE标准文件头</p><p>+18hIMAGE_OPTIONAL_HEADER32OptionalHeader //PE可选文件头</p><p>} IMAGE_NT_HEADERS ENDS</p><blockquote><p>PE标准文件头</p></blockquote><p>typedef struct _IMAGE_FILE_HEADER</p><p>{</p><p>+04h WORD Machine; // 可执行文件的目标cpu类型</p><p>+06h WORD NumberOfSections; // 文件的区块数目</p><p>+08h DWORDTimeDateStamp; // 文件创建日期和时间</p><p>+0Ch DWORD PointerToSymbolTable; // 指向符号表(主要用于调试)</p><p>+10hDWORD NumberOfSymbols; // 符号表中符号个数(同上)</p><p>+14h WORD SizeOfOptionalHeader; // IMAGE_OPTIONAL_HEADER32 结构大小</p><p>+16h WORD Characteristics; // 文件属性</p><p>} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</p>]]></content>
      
      
      <categories>
          
          <category> pe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc函数</title>
      <link href="2021/05/31/malloc%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/31/malloc%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>今天学习了malloc函数，个人感觉就是一个划分内存空间的工具，<br>以下是关于malloc函数的定义。<br>C语言中malloc是动态内存分配函数。<br>函数原型：<code>void *malloc(unsigned int num_bytes);</code><br>参数：num_bytes 是无符号整型，用于表示分配的字节数。<br>返回值：如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者…）<br>功能：分配长度为num_bytes字节的内存块<br>注意：当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。关于该函数的原型，在以前malloc返回的是char型指针，新的ANSIC标准规定，该函数返回为void型指针，因此必要时要进行类型转换。<br>我们来观看一下实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span><span class="comment">//malloc()函数被包含在malloc.h里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*a=<span class="literal">NULL</span>;<span class="comment">//声明一个指向a的char*类型的指针</span></span><br><span class="line">    </span><br><span class="line">a=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//使用malloc分配内存的首地址，然后赋值给a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)<span class="comment">//如果malloc失败，可以得到一些log</span></span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(a,<span class="string">&quot;%s&quot;</span>,<span class="string">&quot;HelloWorld\n&quot;</span>);<span class="comment">//&quot;HelloWorld\n&quot;写入a指向的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,a);<span class="comment">//输出用户输入的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">//释放掉使用的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//例2有无内存泄露？</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果，<br>我在再来看一下反汇编窗口<br><img src="https://img-blog.csdnimg.cn/20210531175142777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvYXRfMjAwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到区别，编译器在运行我们写的代码时，会提前根据所定义的类型来给我们分配缓冲区，也就是堆栈空间，例如图中对变量b的定义与赋值，而我们使用amlloc函数时，则会给我们额外分配动态内存（push 64h）。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于搭建博客时遇到的麻烦报错</title>
      <link href="2021/05/30/001/"/>
      <url>2021/05/30/001/</url>
      
        <content type="html"><![CDATA[<p><strong>1、hexo初始化博客</strong><br>这里主要有两个命令，一个是npm install -g hexo-cli，这个命令能碰到的的问题主要是卡住，建议下载一个淘宝镜像<br>第二个是hexo init，这里的问题整整卡了我两天，我的报错是（fatal: unable to access …）解决方法:首先我们可以去添加三条新的环境变量，添加万这三条以后去博客根目录里hexobush并再次输入命令，问题基本解决，如果还不行的话，可以去cmd里再次输入。<br><img src="/images/001/001.jpg" alt="001"><br><strong>2、hexo d命令</strong><br>该命令意思是讲你的本地文件夹上传到github上，解决方法是查看你的根目录配置文件，翻到最下面查看branch后的代码，如果是march请将它改为main，具体原因好像是因为github最近讲march分支改为了main分支。如果还未解决的话可能是因为你的repository设置有问题（还是根目录配置文件的最底层）这里我们放置的链接必须是ssh链接，如下图，因为我们是通过ssh与github获得连接的，所以使用https的形式会报错。<br><img src="/images/001/002.jpg" alt="002"></p><p><strong>3、git clone命令</strong><br>使用该命令时报错 fatal: remote error: You can’t push to git，解决方法参考下面的文章<br><a href="https://xvideos.blog.csdn.net/article/details/52367128">https://xvideos.blog.csdn.net/article/details/52367128</a><br>大概意思是由于我们与github建立的是ssh连接，而我们在git clone时并没有通过ssh的方式去获得连接如一下报错<br>fatal: remote error:<br>You can’t push to git://github.com/user_name/user_repo.git<br>Use <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:user_name/user_repo.git<br>这里我们只需要使用以下代码就可以了<br>$ git remote rm origin<br>$ git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:user_name/user_repo.git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vs编写c语言时的不安全报错</title>
      <link href="2021/05/30/5-30/"/>
      <url>2021/05/30/5-30/</url>
      
        <content type="html"><![CDATA[<p>之所以会报错，是因为vs觉得scanf函数不安全，所以我们只需要取消安全检查就可以了，在头文件前加上 _CRT_SECURE_NO_WARNING 就可以了</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/28/hello-world/"/>
      <url>2021/05/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
